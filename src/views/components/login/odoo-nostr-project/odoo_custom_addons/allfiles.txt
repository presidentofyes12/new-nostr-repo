Home dir: ~/oldhome/home/impromise/Downloads/Telegram Desktop/nostr-w-relay-main (2)/nostr-w-relay-main (1)/src/views/components/login/odoo-nostr-project/odoo_custom_addons/

=== ./git_repository_anchor/models/__init__.py ===
from . import repository_anchor
from . import branch_manager
from . import odoo_models
=== ./git_repository_anchor/models/repository_anchor.py ===
import logging
import time
from functools import wraps
from odoo import models, fields, api
from nostr.key import PrivateKey
from nostr.event import Event, EventKind
import json

def log_execution_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        logging.debug(f"{func.__name__} executed in {end_time - start_time:.2f} seconds")
        return result
    return wrapper

class RepositoryAnchor(models.AbstractModel):
    _name = 'git.repository.anchor'
    _description = 'Git Repository Anchor'

    @api.model
    def _get_private_key(self):
        # In practice, you'd retrieve this securely
        return PrivateKey()

    @log_execution_time
    def create_repository(self, name, path, description, maintainers):
        private_key = self._get_private_key()
        logging.info(f"Creating repository: {name}")
        
        repo = self.env['git.repository'].create({
            'name': name,
            'path': path,  # Add this line
            'description': description,
            'maintainer_ids': [(6, 0, maintainers)],
        })
        
        event = Event(
            kind=EventKind.GENERIC,
            content=json.dumps({
                'action': 'create_repository',
                'name': name,
                'path': path,  # Add this line
                'description': description,
                'maintainers': maintainers,
            }),
            tags=[['e', 'git_repository']]
        )
        private_key.sign_event(event)
        
        self.env['git.event'].create({
            'event_type': 'create_repository',
            'content': event.to_json(),
        })
        
        return repo

    @log_execution_time
    def update_repository(self, repo, description=None, maintainers=None):
        logging.info(f"Updating repository: {repo.name}")
        
        update_vals = {}
        if description is not None:
            update_vals['description'] = description
        if maintainers is not None:
            update_vals['maintainer_ids'] = [(6, 0, maintainers)]
        
        repo.write(update_vals)
        
        private_key = self._get_private_key()
        event = Event(
            kind=EventKind.GENERIC,
            content=json.dumps({
                'action': 'update_repository',
                'repo_id': repo.id,
                'description': description,
                'maintainers': maintainers,
            }),
            tags=[['e', 'git_repository']]
        )
        private_key.sign_event(event)
        
        self.env['git.event'].create({
            'event_type': 'update_repository',
            'content': event.to_json(),
        })
        
        return repo

    @log_execution_time
    def fork_repository(self, original_repo, new_name, new_maintainer):
        logging.info(f"Forking repository: {original_repo.name} to {new_name}")
        
        forked_repo = self.env['git.repository'].create({
            'name': new_name,
            'description': f"Forked from {original_repo.name}",
            'maintainer_ids': [(6, 0, [new_maintainer])],
        })
        
        private_key = self._get_private_key()
        event = Event(
            kind=EventKind.GENERIC,
            content=json.dumps({
                'action': 'fork_repository',
                'original_repo_id': original_repo.id,
                'new_name': new_name,
                'new_maintainer': new_maintainer,
            }),
            tags=[['e', 'git_repository']]
        )
        private_key.sign_event(event)
        
        self.env['git.event'].create({
            'event_type': 'fork_repository',
            'content': event.to_json(),
        })
        
        return forked_repo

    @log_execution_time
    def list_maintainers(self, repo):
        logging.info(f"Listing maintainers for repository: {repo.name}")
        return repo.maintainer_ids
=== ./git_repository_anchor/models/odoo_models.py ===
from odoo import models, fields, api
import logging

_logger = logging.getLogger(__name__)

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    description = fields.Text(string='Description')
    maintainer_ids = fields.Many2many('res.users', string='Maintainers')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)
    last_updated = fields.Datetime(string='Last Updated', default=fields.Datetime.now)
    branch_ids = fields.One2many('git.branch', 'repository_id', string='Branches')

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        res = super(GitRepository, self).fields_get(allfields, attributes)
        _logger.info(f"Fields in GitRepository model: {res.keys()}")
        return res

    @api.model
    def search_read(self, domain=None, fields=None, offset=0, limit=None, order=None):
        _logger.info(f"Search_read called with fields: {fields}")
        return super(GitRepository, self).search_read(domain=domain, fields=fields, offset=offset, limit=limit, order=order)

    def read(self, fields=None, load='_classic_read'):
        _logger.info(f"Read called with fields: {fields}")
        return super(GitRepository, self).read(fields=fields, load=load)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._create_default_branch()
        return repo

    def _create_default_branch(self):
        self.env['git.branch'].create({
            'name': 'main',
            'repository_id': self.id,
            'head': 'initial commit',
        })

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    head = fields.Char(string='Head Commit', required=True)

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([
        ('create_repository', 'Create Repository'),
        ('update_repository', 'Update Repository'),
        ('fork_repository', 'Fork Repository'),
        ('create_branch', 'Create Branch'),
        ('update_branch', 'Update Branch'),
        ('delete_branch', 'Delete Branch')
    ], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

class GitRepositoryManager(models.Model):
    _name = 'git.repository.manager'
    _description = 'Git Repository Manager'

    @api.model
    def create_repository(self, name, path, description, maintainer_ids):
        anchor = self.env['git.repository.anchor']
        repo = anchor.create_repository(name, path, description, maintainer_ids)
        return repo.id

    @api.model
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        updated_repo = anchor.update_repository(repo, description, maintainer_ids)
        return updated_repo.id

    @api.model
    def fork_repository(self, original_repo_id, new_name, new_maintainer_id):
        anchor = self.env['git.repository.anchor']
        original_repo = self.env['git.repository'].browse(original_repo_id)
        forked_repo = anchor.fork_repository(original_repo, new_name, new_maintainer_id)
        return forked_repo.id

    @api.model
    def list_maintainers(self, repo_id):
        anchor = self.env['git.repository.anchor']
        repo = self.env['git.repository'].browse(repo_id)
        maintainers = anchor.list_maintainers(repo)
        return maintainers.ids
=== ./git_repository_anchor/models/branch_manager.py ===
from odoo import models, fields, api
from .repository_anchor import log_execution_time

class BranchManager(models.AbstractModel):
    _name = 'git.branch.manager'
    _description = 'Git Branch Manager'

    @api.model
    @log_execution_time
    def create_branch(self, repository_id, name, head):
        repo = self.env['git.repository'].browse(repository_id)
        branch = self.env['git.branch'].create({
            'name': name,
            'repository_id': repository_id,
            'head': head,
        })
        self._create_event('create_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def update_branch(self, branch_id, new_head):
        branch = self.env['git.branch'].browse(branch_id)
        branch.write({'head': new_head})
        self._create_event('update_branch', branch)
        return branch.id

    @api.model
    @log_execution_time
    def delete_branch(self, branch_id):
        branch = self.env['git.branch'].browse(branch_id)
        self._create_event('delete_branch', branch)
        branch.unlink()
        return True

    @api.model
    def _create_event(self, event_type, branch):
        self.env['git.event'].create({
            'event_type': event_type,
            'content': f"{event_type}: {branch.name} in {branch.repository_id.name}",
        })
=== ./git_repository_anchor/__init__.py ===
from . import models
from . import controllers
=== ./git_repository_anchor/__manifest__.py ===
{
    'name': 'Git Repository Anchor',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Manage Git repositories using Nostr events',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/repository_views.xml',
        'data/git_repository_data.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./git_repository_anchor/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,0
access_git_repository_manager,git.repository manager,model_git_repository,base.group_system,1,1,1,1
access_git_branch_user,git.branch user,model_git_branch,base.group_user,1,1,1,0
access_git_branch_manager,git.branch manager,model_git_branch,base.group_system,1,1,1,1
access_git_event_user,git.event user,model_git_event,base.group_user,1,0,0,0
access_git_event_manager,git.event manager,model_git_event,base.group_system,1,1,1,1
access_git_repository_manager_user,git.repository.manager user,model_git_repository_manager,base.group_user,1,1,1,0
access_git_repository_manager_manager,git.repository.manager manager,model_git_repository_manager,base.group_system,1,1,1,1
=== ./git_repository_anchor/tests/test_repository_anchor.py ===
from odoo.tests.common import TransactionCase
from odoo.exceptions import AccessError

class TestRepositoryAnchor(TransactionCase):

    def setUp(self):
        super(TestRepositoryAnchor, self).setUp()
        self.repo_manager = self.env['git.repository.manager'].sudo()
        self.user_admin = self.env.ref('base.user_admin')
        self.user_demo = self.env.ref('base.user_demo')

    def test_create_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "/path/to/test-repo", "Test repository", [self.user_admin.id]
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.name, "test-repo")
        self.assertEqual(repo.path, "/path/to/test-repo")
        self.assertEqual(repo.description, "Test repository")
        self.assertIn(self.user_admin, repo.maintainer_ids)
        self.assertEqual(len(repo.branch_ids), 1)
        self.assertEqual(repo.branch_ids[0].name, 'main')

    def test_update_repository(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        updated_repo_id = self.repo_manager.update_repository(
            repo_id, "Updated description", [self.user_admin.id, self.user_demo.id]
        )
        repo = self.env['git.repository'].browse(updated_repo_id)
        self.assertEqual(repo.description, "Updated description")
        self.assertIn(self.user_demo, repo.maintainer_ids)

    def test_fork_repository(self):
        original_repo_id = self.repo_manager.create_repository(
            "original-repo", "Original repository", [self.user_admin.id]
        )
        forked_repo_id = self.repo_manager.fork_repository(
            original_repo_id, "forked-repo", self.user_demo.id
        )
        forked_repo = self.env['git.repository'].browse(forked_repo_id)
        self.assertEqual(forked_repo.name, "forked-repo")
        self.assertIn(self.user_demo, forked_repo.maintainer_ids)
        self.assertEqual(len(forked_repo.branch_ids), 1)
        self.assertEqual(forked_repo.branch_ids[0].name, 'main')

    def test_list_maintainers(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id, self.user_demo.id]
        )
        maintainer_ids = self.repo_manager.list_maintainers(repo_id)
        self.assertIn(self.user_admin.id, maintainer_ids)
        self.assertIn(self.user_demo.id, maintainer_ids)

    def test_access_rights(self):
        repo_id = self.repo_manager.create_repository(
            "test-repo", "Test repository", [self.user_admin.id]
        )
        
        # Test that non-maintainer can't update the repository
        with self.assertRaises(AccessError):
            self.repo_manager.with_user(self.user_demo).update_repository(
                repo_id, "Unauthorized update"
            )

        # Test that maintainer can update the repository
        self.repo_manager.with_user(self.user_admin).update_repository(
            repo_id, "Authorized update"
        )
        repo = self.env['git.repository'].browse(repo_id)
        self.assertEqual(repo.description, "Authorized update")
=== ./git_repository_anchor/tests/__init__.py ===
from . import test_repository_anchor
=== ./git_repository_anchor/data/README.md ===
# Git Repository Anchor

This Odoo module provides a system for managing Git repositories using Nostr events. It allows users to create, update, and fork repositories, as well as manage branches and maintainers.

## Features

- Create, update, and fork Git repositories
- Manage repository maintainers
- Create and manage branches
- Log all actions as Nostr events
- Odoo views for easy management through the UI
- CLI for standalone usage

## Installation

1. Place the `git_repository_anchor` directory in your Odoo addons path.
2. Update your Odoo apps list.
3. Install the "Git Repository Anchor" module from the Odoo Apps menu.

## Usage

### Through Odoo Interface

1. Navigate to the "Git Repositories" menu item.
2. Use the provided views to manage repositories, branches, and maintainers.

### Using CLI

A CLI script is provided for standalone usage. Example usage:

```bash
python cli_script.py create --name "New Repo" --description "A new repository" --maintainers 1 2
python cli_script.py update --repo-id 1 --description "Updated description"
python cli_script.py fork --original-repo-id 1 --new-name "Forked Repo"
=== ./git_repository_anchor/data/git_repository_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Example repository data -->
        <record id="git_repository_example" model="git.repository">
            <field name="name">Example Repository</field>
            <field name="path">/path/to/example-repo</field>
            <field name="description">This is an example repository created during module installation.</field>
            <field name="maintainer_ids" eval="[(4, ref('base.user_admin'))]"/>
        </record>
    </data>
</odoo>
=== ./git_repository_anchor/views/repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Repository Form View -->
        <record id="view_git_repository_form" model="ir.ui.view">
            <field name="name">git.repository.form</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <form string="Git Repository">
                    <sheet>
                        <group>
                            <field name="name"/>
                            <field name="path"/>
                            <field name="description"/>
                            <field name="maintainer_ids" widget="many2many_tags"/>
                            <field name="created_at"/>
                            <field name="last_updated"/>
                        </group>
                        <notebook>
                            <page string="Branches">
                                <field name="branch_ids">
                                    <tree editable="bottom">
                                        <field name="name"/>
                                        <field name="head"/>
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Repository Tree View -->
        <record id="view_git_repository_tree" model="ir.ui.view">
            <field name="name">git.repository.tree</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <tree string="Git Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="created_at"/>
                    <field name="last_updated"/>
                </tree>
            </field>
        </record>

        <!-- Repository Search View -->
        <record id="view_git_repository_search" model="ir.ui.view">
            <field name="name">git.repository.search</field>
            <field name="model">git.repository</field>
            <field name="arch" type="xml">
                <search string="Search Repositories">
                    <field name="name"/>
                    <field name="path"/>
                    <field name="description"/>
                    <field name="maintainer_ids"/>
                    <filter string="My Repositories" name="my_repositories" domain="[('maintainer_ids', 'in', uid)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Created Date" name="group_by_created_at" context="{'group_by': 'created_at:month'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Repository Action -->
        <record id="action_git_repository" model="ir.actions.act_window">
            <field name="name">Git Repositories</field>
            <field name="res_model">git.repository</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="view_git_repository_search"/>
        </record>

        <!-- Menu Items -->
        <menuitem id="menu_git_repository_root" name="Git Repositories" sequence="10"/>
        <menuitem id="menu_git_repository" parent="menu_git_repository_root" action="action_git_repository" sequence="10"/>
    </data>
</odoo>
=== ./git_repository_anchor/controllers/__init__.py ===
from . import main
=== ./git_repository_anchor/controllers/main.py ===
from odoo import http
from odoo.http import request

class GitRepositoryController(http.Controller):
    @http.route('/git/repository/create', type='json', auth='user')
    def create_repository(self, name, path, description, maintainer_ids):
        repo_manager = request.env['git.repository.manager'].sudo()
        repo_id = repo_manager.create_repository(name, path, description, maintainer_ids)
        return {'success': True, 'repository_id': repo_id}

    @http.route('/git/repository/update', type='json', auth='user')
    def update_repository(self, repo_id, description=None, maintainer_ids=None):
        repo_manager = request.env['git.repository.manager'].sudo()
        updated_repo_id = repo_manager.update_repository(repo_id, description, maintainer_ids)
        return {'success': True, 'repository_id': updated_repo_id}

    @http.route('/git/repository/fork', type='json', auth='user')
    def fork_repository(self, original_repo_id, new_name):
        repo_manager = request.env['git.repository.manager'].sudo()
        forked_repo_id = repo_manager.fork_repository(original_repo_id, new_name, request.env.user.id)
        return {'success': True, 'repository_id': forked_repo_id}

    @http.route('/git/repository/list_maintainers', type='json', auth='user')
    def list_maintainers(self, repo_id):
        repo_manager = request.env['git.repository.manager'].sudo()
        maintainer_ids = repo_manager.list_maintainers(repo_id)
        return {'success': True, 'maintainer_ids': maintainer_ids}
=== ./git_branch_manager/git-branch-manager-module.py ===
# Directory structure:
# git_branch_manager/
# ├── __init__.py
# ├── __manifest__.py
# ├── models/
# │   ├── __init__.py
# │   ├── branch.py
# │   ├── event.py
# │   └── branch_manager.py
# ├── controllers/
# │   ├── __init__.py
# │   └── main.py
# ├── security/
# │   └── ir.model.access.csv
# └── views/
#     ├── branch_views.xml
#     └── event_views.xml

# __init__.py
from . import models
from . import controllers

# __manifest__.py
{
    'name': 'Git Branch Manager',
    'version': '1.0',
    'summary': 'Manage Git branches using Nostr events',
    'description': """
    This module allows you to manage Git branches using Nostr events.
    It integrates with the Nostr-Odoo application to handle branch operations.
    """,
    'author': 'Your Name',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/branch_views.xml',
        'views/event_views.xml',
    ],
    'installable': True,
    'application': True,
}

# models/__init__.py
from . import branch
from . import event
from . import branch_manager

# models/branch.py
from odoo import models, fields

class GitBranch(models.Model):
    _name = 'git.branch'
    _description = 'Git Branch'

    name = fields.Char(string='Branch Name', required=True)
    head = fields.Char(string='Head Commit', required=True)
    created_at = fields.Datetime(string='Created At')
    last_updated = fields.Datetime(string='Last Updated')

# models/event.py
from odoo import models, fields

class GitEvent(models.Model):
    _name = 'git.event'
    _description = 'Git Event'

    event_type = fields.Selection([('create', 'Create'), ('update', 'Update'), ('delete', 'Delete')], string='Event Type')
    content = fields.Text(string='Event Content')
    created_at = fields.Datetime(string='Created At', default=fields.Datetime.now)

# models/branch_manager.py
from odoo import models, api
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time

_logger = logging.getLogger(__name__)

class GitBranchManager(models.AbstractModel):
    _name = 'git.branch.manager'
    _description = 'Git Branch Manager'

    @api.model
    def create_branch(self, name, head):
        _logger.info(f"Creating branch: {name} with head: {head}")
        start_time = time.time()

        try:
            if self.env['git.branch'].search([('name', '=', name)]):
                raise ValueError(f"Branch {name} already exists")

            branch = self.env['git.branch'].create({
                'name': name,
                'head': head,
                'created_at': fields.Datetime.now(),
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'create')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} created in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error creating branch: {str(e)}")
            raise

    @api.model
    def update_branch(self, name, new_head):
        _logger.info(f"Updating branch: {name} to new head: {new_head}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            branch.write({
                'head': new_head,
                'last_updated': fields.Datetime.now(),
            })

            event = self._create_branch_event(branch, 'update')
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} updated in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error updating branch: {str(e)}")
            raise

    @api.model
    def delete_branch(self, name):
        _logger.info(f"Deleting branch: {name}")
        start_time = time.time()

        try:
            branch = self.env['git.branch'].search([('name', '=', name)])
            if not branch:
                raise ValueError(f"Branch {name} does not exist")

            event = self._create_branch_event(branch, 'delete')
            branch.unlink()
            self._publish_event(event)

            end_time = time.time()
            _logger.info(f"Branch {name} deleted in {end_time - start_time:.2f} seconds")
            return True
        except Exception as e:
            _logger.exception(f"Error deleting branch: {str(e)}")
            raise

    def _create_branch_event(self, branch, operation):
        event = Event()
        event.kind = 31227  # Custom event kind for git branch operations
        event.content = json.dumps({
            'operation': operation,
            'name': branch.name,
            'head': branch.head,
            'timestamp': fields.Datetime.now().isoformat(),
        })
        event.tags = [['e', 'git_branch']]

        private_key = PrivateKey()  # In practice, securely store and retrieve this
        event.sign(private_key.hex())

        return event

    def _publish_event(self, event):
        self.env['git.event'].create({
            'event_type': json.loads(event.content)['operation'],
            'content': event.to_message(),
        })
        # Here you would also publish the event to the Nostr network
        # This part depends on how you've implemented your Nostr client in Odoo

# controllers/__init__.py
from . import main

# controllers/main.py
from odoo import http
from odoo.http import request

class GitBranchController(http.Controller):

    @http.route('/git/branch/create', type='json', auth='user')
    def create_branch(self, name, head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.create_branch(name, head)
        return {'success': result}

    @http.route('/git/branch/update', type='json', auth='user')
    def update_branch(self, name, new_head):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.update_branch(name, new_head)
        return {'success': result}

    @http.route('/git/branch/delete', type='json', auth='user')
    def delete_branch(self, name):
        branch_manager = request.env['git.branch.manager'].sudo()
        result = branch_manager.delete_branch(name)
        return {'success': result}

# security/ir.model.access.csv
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_branch_user,access_git_branch_user,model_git_branch,,1,1,1,1
access_git_event_user,access_git_event_user,model_git_event,,1,1,1,1

# views/branch_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_branch_form" model="ir.ui.view">
        <field name="name">git.branch.form</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <form string="Git Branch">
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="head"/>
                        <field name="created_at"/>
                        <field name="last_updated"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_branch_tree" model="ir.ui.view">
        <field name="name">git.branch.tree</field>
        <field name="model">git.branch</field>
        <field name="arch" type="xml">
            <tree string="Git Branches">
                <field name="name"/>
                <field name="head"/>
                <field name="created_at"/>
                <field name="last_updated"/>
            </tree>
        </field>
    </record>

    <record id="action_git_branch" model="ir.actions.act_window">
        <field name="name">Branches</field>
        <field name="res_model">git.branch</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_branch_root" name="Git Branches" sequence="10"/>
    <menuitem id="menu_git_branch" parent="menu_git_branch_root"
              action="action_git_branch" sequence="10"/>
</odoo>

# views/event_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="view_git_event_form" model="ir.ui.view">
        <field name="name">git.event.form</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <form string="Git Event">
                <sheet>
                    <group>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="created_at"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_event_tree" model="ir.ui.view">
        <field name="name">git.event.tree</field>
        <field name="model">git.event</field>
        <field name="arch" type="xml">
            <tree string="Git Events">
                <field name="event_type"/>
                <field name="content"/>
                <field name="created_at"/>
            </tree>
        </field>
    </record>

    <record id="action_git_event" model="ir.actions.act_window">
        <field name="name">Events</field>
        <field name="res_model">git.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_events" parent="menu_git_branch_root"
              action="action_git_event" sequence="20"/>
</odoo>
=== ./nostr_auth/models/__init__.py ===
# File: odoo_custom_addons/nostr_auth/models/__init__.py
from . import res_users
from . import nostr_auth_module
=== ./nostr_auth/models/res_users.py ===
# File: odoo_custom_addons/nostr_auth/models/res_users.py

from odoo import models, fields, api
from odoo.exceptions import ValidationError
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
import base64

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string='Nostr Public Key')
    nostr_private_key = fields.Char(string='Nostr Private Key')
    nostr_relay_url = fields.Char(string='Nostr Relay URL')

    @api.model_create_multi
    def create(self, vals_list):
        nostr_auth = self.env['nostr.auth.module']
        for vals in vals_list:
            if not vals.get('nostr_private_key'):
                keys = nostr_auth.generate_keypair()
                vals['nostr_private_key'] = keys['private_key']
                vals['nostr_public_key'] = keys['public_key']
        return super(ResUsers, self).create(vals_list)

    @api.constrains('nostr_public_key')
    def _check_nostr_public_key(self):
        for user in self:
            if user.nostr_public_key:
                if not user.nostr_public_key.startswith('npub1'):
                    raise ValidationError("Invalid Nostr public key format. It should start with 'npub1'.")

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        user = self.search([('nostr_public_key', '=', public_key)], limit=1)
        if user:
            nostr_auth = self.env['nostr.auth.module']
            if nostr_auth.verify_signature(public_key, message, signature):
                return user.id
        return False
=== ./nostr_auth/models/nostr_auth_module.py ===
# File: odoo_custom_addons/nostr_auth/models/nostr_auth_module.py

from odoo import models, api
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat, NoEncryption
import base64
from bech32 import bech32_encode, bech32_decode, convertbits

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth.module'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_numbers().private_value.to_bytes(32, 'big')
        public_bytes = public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:]
        
        return {
            'private_key': self.bytes_to_nsec(private_bytes),
            'public_key': self.bytes_to_npub(public_bytes)
        }

    @api.model
    def verify_signature(self, public_key, message, signature):
        try:
            public_key_bytes = self.npub_to_bytes(public_key)
            public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), b'\x04' + public_key_bytes)
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def bytes_to_npub(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('npub', data)

    @api.model
    def bytes_to_nsec(self, key_bytes):
        data = convertbits(key_bytes[:32], 8, 5)
        return bech32_encode('nsec', data)
        
    @api.model
    def npub_to_bytes(self, npub):
        hrp, data = bech32_decode(npub)
        return bytes(convertbits(data, 5, 8, False))

    @api.model
    def nsec_to_bytes(self, nsec):
        hrp, data = bech32_decode(nsec)
        return bytes(convertbits(data, 5, 8, False))
=== ./nostr_auth/__init__.py ===
from . import models
=== ./nostr_auth/__manifest__.py ===
# File: odoo_custom_addons/nostr_auth/__manifest__.py
{
    'name': 'Nostr Authentication',
    'version': '1.0',
    'category': 'Authentication',
    'summary': 'Extends user model with Nostr fields and authentication',
    'depends': ['base', 'auth_signup'],
    'data': [
        'views/res_users_views.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'external_dependencies': {
        'python': ['cryptography', 'bech32'],
    },
}
=== ./nostr_auth/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//page[@name='access_rights']" position="after">
                <page string="Nostr Authentication" name="nostr_auth">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_auth/controllers/__init__.py ===
from . import main
=== ./nostr_auth/controllers/main.py ===
# controllers/main.py
from odoo import http
from odoo.http import request
import json

class NostrAuthController(http.Controller):
    @http.route('/web/nostr/authenticate', type='json', auth='none')
    def authenticate(self, public_key, signature, message):
        uid = request.env['res.users'].sudo().authenticate_nostr(public_key, signature, message)
        if uid:
            request.session.authenticate(request.session.db, uid, public_key)
            return {'success': True, 'uid': uid}
        return {'success': False, 'error': 'Authentication failed'}
=== ./nostr_identity/models/__init__.py ===
# models/__init__.py
from . import nostr_identity
from . import nostr_identity_verifier
from . import nostr_message
=== ./nostr_identity/models/nostr_identity_verifier.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging
import json
import websocket
import threading
import ssl
import time
from odoo.tools import config

_logger = logging.getLogger(__name__)

class NostrIdentityVerifier(models.Model):
    _name = 'nostr.identity.verifier'
    _description = 'Nostr Identity Verifier'

    name = fields.Char(string='Name', required=True)
    active = fields.Boolean(default=True)
    relay_url = fields.Char(string='Relay URL', required=True)
    websocket_state = fields.Selection([
        ('disconnected', 'Disconnected'),
        ('connecting', 'Connecting'),
        ('connected', 'Connected')
    ], default='disconnected', string='WebSocket State', readonly=True)
    last_error = fields.Text(string='Last Error', readonly=True)

    def _get_ws_connection(self):
        return self.env.context.get('ws_connection')

    def _set_ws_connection(self, ws):
        self = self.with_context(ws_connection=ws)

    def connect_to_relay(self):
        self.ensure_one()
        if self.websocket_state == 'connected':
            return True

        self.websocket_state = 'connecting'
        self.last_error = False

        try:
            ws = self._create_websocket(self.relay_url)
            self._set_ws_connection(ws)
            
            # Wait for connection to establish or fail
            for _ in range(20):  # Wait up to 10 seconds
                if self.websocket_state == 'connected':
                    return True
                elif self.websocket_state == 'disconnected':
                    raise UserError(self.last_error or _("Connection failed"))
                time.sleep(0.5)

            raise UserError(_("Connection timeout"))
        except Exception as e:
            self.websocket_state = 'disconnected'
            self.last_error = str(e)
            _logger.error(f"Failed to connect to {self.relay_url}: {str(e)}")
            return False

    def _create_websocket(self, relay_url):
        def on_message(ws, message):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_message(message)

        def on_error(ws, error):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_error(error)

        def on_close(ws, close_status_code, close_msg):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_close()

        def on_open(ws):
            with self.pool.cursor() as new_cr:
                self.with_env(self.env(cr=new_cr))._handle_open()

        ws = websocket.WebSocketApp(relay_url,
                                    on_message=on_message,
                                    on_error=on_error,
                                    on_close=on_close,
                                    on_open=on_open)

        wst = threading.Thread(target=lambda: ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}))
        wst.daemon = True
        wst.start()

        return ws

    def _handle_message(self, message):
        _logger.info(f"Received message from {self.relay_url}: {message}")
        self.env['nostr.message'].create({
            'verifier_id': self.id,
            'content': message
        })

    def _handle_error(self, error):
        _logger.error(f"WebSocket error for {self.relay_url}: {error}")
        self.write({'last_error': str(error), 'websocket_state': 'disconnected'})

    def _handle_close(self):
        _logger.info(f"WebSocket connection closed for {self.relay_url}")
        self.write({'websocket_state': 'disconnected'})

    def _handle_open(self):
        _logger.info(f"WebSocket connection opened for {self.relay_url}")
        self.write({'websocket_state': 'connected'})

    def publish_event(self, event):
        self.ensure_one()
        if self.websocket_state != 'connected':
            if not self.connect_to_relay():
                raise UserError(_("Failed to connect to relay"))

        try:
            message = json.dumps(["EVENT", event])
            ws = self._get_ws_connection()
            if ws:
                ws.send(message)
                _logger.info(f"Published event to {self.relay_url}")
                return True
            else:
                raise UserError(_("WebSocket connection is not available"))
        except Exception as e:
            _logger.error(f"Failed to publish event to {self.relay_url}: {str(e)}")
            raise UserError(_("Failed to publish event: %s") % str(e))

    @api.model
    def process_messages(self):
        messages = self.env['nostr.message'].search([('processed', '=', False)])
        for message in messages:
            try:
                # Process the message here
                _logger.info(f"Processing message: {message.content}")
                # Add your message processing logic here
                message.write({'processed': True})
            except Exception as e:
                _logger.error(f"Error processing message {message.id}: {str(e)}")

    def close_connection(self):
        self.ensure_one()
        ws = self._get_ws_connection()
        if ws:
            try:
                ws.close()
            except Exception as e:
                _logger.error(f"Error closing WebSocket for {self.relay_url}: {str(e)}")
        self._set_ws_connection(None)
        self.write({'websocket_state': 'disconnected'})
=== ./nostr_identity/models/nostr_identity.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import base64
from cryptography.fernet import Fernet
import logging
import secrets
from nostr.key import PrivateKey
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization
import bech32

_logger = logging.getLogger(__name__)

def hex_to_nostr_key(hex_key, prefix):
    # Convert hex to bytes
    data = bytes.fromhex(hex_key)
    
    # Convert to 5-bit words
    words = bech32.convertbits(data, 8, 5)
    
    # Encode with bech32
    encoded = bech32.bech32_encode(prefix, words)
    
    return encoded

class NostrIdentity(models.Model):
    _name = 'nostr.identity'
    _description = 'Nostr Identity'

    name = fields.Char(string='Name', required=True)
    public_key = fields.Char(string='Public Key (hex)', readonly=True)
    private_key = fields.Char(string='Private Key (hex)', readonly=True)
    public_key_bech32 = fields.Char(string='Public Key (npub)', readonly=True, compute='_compute_bech32_keys')
    private_key_bech32 = fields.Char(string='Private Key (nsec)', readonly=True, compute='_compute_bech32_keys')
    relay_urls = fields.Text(string='Relay URLs')
    profile_data = fields.Text(string='Profile Data')

    @api.model
    def create(self, vals):
        if 'public_key' not in vals or 'private_key' not in vals:
            try:
                private_key = PrivateKey()
                public_key = private_key.public_key
                vals['private_key'] = private_key.hex()
                vals['public_key'] = public_key.hex()
            except Exception as e:
                _logger.error(f"Failed to generate Nostr keys: {str(e)}")
                raise UserError(_("Failed to generate Nostr keys: %s") % str(e))
        return super(NostrIdentity, self).create(vals)

    @api.depends('public_key', 'private_key')
    def _compute_bech32_keys(self):
        for record in self:
            if record.public_key:
                record.public_key_bech32 = hex_to_nostr_key(record.public_key, "npub")
            else:
                record.public_key_bech32 = False
            
            if record.private_key:
                record.private_key_bech32 = hex_to_nostr_key(record.private_key, "nsec")
            else:
                record.private_key_bech32 = False

    def get_private_key(self):
        self.ensure_one()
        try:
            encryption_key = self.env['ir.config_parameter'].sudo().get_param('nostr.encryption_key')
            if not encryption_key:
                raise UserError(_("Encryption key not found. Unable to decrypt private key."))
            
            fernet = Fernet(encryption_key.encode())
            decrypted_private_key = fernet.decrypt(base64.b64decode(self.encrypted_private_key))
            return PrivateKey(bytes.fromhex(decrypted_private_key.decode()))
        except Exception as e:
            _logger.error(f"Failed to decrypt private key: {str(e)}")
            raise UserError(_("Failed to decrypt private key: %s") % str(e))

    def get_public_key_bech32(self):
        return self.public_key_bech32
=== ./nostr_identity/models/nostr_message.py ===
# models/nostr_message.py

from odoo import models, fields

class NostrMessage(models.Model):
    _name = 'nostr.message'
    _description = 'Nostr Message'

    verifier_id = fields.Many2one('nostr.identity.verifier', string='Verifier', required=True, ondelete='cascade')
    content = fields.Text(string='Message Content', required=True)
    processed = fields.Boolean(string='Processed', default=False)
=== ./nostr_identity/__init__.py ===
# nostr_identity/__init__.py

from . import models
from . import nostr_cleanup

def post_init_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Generate encryption key if it doesn't exist
    if not env['ir.config_parameter'].get_param('nostr.encryption_key'):
        from cryptography.fernet import Fernet
        encryption_key = Fernet.generate_key()
        env['ir.config_parameter'].set_param('nostr.encryption_key', encryption_key.decode())

def uninstall_hook(cr, registry):
    from odoo import api, SUPERUSER_ID
    env = api.Environment(cr, SUPERUSER_ID, {})
    
    # Remove the encryption key
    env['ir.config_parameter'].set_param('nostr.encryption_key', False)
    
    # Close all active WebSocket connections
    verifiers = env['nostr.identity.verifier'].search([])
    for verifier in verifiers:
        verifier.close_connection()
=== ./nostr_identity/__manifest__.py ===
# __manifest__.py
{
    'name': 'Nostr Identity Verifier',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrate Nostr identity verification into Odoo',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'license': 'LGPL-3',
    'depends': ['base', 'mail'],
    'data': [
        'security/nostr_security.xml',
        'security/ir.model.access.csv',
        'views/nostr_identity_views.xml',
        'data/ir_cron_data.xml',
    ],
    'demo': [],
    'external_dependencies': {
        'python': ['websocket-client', 'nostr'],
    },
    'installable': True,
    'application': False,
    'auto_install': False,
    'post_init_hook': 'post_init_hook',
    'uninstall_hook': 'uninstall_hook',
}
=== ./nostr_identity/nostr_cleanup.py ===
# nostr_identity/nostr_cleanup.py

import atexit
from odoo import api, SUPERUSER_ID

def cleanup_connections():
    try:
        with api.Environment.manage():
            env = api.Environment(odoo.registry(odoo.tools.config['db_name']).cursor(), SUPERUSER_ID, {})
            verifiers = env['nostr.identity.verifier'].search([])
            for verifier in verifiers:
                verifier.close_connection()
            env.cr.commit()
    except Exception as e:
        # Log the error, but don't raise it to avoid interfering with Odoo's shutdown process
        _logger.error(f"Error during Nostr connection cleanup: {e}")
    finally:
        if env and env.cr:
            env.cr.close()

atexit.register(cleanup_connections)
=== ./nostr_identity/security/nostr_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Rule: Users can only see their own Nostr Identity records -->
        <record id="rule_nostr_identity_users" model="ir.rule">
            <field name="name">Users can only see their own Nostr Identity</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <!-- Rule: Managers can see all Nostr Identity records -->
        <record id="rule_nostr_identity_managers" model="ir.rule">
            <field name="name">Managers can see all Nostr Identity records</field>
            <field name="model_id" ref="model_nostr_identity"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_system'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>
    </data>
</odoo>
=== ./nostr_identity/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_nostr_identity_user,nostr.identity user,model_nostr_identity,base.group_user,1,1,1,0
access_nostr_identity_manager,nostr.identity manager,model_nostr_identity,base.group_system,1,1,1,1
access_nostr_identity_verifier_user,nostr.identity.verifier user,model_nostr_identity_verifier,base.group_user,1,0,0,0
access_nostr_identity_verifier_manager,nostr.identity.verifier manager,model_nostr_identity_verifier,base.group_system,1,1,1,1
access_nostr_message_user,nostr.message user,model_nostr_message,base.group_user,1,0,0,0
access_nostr_message_manager,nostr.message manager,model_nostr_message,base.group_system,1,1,1,1
=== ./nostr_identity/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_nostr_process_messages" model="ir.cron">
            <field name="name">Nostr: Process Messages</field>
            <field name="model_id" ref="model_nostr_identity_verifier"/>
            <field name="state">code</field>
            <field name="code">model.process_messages()</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="doall" eval="False"/>
            <field name="active" eval="True"/>
        </record>
    </data>
</odoo>
=== ./nostr_identity/views/nostr_identity_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- Nostr Identity Views -->
    <record id="view_nostr_identity_tree" model="ir.ui.view">
        <field name="name">nostr.identity.tree</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="public_key"/>
                <field name="public_key_bech32"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_form" model="ir.ui.view">
        <field name="name">nostr.identity.form</field>
        <field name="model">nostr.identity</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="public_key"/>
                        <field name="public_key_bech32"/>
                        <field name="relay_urls"/>
                        <field name="profile_data"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- The rest of the XML remains unchanged -->
    <!-- Nostr Identity Verifier Views -->
    <record id="view_nostr_identity_verifier_tree" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.tree</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="relay_url"/>
                <field name="websocket_state"/>
            </tree>
        </field>
    </record>

    <record id="view_nostr_identity_verifier_form" model="ir.ui.view">
        <field name="name">nostr.identity.verifier.form</field>
        <field name="model">nostr.identity.verifier</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="connect_to_relay" string="Connect" type="object" class="oe_highlight" attrs="{'invisible': [('websocket_state', '=', 'connected')]}"/>
                    <button name="close_connection" string="Disconnect" type="object" attrs="{'invisible': [('websocket_state', '!=', 'connected')]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="relay_url"/>
                        <field name="active"/>
                        <field name="websocket_state"/>
                        <field name="last_error"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <!-- Action Windows -->
    <record id="action_nostr_identity" model="ir.actions.act_window">
        <field name="name">Nostr Identities</field>
        <field name="res_model">nostr.identity</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_nostr_identity_verifier" model="ir.actions.act_window">
        <field name="name">Nostr Identity Verifiers</field>
        <field name="res_model">nostr.identity.verifier</field>
        <field name="view_mode">tree,form</field>
    </record>

    <!-- Menu Items -->
    <menuitem id="menu_nostr_root" name="Nostr" sequence="10"/>
    <menuitem id="menu_nostr_identity" name="Identities" parent="menu_nostr_root" action="action_nostr_identity" sequence="10"/>
    <menuitem id="menu_nostr_identity_verifier" name="Verifiers" parent="menu_nostr_root" action="action_nostr_identity_verifier" sequence="20"/>
</odoo>
=== ./nostr_bridge/models/git_repository.py ===
# File: odoo_custom_addons/nostr_bridge/models/git_repository.py

from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        event_manager = self.env['nostr.event.manager']
        event = event_manager.create_git_event(self.path, commit.hexsha)
        event_manager.publish_event(event)
        
        return commit.hexsha
=== ./nostr_bridge/models/__init__.py ===
# File: odoo_custom_addons/nostr_bridge/models/__init__.py

from . import res_users
from . import mail_message
from . import nostr_adapter
from . import res_config_settings
from . import res_partner
from . import nostr_event_manager
from . import git_repository
=== ./nostr_bridge/models/res_users.py ===
"""from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    #nostr_private_key = fields.Char(string="Nostr Private Key")
    #nostr_public_key = fields.Char(string="Nostr Public Key", compute='_compute_public_key')
    #nostr_relay_url = fields.Char(string="Nostr Relay URL")

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        if not vals.get('nostr_private_key'):
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                private_key = PrivateKey.from_nsec(user.nostr_private_key)
                user.nostr_public_key = private_key.public_key.bech32()
            else:
                user.nostr_public_key = False
"""

"""from odoo import models, fields, api

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.model
    def create(self, vals):
        # Here you might want to generate Nostr keys if they're not provided
        return super(ResUsers, self).create(vals)

    def write(self, vals):
        # Here you might want to handle updates to Nostr fields
        return super(ResUsers, self).write(vals)"""
        
        
from odoo import models, fields

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")
=== ./nostr_bridge/models/nostr_adapter.py ===
import requests
import websocket
from odoo import models, api
from websocket._exceptions import WebSocketConnectionClosedException
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
from nostr.relay_manager import RelayManager
import logging
import time

_logger = logging.getLogger(__name__)

class NostrAdapter(models.AbstractModel):
    _name = 'nostr.adapter'
    _description = 'Nostr Adapter'

    @api.model
    def get_relay_manager(self):
        ICPSudo = self.env['ir.config_parameter'].sudo()
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls', '').split(',')
        if not relay_urls:
            raise UserError("Nostr relay URL is not configured. Please set it in the settings.")
        _logger.info(f"Nostr relay URLs: {relay_urls}")

        relay_manager = RelayManager()
        for url in relay_urls:
            url = url.strip()
            if url:  # Only add non-empty URLs
                _logger.info(f"Adding relay: {url}")
                relay_manager.add_relay(url)
        return relay_manager

    @api.model
    def publish_event(self, event_data, max_retries=3, retry_delay=1):
        for attempt in range(max_retries):
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                public_key = private_key.public_key.hex()
                
                event = Event(
                    kind=event_data['kind'],
                    content=event_data['content'],
                    tags=event_data.get('tags', []),
                    public_key=public_key
                )
                private_key.sign_event(event)
                
                relay_manager = self.get_relay_manager()
                relay_manager.open_connections({"write": True})
                time.sleep(1)  # Give some time for connections to establish
                
                publish_result = relay_manager.publish_event(event)
                _logger.info(f"Relay publish response: {publish_result}")
    
                relay_manager.close_connections()
                return True
            except Exception as e:
                _logger.exception(f"Error publishing event to Nostr: {str(e)}")
                time.sleep(retry_delay)
        
        _logger.error("Failed to publish event after multiple attempts")
        return False
=== ./nostr_bridge/models/mail_message.py ===
from odoo import models, api
import logging

_logger = logging.getLogger(__name__)

class MailMessage(models.Model):
    _inherit = 'mail.message'

    @api.model_create_multi
    def create(self, vals_list):
        _logger.info("Creating new mail messages")
        messages = super(MailMessage, self).create(vals_list)
        for message in messages:
            self._publish_to_nostr(message)
        return messages

    def _publish_to_nostr(self, message):
        try:
            nostr_adapter = self.env['nostr.adapter'].sudo()
            event_data = {
                'kind': 1,  # Text note
                'content': message.body,
                'tags': [
                    ['e', str(message.parent_id.id)] if message.parent_id else [],
                    ['p', message.author_id.nostr_public_key] if message.author_id and message.author_id.nostr_public_key else [],
                    ['client', 'Odoo Nostr Bridge'],
                ],
            }
            result = nostr_adapter.publish_event(event_data)
            if result:
                _logger.info(f"Successfully published message {message.id} to Nostr")
            else:
                _logger.warning(f"Failed to publish message {message.id} to Nostr")
        except Exception as e:
            _logger.exception(f"Error publishing message {message.id} to Nostr: {str(e)}")
=== ./nostr_bridge/models/nostr_event_handler.py ===
import json
from odoo import api, models

class NostrEventHandler(models.AbstractModel):
    _name = 'nostr.event.handler'
    _description = 'Nostr Event Handler'

    @api.model
    def handle_event(self, event):
        content = json.loads(event.content)
        if event.kind == 1:  # Text note
            self._handle_message(content)
        elif event.kind == 7:  # Reaction
            self._handle_reaction(content)

    def _handle_message(self, content):
        self.env['mail.message'].create({
            'body': content['body'],
            'author_id': self._get_author_id(content['author']),
            'model': content['channel'],
            'res_id': content['res_id'],
        })

    def _handle_reaction(self, content):
        # Implement reaction handling (e.g., likes, emojis)
        pass

    def _get_author_id(self, author_name):
        partner = self.env['res.partner'].search([('name', '=', author_name)], limit=1)
        if not partner:
            partner = self.env['res.partner'].create({'name': author_name})
        return partner.id
=== ./nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            #_logger.info(f"API response (first 108 items): {json.dumps(data)[:1000]}")
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")  # Log first 100 characters
        
        res.update(nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.nostr_relay_urls:
            ICPSudo.set_param('nostr_bridge.relay_urls', self.nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.nostr_relay_urls[:100]}...")  # Log first 100 characters
        else:
            default_urls = self._get_top_nostr_relays()
            ICPSudo.set_param('nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")  # Log first 100 characters
=== ./nostr_bridge/models/res_partner.py ===
from odoo import models, fields

class ResPartner(models.Model):
    _inherit = 'res.partner'

    nostr_public_key = fields.Char(string="Nostr Public Key")
=== ./nostr_bridge/models/nostr_event_manager.py ===
from odoo import models, fields, api
import json
import time
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
import logging

_logger = logging.getLogger(__name__)

class NostrEventManager(models.AbstractModel):
    _name = 'nostr.event.manager'
    _description = 'Nostr Event Manager'

    @api.model
    def create_event(self, content, tags, private_key):
        private_key_obj = PrivateKey.from_nsec(private_key)
        event = Event(kind=1, content=content, tags=tags)
        private_key_obj.sign_event(event)
        return event.to_json()

    @api.model
    def get_public_key(self, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        public_key = private_key_obj.public_key()
        return public_key.public_bytes(
            encoding=Encoding.X962,
            format=PublicFormat.UncompressedPoint
        )[1:].hex()

    @api.model
    def calculate_event_id(self, event_data):
        serialized = json.dumps([
            0,
            event_data['pubkey'],
            event_data['created_at'],
            event_data['kind'],
            event_data['tags'],
            event_data['content']
        ], separators=(',', ':'))
        return self.sha256(serialized)

    @api.model
    def sign_event(self, event_data, private_key):
        private_key_obj = ec.derive_private_key(int(private_key, 16), ec.SECP256K1())
        signature = private_key_obj.sign(
            bytes.fromhex(event_data['id']),
            ec.ECDSA(hashes.SHA256())
        )
        return signature.hex()

    @api.model
    def sha256(self, data):
        digest = hashes.Hash(hashes.SHA256())
        digest.update(data.encode())
        return digest.finalize().hex()

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat()
        })
        
        tags = [
            ["t", "commit"],
            ["h", commit_hash],
            ["n", repo.active_branch.name],
            ["m", commit.author.name],
            ["v", "1.0"],
            ["r", repo.remotes.origin.url if repo.remotes else ""],
            ["p", self.env.user.nostr_public_key],
            ["d", commit.message],
            ["s", "success"]
        ]
        
        event = self.create_event(content, tags, self.env.user.nostr_private_key)
        self.publish_event(event)
        return event

    def sync_with_decentralized_manager(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            program = self.env['decentralized.sync.program'].search([
                ('manager_id', '=', manager.id),
                ('content', '=', event['content'])
            ], limit=1)

            if not program:
                program = self.env['decentralized.sync.program'].create({
                    'manager_id': manager.id,
                    'creator_id': self.env['decentralized.sync.creator'].search([], limit=1).id,
                    'content': event['content'],
                    'version': 1,
                    'size': 0.5  # Arbitrary size
                })

            manager.propagate_update(program)

    @api.model
    def publish_event(self, event):
        sync_managers = self.env['decentralized.sync.manager'].search([])
        for manager in sync_managers:
            manager.publish_event(event['content'], event['tags'])
        return True

    @api.model
    def get_events(self, filters=None):
        nostr_adapter = self.env['nostr.adapter']
        return nostr_adapter.get_events(filters)
=== ./nostr_bridge/models/ivcs_item.py ===
# File: odoo_custom_addons/nostr_bridge/models/ivcs_item.py

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import os
import logging
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _inherit = 'ivcs.item'

    nostr_private_key = fields.Char(string="Nostr Private Key")

    def _create_nostr_event_and_publish(self, commit):
        if not self.nostr_private_key:
            self.nostr_private_key = PrivateKey().hex()
            self.sudo().write({'nostr_private_key': self.nostr_private_key})

        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        nostr_manager = self.env['nostr.event.manager']
        event = nostr_manager.create_git_event(commit, private_key)

        relay_urls = self.env['ir.config_parameter'].sudo().get_param('nostr_bridge.relay_urls', '').split(',')
        for relay_url in relay_urls:
            if relay_url.strip():
                success = nostr_manager.publish_event_sync(event, relay_url.strip())
                if success:
                    _logger.info(f"Successfully published event to {relay_url}")
                else:
                    _logger.warning(f"Failed to publish event to {relay_url}")

    def sync_repository(self):
        result = super(IVCSItem, self).sync_repository()
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    def create_file(self, filename, content):
        result = super(IVCSItem, self).create_file(filename, content)
        if result.get('type') == 'ir.actions.client' and result['params']['type'] == 'success':
            repo = git.Repo(self.repo_path)
            latest_commit = repo.head.commit
            self._create_nostr_event_and_publish(latest_commit)
        return result

    @api.model
    def create(self, vals):
        item = super(IVCSItem, self).create(vals)
        repo = git.Repo(item.repo_path)
        initial_commit = repo.head.commit
        item._create_nostr_event_and_publish(initial_commit)
        return item
=== ./nostr_bridge/__init__.py ===
from . import models
from . import controllers
=== ./nostr_bridge/__manifest__.py ===
# File: odoo_custom_addons/nostr_bridge/__manifest__.py

{
    'name': 'Nostr Bridge',
    'version': '1.0',
    'category': 'Social',
    'summary': 'Bridge between Odoo messages, Git, and Nostr network',
    'depends': ['base', 'mail', 'web'],
    'data': [
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'views/res_partner_views.xml',
        'views/git_repository_views.xml',
        'security/ir.model.access.csv',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
    'license': 'LGPL-3',
    'external_dependencies': {
        'python': ['cryptography', 'gitpython', 'nostr'],
    },
}
=== ./nostr_bridge/static/src/js/nostr_client.js ===
odoo.define('nostr_bridge.NostrClient', function (require) {
    "use strict";

    var Class = require('web.Class');

    var NostrClient = Class.extend({
        init: function (relayUrls) {
            this.relayUrls = relayUrls;
            this.relayPool = new NostrTools.RelayPool(this.relayUrls);
        },

        subscribe: function (filters, callback) {
            this.relayPool.subscribe(filters, callback);
        },

        publish: function (event) {
            this.relayPool.publish(event);
        }
    });

    return NostrClient;
});
=== ./nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository_user,git.repository.user,model_git_repository,base.group_user,1,1,1,1
=== ./nostr_bridge/data/ir_cron_data.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_migrate_messages_to_nostr" model="ir.cron">
            <field name="name">Migrate Messages to Nostr</field>
            <field name="model_id" ref="model_mail_message"/>
            <field name="state">code</field>
            <field name="code">model.migrate_messages_to_nostr()</field>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">1</field>
            <field name="doall" eval="False"/>
        </record>
    </data>
</odoo>
=== ./nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_nostr" model="ir.ui.view">
        <field name="name">res.users.form.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_relay_url"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_bridge/views/res_partner_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_partner_form_nostr" model="ir.ui.view">
        <field name="name">res.partner.form.nostr</field>
        <field name="model">res.partner</field>
        <field name="inherit_id" ref="base.view_partner_form"/>
        <field name="arch" type="xml">
            <xpath expr="//notebook" position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form_nostr" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.nostr</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Nostr Bridge" string="Nostr Bridge" data-key="nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="nostr_relay_urls" class="o_light_label"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./nostr_bridge/views/templates.xml ===
<odoo>
    <template id="assets_backend" name="nostr_bridge assets" inherit_id="web.assets_backend">
        <xpath expr="." position="inside">
            <script type="text/javascript" src="/nostr_bridge/static/src/js/nostr_client.js"/>
        </xpath>
    </template>
</odoo>
=== ./nostr_bridge/views/git_repository_views.xml ===
<!-- File: odoo_custom_addons/nostr_bridge/views/git_repository_views.xml -->

<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" action="action_git_repository" parent="base.menu_custom"/>
</odoo>
=== ./nostr_bridge/controllers/__init__.py ===
from . import main
=== ./nostr_bridge/controllers/main.py ===
from odoo import http
from odoo.http import request
import json
from nostr.event import Event
from nostr.key import PrivateKey

class NostrController(http.Controller):

    @http.route('/nostr/authenticate', type='json', auth='public')
    def authenticate(self, public_key, signature, message):
        User = request.env['res.users'].sudo()
        user_id = User.authenticate_nostr(public_key, signature, message)
        if user_id:
            request.session.authenticate(request.db, user_id, public_key)
            return {'success': True, 'uid': user_id}
        return {'success': False, 'error': 'Authentication failed'}

    @http.route('/nostr/publish', type='json', auth='user')
    def publish_event(self, event_data):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            nostr_adapter.publish_event(event_data)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/subscribe', type='json', auth='user')
    def subscribe_to_events(self, filters):
        nostr_adapter = request.env['nostr.adapter'].sudo().get_adapter()
        try:
            def callback(event):
                # Process the event, e.g., create a message in Odoo
                request.env['nostr.event.handler'].sudo().handle_event(event)

            nostr_adapter.subscribe_to_events(filters, callback)
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    @http.route('/nostr/get_public_key', type='json', auth='user')
    def get_public_key(self):
        user = request.env.user
        return {'public_key': user.nostr_public_key}

    @http.route('/nostr/create_event', type='json', auth='user')
    def create_event(self, kind, content, tags=None):
        user = request.env.user
        private_key = PrivateKey.from_nsec(user.nostr_private_key)
        event = Event(kind=kind, content=json.dumps(content), tags=tags or [])
        event.sign(private_key.hex())
        return {
            'id': event.id,
            'pubkey': event.public_key,
            'created_at': event.created_at,
            'kind': event.kind,
            'tags': event.tags,
            'content': event.content,
            'sig': event.signature,
        }
=== ./decentralized_sync/models/supporting_models.py ===
from odoo import models, fields, api

class DAO(models.Model):
    _name = 'decentralized.sync.dao'
    _description = 'DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    tier = fields.Selection([('primary', 'Primary'), ('secondary', 'Secondary'), ('tertiary', 'Tertiary')], string='Tier')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    storage_capacity = fields.Float(string='Storage Capacity')
    network_speed = fields.Float(string='Network Speed')
    local_state = fields.Text(string='Local State')

class Creator(models.Model):
    _name = 'decentralized.sync.creator'
    _description = 'Creator'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    location_lat = fields.Float(string='Latitude')
    location_lon = fields.Float(string='Longitude')
    productivity = fields.Float(string='Productivity')
    dao_id = fields.Many2one('decentralized.sync.dao', string='Associated DAO')

class Program(models.Model):
    _name = 'decentralized.sync.program'
    _description = 'Program'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    size = fields.Float(string='Size')
    version = fields.Integer(string='Version')
    content = fields.Text(string='Content')
    host_ids = fields.Many2many('decentralized.sync.dao', string='Hosts')

class Event(models.Model):
    _name = 'decentralized.sync.event'
    _description = 'Sync Event'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    description = fields.Text(string='Event Description')
    timestamp = fields.Datetime(string='Timestamp', default=fields.Datetime.now)

class Connection(models.Model):
    _name = 'decentralized.sync.connection'
    _description = 'Connection between Creator and DAO'

    manager_id = fields.Many2one('decentralized.sync.manager', string='Sync Manager')
    creator_id = fields.Many2one('decentralized.sync.creator', string='Creator')
    dao_id = fields.Many2one('decentralized.sync.dao', string='DAO')
=== ./decentralized_sync/models/sync_manager.py ===
from odoo import models, fields, api
import logging
from nostr.key import PrivateKey
from nostr.event import Event
from nostr.relay_manager import RelayManager
import git
import os

_logger = logging.getLogger(__name__)

class DecentralizedNostrSyncManager(models.Model):
    _name = 'decentralized.sync.manager'
    _description = 'Decentralized Nostr Sync Manager'

    name = fields.Char(string='Name', required=True)
    relay_urls = fields.Text(string='Relay URLs', required=True)
    private_key = fields.Char(string='Private Key')
    public_key = fields.Char(string='Public Key', compute='_compute_public_key')

    @api.depends('private_key')
    def _compute_public_key(self):
        for record in self:
            if record.private_key:
                private_key = PrivateKey.from_nsec(record.private_key)
                record.public_key = private_key.public_key.bech32()
            else:
                record.public_key = False

    def initialize_nostr(self):
        if not self.private_key:
            private_key = PrivateKey()
            self.private_key = private_key.bech32()
        
        self.relay_manager = RelayManager()
        for url in self.relay_urls.split(','):
            self.relay_manager.add_relay(url.strip())
        self.relay_manager.open_connections()

    def publish_event(self, content, tags=None):
        if not hasattr(self, 'relay_manager'):
            self.initialize_nostr()

        private_key = PrivateKey.from_nsec(self.private_key)
        event = Event(content=content, tags=tags or [])
        private_key.sign_event(event)
        
        self.relay_manager.publish_event(event)
        return event

    def sync_git_repository(self, repo_path):
        repo = git.Repo(repo_path)
        if not repo.remotes:
            raise ValueError('No remote repository configured')

        origin = repo.remotes.origin
        origin.fetch()
        
        current_branch = repo.active_branch
        if f'origin/{current_branch.name}' not in repo.refs:
            origin.push(current_branch)
        else:
            origin.pull(current_branch)

        for commit in repo.iter_commits(f'{current_branch.name}@{{u}}..{current_branch.name}'):
            self.publish_event(
                content=f"New commit: {commit.hexsha}",
                tags=[['c', commit.hexsha], ['t', 'git_commit']]
            )

    @api.model
    def create(self, vals):
        manager = super(DecentralizedNostrSyncManager, self).create(vals)
        manager.initialize_nostr()
        return manager

    def write(self, vals):
        result = super(DecentralizedNostrSyncManager, self).write(vals)
        if 'relay_urls' in vals:
            self.initialize_nostr()
        return result
=== ./decentralized_sync/__init__.py ===
from . import models
from . import controllers
=== ./decentralized_sync/__manifest__.py ===
{
    'name': 'Decentralized Nostr Sync Manager',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Manage decentralized synchronization with Nostr and Git',
    'depends': ['base', 'ivcs_git', 'nostr_bridge'],
    'data': [
        'security/ir.model.access.csv',
        'views/sync_manager_views.xml',
        'views/dao_views.xml',
        'views/creator_views.xml',
        'views/program_views.xml',
        'views/event_views.xml',
        'views/menu_items.xml',
    ],
    'installable': True,
    'application': False,
    'auto_install': False,
}
=== ./decentralized_sync/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_decentralized_sync_manager_user,decentralized.sync.manager user,model_decentralized_sync_manager,base.group_user,1,1,1,1
access_decentralized_sync_dao_user,decentralized.sync.dao user,model_decentralized_sync_dao,base.group_user,1,1,1,1
access_decentralized_sync_creator_user,decentralized.sync.creator user,model_decentralized_sync_creator,base.group_user,1,1,1,1
access_decentralized_sync_program_user,decentralized.sync.program user,model_decentralized_sync_program,base.group_user,1,1,1,1
access_decentralized_sync_event_user,decentralized.sync.event user,model_decentralized_sync_event,base.group_user,1,1,1,1
access_decentralized_sync_connection_user,decentralized.sync.connection user,model_decentralized_sync_connection,base.group_user,1,1,1,1
=== ./decentralized_sync/controllers/main.py ===
from odoo import http
from odoo.http import request
from nostr.event import Event
import json

class DecentralizedSyncController(http.Controller):

    @http.route('/api/decentralized_sync/publish', type='json', auth='user')
    def publish_event(self, manager_id, content, tags=None):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        event = manager.publish_event(content, tags)
        return {'status': 'success', 'event_id': event.id}

    @http.route('/api/decentralized_sync/sync_repo', type='json', auth='user')
    def sync_repository(self, manager_id, repo_path):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        manager.sync_git_repository(repo_path)
        return {'status': 'success', 'message': 'Repository synced and events published'}

    @http.route('/api/decentralized_sync/events', type='json', auth='user')
    def get_events(self, manager_id):
        manager = request.env['decentralized.sync.manager'].browse(int(manager_id))
        # This would typically fetch events from Nostr relays
        # For now, we'll return an empty list
        return {'events': []}
=== ./nostr_auth_test/nostr_auth_module.py ===
import os
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes
from odoo import models, fields, api
from odoo.exceptions import ValidationError
import base64

class NostrAuthModule(models.AbstractModel):
    _name = 'nostr.auth'
    _description = 'Nostr Authentication Module'

    @api.model
    def generate_keypair(self):
        """
        Generate a new Nostr keypair.
        This represents the 'Cause' in our 'Causal Relationship'.
        """
        private_key = ec.generate_private_key(ec.SECP256K1())
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        return {
            'private_key': base64.b64encode(private_bytes).decode('utf-8'),
            'public_key': base64.b64encode(public_bytes).decode('utf-8')
        }

    @api.model
    def store_keys(self, user_id, public_key, private_key):
        """
        Store the Nostr keys for a user.
        This action creates an 'Effect' in our 'Causal Relationship'.
        """
        user = self.env['res.users'].browse(user_id)
        if not user.exists():
            raise ValidationError("User does not exist")
        
        user.write({
            'nostr_public_key': public_key,
            'nostr_private_key': private_key  # In a real-world scenario, encrypt this before storage
        })

    @api.model
    def verify_signature(self, public_key, message, signature):
        """
        Verify a Nostr signature.
        This verification process is another 'Effect' in our 'Causal Relationship'.
        """
        try:
            public_key_obj = serialization.load_pem_public_key(base64.b64decode(public_key))
            signature_bytes = base64.b64decode(signature)
            public_key_obj.verify(
                signature_bytes,
                message.encode('utf-8'),
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except:
            return False

    @api.model
    def authenticate_nostr(self, public_key, signature, message):
        """
        Authenticate a user using Nostr.
        This method embodies the complete 'Causal Relationship':
        The provided credentials (Cause) lead to authentication success or failure (Effect).
        """
        user = self.env['res.users'].search([('nostr_public_key', '=', public_key)], limit=1)
        if user and self.verify_signature(user.nostr_public_key, message, signature):
            return user.id
        return False

# For console testing
if __name__ == "__main__":
    # Simulate Odoo environment
    class MockEnv:
        def __init__(self):
            self.users = {}
        
        def __getitem__(self, key):
            return self
        
        def search(self, domain, limit=None):
            for user_id, user in self.users.items():
                if user['nostr_public_key'] == domain[0][2]:
                    return [MockUser(user_id, user)]
            return []
    
    class MockUser:
        def __init__(self, id, data):
            self.id = id
            self.__dict__.update(data)
        
        def exists(self):
            return True
        
        def write(self, vals):
            self.__dict__.update(vals)

    mock_env = MockEnv()
    
    # Create an instance of NostrAuthModule
    nostr_auth = NostrAuthModule()
    nostr_auth.env = mock_env

    # Test key generation
    print("Generating keypair...")
    keys = nostr_auth.generate_keypair()
    print(f"Public Key: {keys['public_key'][:32]}...")
    print(f"Private Key: {keys['private_key'][:32]}...")

    # Test key storage
    print("\nStoring keys...")
    mock_env.users[1] = {'name': 'Test User'}
    try:
        nostr_auth.store_keys(1, keys['public_key'], keys['private_key'])
        print("Keys stored successfully")
    except Exception as e:
        print(f"Error storing keys: {str(e)}")

    # Test signature verification
    print("\nTesting signature verification...")
    message = "Test message"
    private_key = serialization.load_pem_private_key(base64.b64decode(keys['private_key']), password=None)
    signature = base64.b64encode(private_key.sign(
        message.encode('utf-8'),
        ec.ECDSA(hashes.SHA256())
    )).decode('utf-8')
    
    is_valid = nostr_auth.verify_signature(keys['public_key'], message, signature)
    print(f"Signature valid: {is_valid}")

    # Test authentication
    print("\nTesting authentication...")
    user_id = nostr_auth.authenticate_nostr(keys['public_key'], signature, message)
    print(f"Authenticated user ID: {user_id}")

    print("\nAll tests completed.")
=== ./allfiles.txt ===
=== ./git_nostr_object/models/git_repository.py ===
# models/git_repository.py
from odoo import models, fields, api
import git
import json

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Path', required=True)
    logs = fields.Text(string='Logs')

    def traverse_and_publish(self):
        self.ensure_one()
        logs = []
        try:
            git_repo = git.Repo(self.path)
            for commit in git_repo.iter_commits():
                nostr_event = self.env['nostr.event.object'].create({
                    'kind': 1,
                    'content': commit.message,
                    'tags': json.dumps([['commit', commit.hexsha]]),
                    'created_at': commit.committed_date,
                })
                nostr_event.action_publish()
                logs.append(f"Published commit {commit.hexsha}")

            self.write({'logs': '\n'.join(logs)})
            self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                'title': _("Git Repository Traversed"),
                'message': _("All commits published to Nostr network"),
            })
        except Exception as e:
            error_msg = f"Error traversing repository: {e}"
            logs.append(error_msg)
            self.write({'logs': '\n'.join(logs)})
            raise UserError(_(error_msg))

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Git Repository"),
                'message': _("Repository traversed and commits published. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./git_nostr_object/models/git_commit.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitCommit(models.Model):
    _name = 'git.commit'
    _inherit = 'git.object'
    _description = 'Git Commit'

    message = fields.Text(string='Commit Message')
    author = fields.Char(string='Author')
    timestamp = fields.Datetime(string='Timestamp')

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3121,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_commit = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_commit.sha,
            'data': git_commit.data.decode('utf-8', errors='replace'),
            'message': git_commit.message,
            'author': git_commit.author,
            'timestamp': git_commit.timestamp,
        })
    @api.model
    def create_from_git_commit(self, commit):
        return self.create({
            'sha': commit.hexsha,
            'message': commit.message,
            'author': f"{commit.author.name} <{commit.author.email}>",
            'timestamp': commit.committed_datetime,
            'data': commit.tree.data_stream.read().decode('utf-8', errors='replace'),
        })
=== ./git_nostr_object/models/nostr_websocket_client.py ===
import websocket
import json
import logging
import time

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        for url in self.relay_urls:
            try:
                _logger.info(f"Attempting to connect to {url}")
                start_time = time.time()
                ws = websocket.create_connection(url, timeout=10)
                _logger.info(f"Connected to {url} in {time.time() - start_time:.2f} seconds")

                # Construct the message correctly
                message = ["EVENT", event_data]
                _logger.debug(f"Raw event message: {message}")

                ws.send(json.dumps(message))
                _logger.info(f"Sent message to {url} in {time.time() - start_time:.2f} seconds")

                _logger.info(f"Waiting for response from {url}")
                response = ws.recv()
                _logger.info(f"Received response from {url} in {time.time() - start_time:.2f} seconds: {response}")

                responses.append(json.loads(response))
                ws.close()
            except Exception as e:
                _logger.error(f"Error publishing to {url}: {str(e)}")
                responses.append(["ERROR", str(e)])
        return responses
=== ./git_nostr_object/models/__init__.py ===
# __init__.py
from . import git_object
from . import git_commit
from . import git_tree
from . import git_blob
from . import git_repository
from . import nostr_event
from . import admin_test
from . import git_commit_wizard
=== ./git_nostr_object/models/git_object.py ===
from odoo import models, fields, api

class GitObject(models.AbstractModel):
    _name = 'git.object'
    _description = 'Git Object'

    sha = fields.Char(string='SHA', required=True)
    data = fields.Text(string='Data', required=True)

    def to_nostr_event(self):
        raise NotImplementedError("This method should be implemented by subclasses")

    @api.model
    def create_from_nostr_event(self, event):
        raise NotImplementedError("This method should be implemented by subclasses")
=== ./git_nostr_object/models/git_nostr_object.py ===
# models/git_nostr_event.py
from odoo import models, fields, api
from utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
import logging
import time
import json

_logger = logging.getLogger(__name__)

class GitNostrEventObject(models.Model):
    _name = 'git_nostr.event.object'
    _description = 'Git Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)

    def action_publish(self):
        """
        Publish the Nostr event to the configured relays.
        """
        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = {
            'kind': self.kind,
            'content': self.content,
            'tags': self.tags,
            'created_at': self.created_at,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        websocket_client = NostrWebSocketClient(relay_urls)

        try:
            responses = websocket_client.connect_and_publish(event_data)
            if all(response[0] == 'OK' and response[2] for response in responses):
                self.write({'published': True})
                _logger.info(f"Nostr event successfully published: {self.id}")
            else:
                self.write({'published': False})
                _logger.error(f"Error publishing Nostr event {self.id}: {responses}")
        except Exception as e:
            self.write({'published': False})
            _logger.error(f"Error publishing Nostr event {self.id}: {e}")

    def to_nostr_event(self):
        try:
            tags = json.loads(self.tags) if self.tags else []
        except json.JSONDecodeError:
            _logger.warning(f"Invalid JSON in tags for event {self.id}. Using empty tags list.")
            tags = []

        return NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=tags,
            public_key=self.public_key,
            created_at=self.created_at,
            sig=self.signature
        )
=== ./git_nostr_object/models/git_blob.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitBlob(models.Model):
    _name = 'git.blob'
    _inherit = 'git.object'
    _description = 'Git Blob'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3123,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_blob = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_blob.sha,
            'data': git_blob.data.hex(),
        })
=== ./git_nostr_object/models/git_tree.py ===
from odoo import models, fields, api
from .git_object import GitObject

class GitTree(models.Model):
    _name = 'git.tree'
    _inherit = 'git.object'
    _description = 'Git Tree'

    def to_nostr_event(self):
        return self.env['nostr.event.object'].create({
            'kind': 3122,
            'content': self.data,
            'tags': [['sha', self.sha]],
        })

    @api.model
    def create_from_nostr_event(self, event):
        git_tree = GitObject.from_nostr_event(event)
        return self.create({
            'sha': git_tree.sha,
            'data': git_tree.data.decode('utf-8', errors='replace'),
        })
=== ./git_nostr_object/models/nostr_event.py ===
# models/nostr_event.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from ..utils.nostr_websocket_client import NostrWebSocketClient
from nostr.event import Event as NostrEvent
from nostr.key import PrivateKey
import logging
import json
import time

_logger = logging.getLogger(__name__)

class NostrEventObject(models.Model):
    _name = 'nostr.event.object'
    _description = 'Nostr Event Object'

    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature')
    public_key = fields.Char(string='Public Key', required=True)
    published = fields.Boolean(string='Published', default=False)
    logs = fields.Text(string='Logs')

    def action_publish(self):
        self.ensure_one()
        if self.published:
            raise UserError(_("This event has already been published."))

        start_time = time.time()
        logs = []

        # Get the user's private key
        user = self.env.user
        private_key_nsec = user.nostr_private_key
        if not private_key_nsec:
            raise UserError(_("Nostr private key is not set for the current user."))

        try:
            private_key = PrivateKey.from_nsec(private_key_nsec)
        except Exception as e:
            raise UserError(_("Invalid Nostr private key: %s") % str(e))

        logs.append(f"Key preparation took {time.time() - start_time:.4f} seconds")

        # Create and sign the Nostr event
        event_creation_start = time.time()
        event = NostrEvent(
            kind=self.kind,
            content=self.content,
            tags=json.loads(self.tags) if self.tags else [],
            public_key=private_key.public_key.hex(),
            created_at=int(time.time())
        )
        private_key.sign_event(event)
        logs.append(f"Event creation and signing took {time.time() - event_creation_start:.4f} seconds")

        # Update the record
        self.write({
            'signature': event.signature,
            'public_key': event.public_key,
            'created_at': event.created_at
        })

        relay_urls = [
            'wss://relay.damus.io',
            'wss://nostr-pub.wellorder.net',
            'wss://nostr.mom',
            'wss://nostr.slothy.win',
            'wss://relay.stoner.com'
        ]

        event_data = json.loads(event.to_message())[1]
        websocket_client = NostrWebSocketClient(relay_urls)

        publish_start = time.time()
        try:
            responses, ws_logs = websocket_client.connect_and_publish(event_data)
            logs.extend(ws_logs)
            if any(response[0] == 'OK' for response in responses):
                self.write({'published': True})
                logs.append(f"Nostr event successfully published: {self.id}")
                self.env['bus.bus']._sendone(self.env.user.partner_id, 'simple_notification', {
                    'title': _("Nostr Event Published"),
                    'message': _("Event successfully published to Nostr network"),
                })
            else:
                error_msg = f"Error publishing Nostr event {self.id}: {responses}"
                logs.append(error_msg)
                raise UserError(_(error_msg))
        except Exception as e:
            error_msg = f"Error publishing Nostr event {self.id}: {e}"
            logs.append(error_msg)
            raise UserError(_(error_msg))
        finally:
            logs.append(f"Publishing process took {time.time() - publish_start:.4f} seconds")

        logs.append(f"Total publish action took {time.time() - start_time:.4f} seconds")
        self.write({'logs': '\n'.join(logs)})

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _("Nostr Event"),
                'message': _("Event published successfully. Check logs for details."),
                'sticky': False,
                'type': 'success',
            }
        }
=== ./git_nostr_object/models/git_commit_wizard.py ===
from odoo import models, fields, api

class GitCommitWizard(models.TransientModel):
    _name = 'git.commit.wizard'
    _description = 'Git Commit Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    message = fields.Text(string='Commit Message', required=True)
    file_data = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_commit(self):
        repo = self.repository_id
        with open(f"{repo.path}/{self.file_name}", 'w') as f:
            f.write(self.file_data)
        commit = repo.create_commit(self.message, [self.file_name])
        return {'type': 'ir.actions.act_window_close'}
=== ./git_nostr_object/models/admin_test.py ===
# /opt/odoo/custom_addons/git_nostr_object/models/admin_test.py
from odoo import models, api
from ..tests.test_git_nostr_object import test_git_nostr_object, test_nostr_auth

class AdminTest(models.TransientModel):
    _name = 'git_nostr_object.admin_test'
    _description = 'Admin Test for Git-Nostr Object'

    def run_tests(self):
        test_git_nostr_object()
        test_nostr_auth()
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Test Results',
                'message': 'Tests completed. Check the logs for details.',
                'sticky': False,
            }
        }
=== ./git_nostr_object/__init__.py ===
from . import models
from . import controllers
=== ./git_nostr_object/utils/nostr_websocket_client.py ===
# utils/nostr_websocket_client.py
import logging
import time
import websocket
import json

_logger = logging.getLogger(__name__)

class NostrWebSocketClient:
    def __init__(self, relay_urls):
        self.relay_urls = relay_urls

    def connect_and_publish(self, event_data):
        responses = []
        logs = []
        for url in self.relay_urls:
            try:
                response, log = self._connect_and_publish_to_relay(url, event_data)
                responses.append(response)
                logs.extend(log)
            except Exception as e:
                error_message = f"Error publishing event to relay {url}: {e}"
                _logger.error(error_message)
                logs.append(error_message)
        return responses, logs

    def _connect_and_publish_to_relay(self, relay_url, event_data):
        log = []
        log.append(f"Attempting to connect to {relay_url}")
        start_time = time.time()

        ws = websocket.create_connection(relay_url)
        log.append(f"Connected to {relay_url} in {time.time() - start_time:.2f} seconds")

        event_message = json.dumps(["EVENT", event_data])
        log.append(f"Sending Nostr event to {relay_url}")
        ws.send(event_message)
        log.append(f"Sent message to {relay_url} in {time.time() - start_time:.2f} seconds")

        log.append(f"Waiting for response from {relay_url}")
        response = ws.recv()
        log.append(f"Received response from {relay_url} in {time.time() - start_time:.2f} seconds: {response}")
        ws.close()
        return json.loads(response), log
=== ./git_nostr_object/__manifest__.py ===
{
    'name': 'git_nostr_object',
    'version': '1.0',
    'depends': ['base', 'bus'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/git_commit_views.xml',
        'views/git_tree_views.xml',
        'views/git_blob_views.xml',
        'views/git_object_views.xml',
        'views/nostr_event_object_views.xml',
        'views/actions.xml',
        'views/menus.xml',
        'views/admin_test_views.xml',
        'views/git_commit_wizard_views.xml'
    ],
    'assets': {
        'web.assets_backend': [
            'git_nostr_object/static/src/js/git_nostr_notifications.js',
        ],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./git_nostr_object/static/src/js/git_nostr_notifications.js ===
// static/src/js/git_nostr_notifications.js
odoo.define('git_nostr_object.notifications', function (require) {
    "use strict";

    var core = require('web.core');
    var session = require('web.session');
    var BusService = require('bus.BusService');

    BusService.include({
        _onNotification: function (notifications) {
            var self = this;
            _.each(notifications, function (notification) {
                if (notification[0][1] === 'simple_notification') {
                    self.displayNotification({
                        title: notification[1].title,
                        message: notification[1].message,
                        type: 'info',
                    });
                }
            });
            this._super.apply(this, arguments);
        },
    });
});
=== ./git_nostr_object/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_commit,access_git_commit,model_git_commit,base.group_user,1,1,1,1
access_git_tree,access_git_tree,model_git_tree,base.group_user,1,1,1,1
access_git_blob,access_git_blob,model_git_blob,base.group_user,1,1,1,1
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_object,access_nostr_event_object,model_nostr_event_object,base.group_user,1,1,1,1
=== ./git_nostr_object/tests/__init__.py ===
# /opt/odoo/custom_addons/git_nostr_object/tests/__init__.py
from . import test_git_nostr_object
=== ./git_nostr_object/tests/test_git_nostr_object.py ===
from odoo.tests.common import TransactionCase
from datetime import datetime
import random
import string
import logging
import os

_logger = logging.getLogger(__name__)

def random_string(length=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_sha():
    """Generate a random 40-character SHA hash"""
    return ''.join(random.choices('0123456789abcdef', k=40))

def get_current_timestamp():
    """Return the current timestamp"""
    return int(datetime.now().timestamp())

def get_author(env):
    """Return the logged-in user's name as the author"""
    return env.user.name

def get_local_path():
    """Return the Odoo installation path as the local path"""
    return '/opt/odoo'

def generate_nostr_keys():
    """Generate random 64-character Nostr public and private keys for the logged-in user"""
    public_key = random_string(64)
    private_key = random_string(64)
    return public_key, private_key

def get_event_type(content):
    """Extract the event type from the first line of the content"""
    return int(content.split('\n')[0].strip('# '))

def get_event_name(content):
    """Extract the event name from the first line of the content"""
    return content.split('\n', 1)[0]

def check_method_existence(env, methods):
    """Check if the required methods exist in the corresponding models"""
    for model, method_name in methods.items():
        model_obj = env[model]
        if not hasattr(model_obj, method_name):
            return False, f"Method '{method_name}' not found in model '{model}'"
    return True, "All required methods found"

class TestGitNostrObject(TransactionCase):

    def setUp(self):
        super(TestGitNostrObject, self).setUp()
        self.GitRepository = self.env['git.repository']
        self.GitCommit = self.env['git.commit']
        self.GitTree = self.env['git.tree']
        self.GitBlob = self.env['git.blob']
        self.GitNostrEventObject = self.env['git_nostr.event.object']
        self.NostrKey = self.env['nostr.key']
        self.NostrRelay = self.env['nostr.relay']
        self.NostrProfile = self.env['nostr.profile']

        # Check if required methods exist in the corresponding models
        required_methods = {
            'git.repository': 'traverse_and_publish',
            'nostr.event.object': 'action_publish',
            'nostr.key': 'generate_key_pair',
            'nostr.key': 'sign_event'
        }
        success, message = check_method_existence(self.env, required_methods)
        if not success:
            self.fail(message)

    def test_git_nostr_object(self):
        _logger.info("Testing Git-Nostr Object module...")

        # Test Git Repository
        repo_name = f'Test Repo {random_string()}'
        repo_path = f'{get_local_path()}/custom_addons/git_nostr_object/tests/test_repo_{random_string()}'
        repo = self.GitRepository.create({
            'name': repo_name,
            'path': repo_path
        })
        _logger.info(f"Created Git Repository with ID: {repo.id}")

        # Test traverse_and_publish
        try:
            repo.traverse_and_publish()
            _logger.info("traverse_and_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in traverse_and_publish: {e}")

        # Test Git Commit
        commit_sha = generate_sha()
        commit_author = get_author(self.env)
        commit_timestamp = get_current_timestamp()
        commit_data = 'Test commit data'
        commit = self.GitCommit.create({
            'sha': commit_sha,
            'message': 'Test commit message',
            'author': commit_author,
            'timestamp': commit_timestamp,
            'data': commit_data
        })
        _logger.info(f"Created Git Commit with ID: {commit.id}")

        # Test Git Tree
        tree_sha = generate_sha()
        tree_data = 'Test tree data'
        tree = self.GitTree.create({
            'sha': tree_sha,
            'data': tree_data
        })
        _logger.info(f"Created Git Tree with ID: {tree.id}")

        # Test Git Blob
        blob_sha = generate_sha()
        blob_data = 'Test blob data'
        blob = self.GitBlob.create({
            'sha': blob_sha,
            'data': blob_data
        })
        _logger.info(f"Created Git Blob with ID: {blob.id}")

        # Test Nostr Event Object
        event_content = '# 1\nTest Nostr event content'
        event_type = get_event_type(event_content)
        event_tags = '[]'
        event_created_at = get_current_timestamp()
        event_signature = random_string(64)
        event_name = get_event_name(event_content)
        event = self.GitNostrEventObject.create({
            'kind': event_type,
            'content': event_content,
            'tags': event_tags,
            'created_at': event_created_at,
            'signature': event_signature,
            'name': event_name
        })
        _logger.info(f"Created Nostr Event Object with ID: {event.id}")

        # Test action_publish
        try:
            event.action_publish()
            _logger.info("action_publish executed successfully")
        except Exception as e:
            _logger.error(f"Error in action_publish: {e}")

    def test_nostr_auth(self):
        _logger.info("Testing Nostr Authentication module...")

        # Test Nostr Key
        public_key, private_key = generate_nostr_keys()
        key = self.NostrKey.create({
            'public_key': public_key,
            'private_key': private_key,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Key with ID: {key.id}")

        # Test Nostr Relay
        relay_url = f'wss://relay{random_string()}.com'
        relay = self.NostrRelay.create({
            'url': relay_url,
            'is_active': True
        })
        _logger.info(f"Created Nostr Relay with ID: {relay.id}")

        # Test Nostr Profile
        profile_name = f'Test Profile {random_string()}'
        profile_about = 'Test profile description'
        profile_picture = 'http://example.com/pic.jpg'
        profile = self.NostrProfile.create({
            'name': profile_name,
            'about': profile_about,
            'picture': profile_picture,
            'user_id': self.env.user.id
        })
        _logger.info(f"Created Nostr Profile with ID: {profile.id}")

        # Test generate_key_pair method
        try:
            result = self.NostrKey.generate_key_pair()
            _logger.info(f"Generated key pair: {result}")
        except Exception as e:
            _logger.error(f"Error in generate_key_pair: {e}")

        # Test sign_event method (assuming it exists)
        try:
            event_data = {
                'kind': 1,
                'content': 'Test content',
                'created_at': get_current_timestamp(),
                'tags': []
            }
            result = key.sign_event(event_data)
            _logger.info(f"Signed event: {result}")
        except Exception as e:
            _logger.error(f"Error in sign_event: {e}")

def test_git_nostr_object():
    test_case = TestGitNostrObject.create({})
    test_case.test_git_nostr_object()

def test_nostr_auth():
    test_case = TestGitNostrObject.create({})
    test_case.test_nostr_auth()

# This allows running the test from the Odoo shell
if __name__ == '__main__':
    test_git_nostr_object()
    test_nostr_auth()
=== ./git_nostr_object/views/git_blob_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_blob_form" model="ir.ui.view">
        <field name="name">git.blob.form</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_blob_tree" model="ir.ui.view">
        <field name="name">git.blob.tree</field>
        <field name="model">git.blob</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_blob" model="ir.actions.act_window">
        <field name="name">Git Blobs</field>
        <field name="res_model">git.blob</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/menus.xml ===
<!-- views/menus.xml -->
<odoo>
    <menuitem id="menu_git_nostr_object_root" name="Git-Nostr Object">
        <menuitem id="menu_git_repository" name="Repositories" action="action_git_repository"/>
        <menuitem id="menu_git_commit" name="Commits" action="action_git_commit"/>
        <menuitem id="menu_git_tree" name="Trees" action="action_git_tree"/>
        <menuitem id="menu_git_blob" name="Blobs" action="action_git_blob"/>
        <menuitem id="menu_git_nostr_event_object" name="Nostr Event Objects" action="action_git_nostr_event_object"/>
    </menuitem>
</odoo>
=== ./git_nostr_object/views/git_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_form" model="ir.ui.view">
        <field name="name">git.commit.form</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="message"/>
                    <field name="author"/>
                    <field name="timestamp"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_commit_tree" model="ir.ui.view">
        <field name="name">git.commit.tree</field>
        <field name="model">git.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
                <field name="message"/>
                <field name="author"/>
                <field name="timestamp"/>
            </tree>
        </field>
    </record>

    <record id="action_git_commit" model="ir.actions.act_window">
        <field name="name">Git Commits</field>
        <field name="res_model">git.commit</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/git_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_object_form" model="ir.ui.view">
        <field name="name">git.object.form</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_object_tree" model="ir.ui.view">
        <field name="name">git.object.tree</field>
        <field name="model">git.object</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>
</odoo>
=== ./git_nostr_object/views/admin_test_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_admin_test_form" model="ir.ui.view">
        <field name="name">git_nostr_object.admin_test.form</field>
        <field name="model">git_nostr_object.admin_test</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="run_tests" string="Run Tests" type="object" class="oe_highlight"/>
                </header>
                <div>
                    <p>Click the button to run the Git-Nostr Object tests.</p>
                </div>
            </form>
        </field>
    </record>

    <record id="action_admin_test" model="ir.actions.act_window">
        <field name="name">Admin Tests</field>
        <field name="res_model">git_nostr_object.admin_test</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <menuitem id="menu_admin_test" name="Admin Tests" parent="menu_git_nostr_object_root" action="action_admin_test" groups="base.group_system"/>
</odoo>
=== ./git_nostr_object/views/git_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_commit_wizard_form" model="ir.ui.view">
        <field name="name">git.commit.wizard.form</field>
        <field name="model">git.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="repository_id" invisible="1"/>
                    <field name="message"/>
                    <field name="file_name"/>
                    <field name="file_data"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>
</odoo>
=== ./git_nostr_object/views/git_tree_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_tree_form" model="ir.ui.view">
        <field name="name">git.tree.form</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="sha"/>
                    <field name="data"/>
                </group>
            </form>
        </field>
    </record>

    <record id="view_git_tree_tree" model="ir.ui.view">
        <field name="name">git.tree.tree</field>
        <field name="model">git.tree</field>
        <field name="arch" type="xml">
            <tree>
                <field name="sha"/>
            </tree>
        </field>
    </record>

    <record id="action_git_tree" model="ir.actions.act_window">
        <field name="name">Git Trees</field>
        <field name="res_model">git.tree</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/nostr_event_object_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_object_form" model="ir.ui.view">
        <field name="name">nostr.event.object.form</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish Event" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="kind"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="public_key"/>
                        <field name="published"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_object_tree" model="ir.ui.view">
        <field name="name">nostr.event.object.tree</field>
        <field name="model">nostr.event.object</field>
        <field name="arch" type="xml">
            <tree string="Nostr Event Objects">
                <field name="kind"/>
                <field name="content"/>
                <field name="tags"/>
                <field name="created_at"/>
                <field name="signature"/>
                <field name="public_key"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="traverse_and_publish" string="Traverse and Publish" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path" string="Local Path"/>
                    </group>
                    <notebook>
                        <page string="Logs">
                            <field name="logs" widget="text" readonly="1"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/views/actions.xml ===
<!-- views/actions.xml -->
<odoo>
    <record id="action_git_nostr_event_object" model="ir.actions.act_window">
        <field name="name">Nostr Event Objects</field>
        <field name="res_model">nostr.event.object</field>
        <field name="view_mode">tree,form</field>
    </record>
</odoo>
=== ./git_nostr_object/controllers/git_controller.py ===
from odoo import http
from odoo.http import request
import logging

_logger = logging.getLogger(__name__)

class GitController(http.Controller):

    @http.route('/git_nostr_object/traverse_repo', type='json', auth='user')
    def traverse_repo(self, repo_id):
        try:
            repo = request.env['git.repository'].browse(repo_id)
            repo.traverse_and_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error traversing repository")
            return {'status': 'error', 'message': str(e)}

    @http.route('/git_nostr_object/publish_event', type='json', auth='user')
    def publish_event(self, event_id):
        try:
            event = request.env['git_nostr.event.object'].browse(event_id)
            event.action_publish()
            return {'status': 'success'}
        except Exception as e:
            _logger.exception("Error publishing Nostr event")
            return {'status': 'error', 'message': str(e)}
=== ./git_nostr_bridge/models/git_repository.py ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./git_nostr_bridge/models/__init__.py ===
from . import git_repository
from . import nostr_event
from . import res_config_settings
=== ./git_nostr_bridge/models/res_users.py ===
from odoo import models, fields, api
from nostr.key import PrivateKey

class ResUsers(models.Model):
    _inherit = 'res.users'

    nostr_public_key = fields.Char(string="Nostr Public Key")
    nostr_private_key = fields.Char(string="Nostr Private Key")
    nostr_relay_url = fields.Char(string="Nostr Relay URL")

    @api.depends('nostr_private_key')
    def _compute_public_key(self):
        for user in self:
            if user.nostr_private_key:
                try:
                    private_key = PrivateKey.from_nsec(user.nostr_private_key)
                    user.nostr_public_key = private_key.public_key.hex()
                except Exception:
                    user.nostr_public_key = False
            else:
                user.nostr_public_key = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' not in vals or not vals['nostr_private_key']:
            private_key = PrivateKey()
            vals['nostr_private_key'] = private_key.bech32()
        return super(ResUsers, self).create(vals)
=== ./git_nostr_bridge/models/nostr_event.py ===
import asyncio
import json
import logging
import websockets
from urllib.parse import urlparse
import time
import traceback

from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event as NostrLibEvent
from nostr.key import PrivateKey

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'
    _inherit = 'nostr.event'

    name = fields.Char(string='Name', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    content = fields.Text(string='Content')
    tags = fields.Text(string='Tags')
    published = fields.Boolean(string='Published', default=False)
    event_id = fields.Char(string='Event ID', readonly=True)
    kind = fields.Integer(string='Nostr Event Kind', default=1)
    repository_id = fields.Many2one('git.repository', string='Related Repository')

    @api.model
    def action_publish(self, event_id):
        event = self.browse(event_id)
        _logger.info(f"Starting publish action for event: {event.name}")
        start_time = time.time()

        try:
            if not self.env.user.nostr_private_key:
                raise UserError(_("Nostr private key is not set for the current user."))

            _logger.info("Generating private key")
            try:
                private_key = PrivateKey.from_nsec(self.env.user.nostr_private_key)
                _logger.info("Private key generated successfully")
            except Exception as e:
                _logger.error(f"Failed to generate private key: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid Nostr private key: %s") % str(e))

            public_key = private_key.public_key.hex()
            _logger.info(f"Public key: {public_key}")

            _logger.info("Parsing tags")
            try:
                tags = json.loads(event.tags) if event.tags else []
                _logger.info(f"Parsed tags: {tags}")
                if not isinstance(tags, list):
                    raise ValueError("Tags must be a list of lists")
                for tag in tags:
                    if not isinstance(tag, list):
                        raise ValueError("Each tag must be a list")
            except json.JSONDecodeError as e:
                _logger.error(f"JSON decode error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format. Please ensure tags are in valid JSON format."))
            except ValueError as e:
                _logger.error(f"Value error: {str(e)}")
                _logger.error(traceback.format_exc())
                raise UserError(_("Invalid tags format: %s") % str(e))

            _logger.info("Creating Nostr event")
            nostr_event = NostrLibEvent(
                kind=1,  # Assuming TEXT_NOTE, adjust if needed
                content=str(event.content),
                tags=tags,
                public_key=public_key  # Ensure public_key is provided
            )
            private_key.sign_event(nostr_event)
            _logger.info(f"Event created: {nostr_event.to_message()}")

            _logger.info("Fetching relay URLs")
            relay_urls = self.env['ir.config_parameter'].sudo().get_param('git_nostr_bridge.relay_urls', '').split(',')
            relay_urls = [url.strip() for url in relay_urls if url.strip()][:5]  # Limit to 5 relays
            _logger.info(f"Relay URLs: {relay_urls}")

            if not relay_urls:
                raise UserError(_("No Nostr relay URLs configured. Please set them in the settings."))

            _logger.info("Validating relay URLs")
            for url in relay_urls:
                parsed = urlparse(url)
                if parsed.scheme not in ('ws', 'wss'):
                    _logger.error(f"Invalid relay URL: {url}")
                    raise UserError(_("Invalid relay URL: %s. Must start with ws:// or wss://") % url)

            async def publish_to_relay(relay_url, nostr_event, retries=3):
                for attempt in range(retries):
                    try:
                        _logger.info(f"Attempting to connect to {relay_url} (attempt {attempt + 1})")
                        connection_start = time.time()
                        async with websockets.connect(relay_url, timeout=30) as websocket:
                            connection_end = time.time()
                            _logger.info(f"Connected to {relay_url} in {connection_end - connection_start:.2f} seconds")
                            
                            message = nostr_event.to_message()
                            _logger.debug(f"Raw event message: {message}")
                            
                            # The message is already in the correct format, so we don't need to modify it
                            _logger.info(f"Sending Nostr event to {relay_url}: {message}")
                            
                            send_start = time.time()
                            await websocket.send(message)
                            send_end = time.time()
                            _logger.info(f"Sent message to {relay_url} in {send_end - send_start:.2f} seconds")
                            
                            _logger.info(f"Waiting for response from {relay_url}")
                            response_start = time.time()
                            response = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                            response_end = time.time()
                            _logger.info(f"Received response from {relay_url} in {response_end - response_start:.2f} seconds: {response}")
                            
                            try:
                                return json.loads(response)
                            except json.JSONDecodeError as e:
                                _logger.error(f"Failed to parse response from {relay_url}: {str(e)}")
                                return f"Invalid response from {relay_url}: {response}"
                    except (websockets.exceptions.WebSocketException, asyncio.TimeoutError) as e:
                        _logger.error(f"Error publishing to {relay_url} (attempt {attempt + 1}): {str(e)}")
                        _logger.error(traceback.format_exc())
                        await asyncio.sleep(5 * (attempt + 1))  # Increased delay between attempts
                return f"Failed to publish to {relay_url} after {retries} attempts"

            async def publish_with_timeout():
                tasks = [publish_to_relay(url, nostr_event) for url in relay_urls]
                return await asyncio.gather(*tasks, return_exceptions=True)

            async def run_publication():
                _logger.info("Starting publication process")
                try:
                    results = await asyncio.wait_for(publish_with_timeout(), timeout=120)  # Increased overall timeout
                    _logger.info(f"Publication results: {results}")
                    return results
                except asyncio.TimeoutError:
                    _logger.error("Publication process timed out after 120 seconds")
                    raise UserError(_("Publishing timed out after 120 seconds"))

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                results = loop.run_until_complete(run_publication())
            finally:
                loop.close()

            success = any(isinstance(result, list) and result[0] == "OK" for result in results)
            if success:
                event.write({
                    'published': True,
                    'event_id': nostr_event.id
                })
                _logger.info(f"Successfully published Nostr event: {nostr_event.id}")
                
                # Verify event publication
                self.verify_event_publication(nostr_event.id, relay_urls)
                
                end_time = time.time()
                _logger.info(f"Total publish action time: {end_time - start_time:.2f} seconds")
                
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'message': _("Nostr event successfully published to at least one relay."),
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                error_messages = [str(result) for result in results if isinstance(result, str)]
                _logger.error(f"Failed to publish Nostr event: {'; '.join(error_messages)}")
                raise UserError(_("Failed to publish Nostr event: %s") % "; ".join(error_messages))

        except Exception as e:
            _logger.error(f"Unexpected error in action_publish: {str(e)}")
            _logger.error(traceback.format_exc())
            raise UserError(_("An unexpected error occurred: %s") % str(e))

    @api.model
    def verify_event_publication(self, event_id, relay_urls, max_attempts=5, delay=2):
        _logger.info(f"Starting verification for event: {event_id}")
        for attempt in range(max_attempts):
            _logger.info(f"Verification attempt {attempt + 1}")
            for url in relay_urls:
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(self.query_event(url, event_id))
                    if result:
                        _logger.info(f"Event {event_id} found on relay {url}")
                        return True
                except Exception as e:
                    _logger.error(f"Error querying event from {url}: {str(e)}")
                    _logger.error(traceback.format_exc())
                finally:
                    loop.close()
            _logger.info(f"Waiting {delay} seconds before next attempt")
            time.sleep(delay)
        _logger.warning(f"Event {event_id} not found on any relay after {max_attempts} attempts")
        return False

    async def query_event(self, relay_url, event_id):
        _logger.info(f"Querying event {event_id} from {relay_url}")
        start_time = time.time()
        try:
            async with websockets.connect(relay_url, timeout=10) as websocket:
                request = json.dumps(["REQ", "query", {"ids": [event_id]}])
                _logger.info(f"Sending query to {relay_url}: {request}")
                await websocket.send(request)
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                _logger.info(f"Response from {relay_url}: {response}")
                end_time = time.time()
                _logger.info(f"Query to {relay_url} took {end_time - start_time:.2f} seconds")
                return json.loads(response)
        except Exception as e:
            _logger.error(f"Error querying {relay_url}: {str(e)}")
            _logger.error(traceback.format_exc())
            end_time = time.time()
            _logger.info(f"Failed query to {relay_url} took {end_time - start_time:.2f} seconds")
            return None
=== ./git_nostr_bridge/models/res_config_settings.py ===
import requests
import json
from odoo import fields, models, api
import logging

_logger = logging.getLogger(__name__)

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    git_nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='git_nostr_bridge.relay_urls',
        default=lambda self: self._default_nostr_relays()
    )

    def _default_nostr_relays(self):
        return self._get_top_nostr_relays()

    @api.model
    def _get_top_nostr_relays(self, limit=108):
        url = "https://api.nostr.watch/v1/online"
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            _logger.info(f"Response status code: {response.status_code}")
            
            data = response.json()
            _logger.info(f"API response (first 108 items): {data[:108]}")
            
            relays = data[:108]
            _logger.info(f"Number of relay links found: {len(relays)}")
            _logger.info(f"Extracted relays (first 5): {relays[:5]}")
            
            relay_urls = ",".join(relays)
            return relay_urls
        except requests.RequestException as e:
            _logger.error(f"Error fetching Nostr relays: {e}")
            return "wss://nostr-relay.app,wss://nos.lol,wss://relay.snort.social,wss://relay.nostr.net"

    nostr_relay_urls = fields.Char(
        string="Nostr Relay URLs", 
        config_parameter='nostr_bridge.relay_urls',
        default=_default_nostr_relays
    )

    @api.model
    def get_values(self):
        res = super(ResConfigSettings, self).get_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        
        relay_urls = ICPSudo.get_param('git_nostr_bridge.relay_urls')
        if not relay_urls:
            relay_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', relay_urls)
            _logger.info(f"Set new relay URLs: {relay_urls[:100]}...")
        else:
            _logger.info(f"Using existing relay URLs: {relay_urls[:100]}...")
        
        res.update(git_nostr_relay_urls=relay_urls)
        return res

    def set_values(self):
        super(ResConfigSettings, self).set_values()
        ICPSudo = self.env['ir.config_parameter'].sudo()
        if self.git_nostr_relay_urls:
            ICPSudo.set_param('git_nostr_bridge.relay_urls', self.git_nostr_relay_urls)
            _logger.info(f"Updated relay URLs: {self.git_nostr_relay_urls[:100]}...")
        else:
            default_urls = self._default_nostr_relays()
            ICPSudo.set_param('git_nostr_bridge.relay_urls', default_urls)
            _logger.info(f"Set default relay URLs: {default_urls[:100]}...")
=== ./git_nostr_bridge/models/git_repository ===
# models/git_repository.py
import os
import git
from odoo import models, fields, api, _
from odoo.exceptions import UserError

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Name', required=True)
    path = fields.Char(string='Local Path', required=True)
    remote_url = fields.Char(string='Remote URL')
    branch = fields.Char(string='Current Branch', default='main')
    last_commit = fields.Char(string='Last Commit', readonly=True)

    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        repo._initialize_repository()
        return repo

    def _initialize_repository(self):
        if not os.path.exists(self.path):
            os.makedirs(self.path)
            repo = git.Repo.init(self.path)
            if self.remote_url:
                repo.create_remote('origin', self.remote_url)
            open(os.path.join(self.path, 'README.md'), 'w').close()
            repo.index.add(['README.md'])
            repo.index.commit('Initial commit')
            self.last_commit = repo.head.commit.hexsha

    def action_pull(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.pull()
        self.last_commit = repo.head.commit.hexsha

    def action_push(self):
        repo = git.Repo(self.path)
        origin = repo.remotes.origin
        origin.push()

    def action_commit(self):
        return {
            'name': _('Create Commit'),
            'type': 'ir.actions.act_window',
            'res_model': 'create.nostr.event.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {'default_repository_id': self.id, 'default_event_type': 'commit'},
        }
=== ./git_nostr_bridge/__init__.py ===
from . import models
from . import wizard
=== ./git_nostr_bridge/__manifest__.py ===
{
    'name': 'Git-Nostr Bridge',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Integrates Git repositories with Nostr network',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail', 'nostr_auth', 'nostr_bridge', 'integrated_ivcs'],
    'data': [
        'security/ir.model.access.csv',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'views/res_users_views.xml',
        'wizard/create_nostr_event_wizard_views.xml',
    ],
    'installable': True,
    'application': True,
    'auto_install': False,
    'external_dependencies': {
        'python': ['git', 'nostr', 'websockets'],
    },
}
=== ./git_nostr_bridge/wizard/create_nostr_event_wizard.py ===
# wizard/create_nostr_event_wizard.py
from odoo import models, fields, api
import git
import json

class CreateNostrEventWizard(models.TransientModel):
    _name = 'create.nostr.event.wizard'
    _description = 'Create Nostr Event Wizard'

    repository_id = fields.Many2one('git.repository', string='Repository', required=True)
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type', required=True)
    commit_message = fields.Text(string='Commit Message')
    branch_name = fields.Char(string='Branch Name')
    file_content = fields.Text(string='File Content')
    file_name = fields.Char(string='File Name')

    def action_create_event(self):
        repo = git.Repo(self.repository_id.path)
        
        if self.event_type == 'commit':
            # Stage all changes
            repo.git.add(A=True)
            # Commit changes
            commit = repo.index.commit(self.commit_message)
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'commit',
                'repository': self.repository_id.name,
                'commit_hash': commit.hexsha,
                'message': self.commit_message,
            })
        elif self.event_type == 'branch':
            repo.git.checkout('-b', self.branch_name)
            self.repository_id.branch = self.branch_name
            content = json.dumps({
                'type': 'branch',
                'repository': self.repository_id.name,
                'branch_name': self.branch_name,
            })
        elif self.event_type == 'blob':
            with open(os.path.join(self.repository_id.path, self.file_name), 'w') as f:
                f.write(self.file_content)
            repo.index.add([self.file_name])
            commit = repo.index.commit(f"Add file: {self.file_name}")
            self.repository_id.last_commit = commit.hexsha
            content = json.dumps({
                'type': 'blob',
                'repository': self.repository_id.name,
                'file_name': self.file_name,
                'commit_hash': commit.hexsha,
            })
        
        self.env['nostr.event'].create({
            'name': f"{self.event_type.capitalize()} - {self.repository_id.name}",
            'event_type': self.event_type,
            'content': content,
            'tags': json.dumps([['r', self.repository_id.remote_url]]),
        })

        return {'type': 'ir.actions.act_window_close'}
=== ./git_nostr_bridge/wizard/__init__.py ===
# wizard/__init__.py
from . import create_nostr_event_wizard
=== ./git_nostr_bridge/wizard/create_nostr_event_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_nostr_event_wizard_form" model="ir.ui.view">
        <field name="name">create.nostr.event.wizard.form</field>
        <field name="model">create.nostr.event.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Nostr Event">
                <group>
                    <field name="repository_id"/>
                    <field name="event_type"/>
                    <field name="commit_message" attrs="{'invisible': [('event_type', '!=', 'commit')], 'required': [('event_type', '=', 'commit')]}"/>
                    <field name="branch_name" attrs="{'invisible': [('event_type', '!=', 'branch')], 'required': [('event_type', '=', 'branch')]}"/>
                    <field name="file_name" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}"/>
                    <field name="file_content" attrs="{'invisible': [('event_type', '!=', 'blob')], 'required': [('event_type', '=', 'blob')]}" widget="ace" options="{'mode': 'xml'}"/>
                </group>
                <footer>
                    <button name="action_create_event" string="Create Event" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_nostr_event_wizard" model="ir.actions.act_window">
        <field name="name">Create Nostr Event</field>
        <field name="res_model">create.nostr.event.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./git_nostr_bridge/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_git_repository,access_git_repository,model_git_repository,base.group_user,1,1,1,1
access_nostr_event,access_nostr_event,model_nostr_event,base.group_user,1,1,1,1
access_create_nostr_event_wizard,access_create_nostr_event_wizard,model_create_nostr_event_wizard,base.group_user,1,1,1,0
=== ./git_nostr_bridge/views/res_users_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_users_form_inherit_git_nostr" model="ir.ui.view">
        <field name="name">res.users.form.inherit.git.nostr</field>
        <field name="model">res.users</field>
        <field name="inherit_id" ref="base.view_users_form"/>
        <field name="arch" type="xml">
            <notebook position="inside">
                <page string="Nostr Settings" name="nostr_settings">
                    <group>
                        <field name="nostr_private_key" password="True"/>
                        <field name="nostr_public_key"/>
                    </group>
                </page>
            </notebook>
        </field>
    </record>
</odoo>
=== ./git_nostr_bridge/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.git_nostr_bridge</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Git-Nostr Bridge" string="Git-Nostr Bridge" data-key="git_nostr_bridge">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <div class="mt16">
                                        <field name="git_nostr_relay_urls"/>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./git_nostr_bridge/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_publish" string="Publish" type="object" class="oe_highlight" attrs="{'invisible': [('published', '=', True)]}"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="published"/>
                        <field name="event_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_form_git_nostr" model="ir.ui.view">
        <field name="name">nostr.event.form.git.nostr</field>
        <field name="model">nostr.event</field>
        <field name="inherit_id" ref="integrated_ivcs.view_nostr_event_form"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='event_type']" position="after">
                <field name="repository_id" attrs="{'invisible': [('event_type', 'not in', ['repo_anchor', 'branch', 'commit', 'tree', 'blob'])]}"/>
            </xpath>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event_git" name="Git Nostr Events" parent="menu_git_nostr_bridge" action="integrated_ivcs.action_nostr_event" sequence="20"/>
</odoo>
=== ./git_nostr_bridge/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_pull" string="Pull" type="object" class="oe_highlight"/>
                    <button name="action_push" string="Push" type="object" class="oe_highlight"/>
                    <button name="action_commit" string="Commit" type="object" class="oe_highlight"/>
                </header>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                        <field name="remote_url"/>
                        <field name="branch"/>
                        <field name="last_commit"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_nostr_bridge" name="Git-Nostr Bridge" sequence="10"/>
    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_git_nostr_bridge" action="action_git_repository" sequence="10"/>
</odoo>
=== ./custom_auth/models/res_users.py ===
from odoo import models, api
from odoo.exceptions import AccessDenied
import requests

class ResUsers(models.Model):
    _inherit = 'res.users'

    @classmethod
    def _login(cls, db, login, password):
        if not cls.validate_external_auth(login, password):
            raise AccessDenied()
        return super(ResUsers, cls)._login(db, login, password)

    @classmethod
    def validate_external_auth(cls, login, token):
        # Replace with your actual localhost API endpoint
        validation_url = 'http://localhost/validate_admin'
        response = requests.post(validation_url, json={'login': login, 'token': token})
        return response.status_code == 200 and response.json().get('is_admin', False)
=== ./custom_auth/__manifest__.py ===
{
    'name': 'Custom External Authentication',
    'version': '1.0',
    'category': 'Hidden',
    'summary': 'Custom authentication for external admin access',
    'depends': ['base'],
    'data': [],
    'installable': True,
}
=== ./opinion_reputation_nostr/models/__init__.py ===
from . import opinion_reputation
from . import nostr_event
=== ./opinion_reputation_nostr/models/nostr_event.py ===
from odoo import models, api, _
from odoo.exceptions import UserError
import json
import logging

_logger = logging.getLogger(__name__)

class NostrEvent(models.AbstractModel):
    _name = 'opinion.nostr.event'
    _description = 'Nostr Event for Opinion Reputation'

    @api.model
    def create_prediction_event(self, prediction):
        content = json.dumps({
            'question_id': prediction.question_id.id,
            'question_text': prediction.question_id.text,
            'answer': prediction.answer,
            'confidence': prediction.confidence
        })
        
        try:
            nostr_event = self.env['nostr.event']
            event = nostr_event.create_event(
                kind=1,  # You might want to use a custom event kind for predictions
                content=content,
                tags=[['p', prediction.user_id.nostr_public_key]],
                private_key=prediction.user_id.nostr_private_key
            )
            
            nostr_event.publish_event(event)
            _logger.info(f"Nostr event created and published for prediction {prediction.id}")
        except AttributeError:
            _logger.warning("Nostr bridge not available. Prediction event not published to Nostr.")
        except Exception as e:
            _logger.error(f"Error creating Nostr event: {str(e)}")
            raise UserError(_("Failed to create Nostr event: %s") % str(e))
=== ./opinion_reputation_nostr/models/opinion_reputation.py ===
from odoo import models, fields, api
from odoo.exceptions import UserError
import enum
import logging

_logger = logging.getLogger(__name__)

class AnswerChoice(enum.Enum):
    AGREE = "I Agree"
    DO_NOT_DISAGREE = "I do not disagree"
    DO_NOT_AGREE = "I do not agree"
    DISAGREE = "I Disagree"

class User(models.Model):
    _inherit = 'res.users'

    reputation = fields.Float(default=0)

class Question(models.Model):
    _name = 'opinion.question'
    _description = 'Opinion Question'

    text = fields.Text(required=True)
    explanation = fields.Text()
    created_by = fields.Many2one('res.users', string='Created By')
    created_at = fields.Datetime(default=fields.Datetime.now)
    is_settled = fields.Boolean(default=False)
    last_revisited = fields.Datetime()

class Prediction(models.Model):
    _name = 'opinion.prediction'
    _description = 'Opinion Prediction'

    user_id = fields.Many2one('res.users', required=True)
    question_id = fields.Many2one('opinion.question', required=True)
    answer = fields.Selection([
        ('AGREE', 'I Agree'),
        ('DO_NOT_DISAGREE', 'I do not disagree'),
        ('DO_NOT_AGREE', 'I do not agree'),
        ('DISAGREE', 'I Disagree')
    ], required=True)
    confidence = fields.Float(required=True)
    timestamp = fields.Datetime(default=fields.Datetime.now)
    is_correct = fields.Boolean()

    @api.model
    def create(self, vals):
        prediction = super(Prediction, self).create(vals)
        try:
            self.env['opinion.nostr.event'].create_prediction_event(prediction)
        except Exception as e:
            _logger.error(f"Failed to create Nostr event for prediction {prediction.id}: {str(e)}")
        self.update_reputation(prediction.user_id.id)
        return prediction

    def update_reputation(self, user_id):
        user = self.env['res.users'].browse(user_id)
        predictions = self.search([('user_id', '=', user_id)])
        correct_predictions = predictions.filtered(lambda p: p.is_correct)
        if predictions:
            user.reputation = (len(correct_predictions) / len(predictions)) * 100

class OpinionReputationSystem(models.AbstractModel):
    _name = 'opinion.reputation.system'
    _description = 'Opinion Reputation System'

    @api.model
    def revisit_question(self, question_id):
        question = self.env['opinion.question'].browse(question_id)
        if (fields.Datetime.now() - question.created_at).days >= 4*365:
            predictions = self.env['opinion.prediction'].search([('question_id', '=', question_id)])
            total_votes = len(predictions)
            if total_votes > 0:
                agreement_ratio = len(predictions.filtered(lambda p: p.answer in ['AGREE', 'DO_NOT_DISAGREE'])) / total_votes
                question.write({
                    'is_settled': agreement_ratio >= 0.8333334,
                    'last_revisited': fields.Datetime.now()
                })

    @api.model
    def explain_answer_choices(self):
        return """
        Answer choices explanation:
        1. I Agree: You fully support and believe in the statement.
        2. I do not disagree: You somewhat agree or have no strong objection to the statement.
        3. I do not agree: You somewhat disagree or have some reservations about the statement.
        4. I Disagree: You fully oppose or do not believe in the statement.
        """
=== ./opinion_reputation_nostr/__init__.py ===
from . import models
=== ./opinion_reputation_nostr/__manifest__.py ===
{
    'name': 'Opinion Reputation with Nostr',
    'version': '1.0',
    'category': 'Tools',
    'summary': 'Opinion Reputation System with optional Nostr integration',
    'depends': ['base'],
    'data': [
        'security/ir.model.access.csv',
        'views/opinion_reputation_views.xml',
        'data/default_questions.xml',
    ],
    'installable': True,
    'application': True,
}
=== ./opinion_reputation_nostr/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_opinion_question,access_opinion_question,model_opinion_question,base.group_user,1,1,1,1
access_opinion_prediction,access_opinion_prediction,model_opinion_prediction,base.group_user,1,1,1,1
access_opinion_nostr_event,access_opinion_nostr_event,model_opinion_nostr_event,base.group_user,1,1,1,1
=== ./opinion_reputation_nostr/data/default_questions.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Add your default questions here -->
        <record id="question_1" model="opinion.question">
            <field name="text">Do life's challenges sometimes lead to self-doubt?</field>
            <field name="explanation">Sometimes when things get tough, we might wonder if we're good enough or if we can handle it.</field>
        </record>
        <!-- Add more questions as needed -->
    </data>
</odoo>
=== ./opinion_reputation_nostr/views/opinion_reputation_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_question_form" model="ir.ui.view">
        <field name="name">opinion.question.form</field>
        <field name="model">opinion.question</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="text"/>
                        <field name="explanation"/>
                        <field name="created_by"/>
                        <field name="created_at"/>
                        <field name="is_settled"/>
                        <field name="last_revisited"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_prediction_form" model="ir.ui.view">
        <field name="name">opinion.prediction.form</field>
        <field name="model">opinion.prediction</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="user_id"/>
                        <field name="question_id"/>
                        <field name="answer"/>
                        <field name="confidence"/>
                        <field name="timestamp"/>
                        <field name="is_correct"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="action_questions" model="ir.actions.act_window">
        <field name="name">Questions</field>
        <field name="res_model">opinion.question</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record id="action_predictions" model="ir.actions.act_window">
        <field name="name">Predictions</field>
        <field name="res_model">opinion.prediction</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_opinion_reputation" name="Opinion Reputation"/>
    <menuitem id="menu_questions" parent="menu_opinion_reputation" action="action_questions"/>
    <menuitem id="menu_predictions" parent="menu_opinion_reputation" action="action_predictions"/>
</odoo>
=== ./integrated_ivcs/models/git_repository.py ===
from odoo import models, fields, api
import git
import os

class GitRepository(models.Model):
    _name = 'git.repository'
    _description = 'Git Repository'

    name = fields.Char(string='Repository Name', required=True)
    path = fields.Char(string='Repository Path', required=True)
    
    @api.model
    def create(self, vals):
        repo = super(GitRepository, self).create(vals)
        if not os.path.exists(repo.path):
            os.makedirs(repo.path)
            git.Repo.init(repo.path)
        return repo

    def commit_changes(self, message):
        repo = git.Repo(self.path)
        repo.git.add(A=True)
        commit = repo.index.commit(message)
        
        self.env['nostr.event'].create_git_event(self.path, commit.hexsha)
        
        return commit.hexsha
=== ./integrated_ivcs/models/__init__.py ===
from . import ivcs_item
from . import ivcs_version
from . import ivcs_commit
from . import git_repository
from . import nostr_event
from . import branch_manager
from . import res_config_settings
=== ./integrated_ivcs/models/ivcs_version.py ===
from odoo import models, fields, api

class IVCSVersion(models.Model):
    _name = 'ivcs.version'
    _description = 'IVCS Version'

    name = fields.Char(string='Version Name', required=True)
    description = fields.Text(string='Description')
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    commit_id = fields.Many2one('ivcs.commit', string='Associated Commit')
    create_date = fields.Datetime(string='Created On', readonly=True, default=fields.Datetime.now)

    @api.model
    def create(self, vals):
        version = super(IVCSVersion, self).create(vals)
        if not version.item_id.current_version_id:
            version.item_id.current_version_id = version.id
        return version

    def name_get(self):
        result = []
        for version in self:
            name = f"{version.item_id.name} - {version.name}"
            result.append((version.id, name))
        return result
=== ./integrated_ivcs/models/nostr_event.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging
import time
import git

_logger = logging.getLogger(__name__)

class NostrEvent(models.Model):
    _name = 'nostr.event'
    _description = 'Nostr Event'

    event_id = fields.Char(string='Event ID', required=True)
    kind = fields.Integer(string='Event Kind', required=True)
    content = fields.Text(string='Content', required=True)
    tags = fields.Text(string='Tags')
    public_key = fields.Char(string='Public Key')
    created_at = fields.Integer(string='Created At', required=True)
    signature = fields.Char(string='Signature', required=True)
    published = fields.Boolean(string='Published', default=False)
    name = fields.Char(string='Name')
    event_type = fields.Selection([
        ('repo_anchor', 'Repository Anchor'),
        ('branch', 'Branch'),
        ('commit', 'Commit'),
        ('tree', 'Tree'),
        ('blob', 'Blob'),
    ], string='Event Type')

    def create_and_publish(self, event):
        vals = {
            'event_id': event.id,
            'kind': event.kind,
            'content': event.content,
            'tags': json.dumps(event.tags),
            'public_key': event.public_key,
            'created_at': event.created_at,
            'signature': event.signature,
        }
        nostr_event = self.create(vals)
        nostr_event.publish_event()
        return nostr_event

    def publish_event(self):
        self.ensure_one()
        relay_urls = self.env['ir.config_parameter'].sudo().get_param('integrated_ivcs.relay_urls', '').split(',')
        
        event_data = {
            'id': self.event_id,
            'kind': self.kind,
            'created_at': self.created_at,
            'tags': json.loads(self.tags),
            'content': self.content,
            'pubkey': self.public_key,
            'sig': self.signature,
        }

        for url in relay_urls:
            try:
                # Here you would typically use a Nostr client library to publish the event
                # For simplicity, we'll just log the action
                _logger.info(f"Publishing event {self.event_id} to relay: {url}")
                # Example: nostr_client.publish_event(url, event_data)
                self.published = True
            except Exception as e:
                _logger.error(f"Failed to publish event to {url}: {str(e)}")

    @api.model
    def create_git_event(self, repo_path, commit_hash):
        repo = git.Repo(repo_path)
        commit = repo.commit(commit_hash)
        
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit_hash,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", commit_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_tree_event(self, repo_path, tree_hash):
        repo = git.Repo(repo_path)
        tree = repo.tree(tree_hash)
        
        content = json.dumps({
            "action": "tree",
            "hash": tree_hash,
            "items": [{"mode": item.mode, "type": item.type, "hash": item.hexsha, "path": item.path} for item in tree.traverse()],
        })
        
        event = Event(
            kind=3122,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", tree_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def create_blob_event(self, repo_path, blob_hash):
        repo = git.Repo(repo_path)
        blob = repo.blob(blob_hash)
        
        content = json.dumps({
            "action": "blob",
            "hash": blob_hash,
            "size": blob.size,
            "data": blob.data_stream.read().decode('utf-8', errors='replace'),
        })
        
        event = Event(
            kind=3123,
            content=content,
            tags=[
                ["r", repo_path],
                ["h", blob_hash],
            ],
            public_key=self.env.user.nostr_public_key,
        )
        
        private_key = PrivateKey(bytes.fromhex(self.env.user.nostr_private_key))
        private_key.sign_event(event)
        
        return self.create_and_publish(event)

    @api.model
    def reconstruct_git_objects(self, repo_path):
        repo = git.Repo(repo_path)
        events = self.search([('tags', 'ilike', repo_path)])
        
        for event in events:
            content = json.loads(event.content)
            if event.kind == 3121:  # Commit
                self._reconstruct_commit(repo, content)
            elif event.kind == 3122:  # Tree
                self._reconstruct_tree(repo, content)
            elif event.kind == 3123:  # Blob
                self._reconstruct_blob(repo, content)

    def _reconstruct_commit(self, repo, content):
        commit_hash = content['hash']
        if commit_hash not in repo.objects:
            repo.create_commit(
                tree=repo.tree(content['tree_hash']),
                message=content['message'],
                author=git.Actor(content['author'], content['email']),
                committer=git.Actor(content['author'], content['email']),
                parent_commits=[repo.commit(p) for p in content['parent_hashes']],
                commit_timestamp=int(content['date']),
                ref=f'refs/heads/{content["branch"]}' if 'branch' in content else None
            )

    def _reconstruct_tree(self, repo, content):
        tree_hash = content['hash']
        if tree_hash not in repo.objects:
            tree_items = []
            for item in content['items']:
                if item['type'] == 'blob':
                    tree_items.append((item['mode'], 'blob', item['hash'], item['path']))
                elif item['type'] == 'tree':
                    tree_items.append((item['mode'], 'tree', item['hash'], item['path']))
            repo.create_tree(tree_items)

    def _reconstruct_blob(self, repo, content):
        blob_hash = content['hash']
        if blob_hash not in repo.objects:
            repo.create_blob(content['data'].encode('utf-8'))

    def sync_git_nostr(self, repo_path):
        repo = git.Repo(repo_path)
        for obj in repo.objects:
            if isinstance(obj, git.Commit):
                self.create_git_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Tree):
                self.create_tree_event(repo_path, obj.hexsha)
            elif isinstance(obj, git.Blob):
                self.create_blob_event(repo_path, obj.hexsha)

        self.reconstruct_git_objects(repo_path)
=== ./integrated_ivcs/models/res_config_settings.py ===
from odoo import fields, models

class ResConfigSettings(models.TransientModel):
    _inherit = 'res.config.settings'

    integrated_ivcs_relay_urls = fields.Char(string="Nostr Relay URLs", config_parameter='integrated_ivcs.relay_urls')
=== ./integrated_ivcs/models/ivcs_commit.py ===
from odoo import models, fields, api
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class IVCSCommit(models.Model):
    _name = 'ivcs.commit'
    _description = 'IVCS Commit'

    hash = fields.Char(string='Commit Hash', required=True)
    message = fields.Text(string='Commit Message', required=True)
    author = fields.Char(string='Author', required=True, default=lambda self: self.env.user.name)
    date = fields.Datetime(string='Commit Date', required=True, default=fields.Datetime.now)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True, ondelete='cascade')
    version_id = fields.Many2one('ivcs.version', string='Associated Version')

    @api.model
    def create(self, vals):
        commit = super(IVCSCommit, self).create(vals)
        try:
            commit._create_nostr_commit_event()
        except Exception as e:
            _logger.error(f"Failed to create Nostr commit event: {str(e)}")
        return commit

    def _create_nostr_commit_event(self):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key set for IVCS Item {self.item_id.name}")
            return

        try:
            private_key = PrivateKey.from_nsec(self.item_id.nostr_private_key)
        except Exception as e:
            _logger.error(f"Invalid Nostr private key for IVCS Item {self.item_id.name}: {str(e)}")
            return

        event = Event(
            kind=3121,
            content=json.dumps({
                "hash": self.hash,
                "message": self.message,
                "author": self.author,
                "date": self.date.isoformat(),
            }),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        try:
            self.env['nostr.event'].create_and_publish(event)
            _logger.info(f"Nostr commit event created and published for commit {self.hash}")
        except Exception as e:
            _logger.error(f"Failed to create and publish Nostr event for commit {self.hash}: {str(e)}")
=== ./integrated_ivcs/models/ivcs_item.py ===
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
import os
import logging

_logger = logging.getLogger(__name__)

class IVCSItem(models.Model):
    _name = 'ivcs.item'
    _description = 'IVCS Item'

    name = fields.Char(string='Name', required=True)
    description = fields.Text('Description')
    current_version_id = fields.Many2one('ivcs.version', string='Current Version', compute='_compute_current_version', store=True)
    version_ids = fields.One2many('ivcs.version', 'item_id', string='Versions')
    repo_path = fields.Char('Repository Path', compute='_compute_repo_path', store=True)
    current_branch = fields.Char('Current Branch', default='main')
    commit_ids = fields.One2many('ivcs.commit', 'item_id', string='Commits')
    nostr_private_key = fields.Char(string="Nostr Private Key")
    branch_manager_id = fields.Many2one('ivcs.branch.manager', string='Branch Manager')

    @api.depends('name')
    def _compute_repo_path(self):
        for item in self:
            item.repo_path = f"/opt/ivcs_repos/item_{item.id}"

    @api.depends('version_ids')
    def _compute_current_version(self):
        for item in self:
            if item.version_ids:
                item.current_version_id = item.version_ids.sorted(lambda v: v.create_date, reverse=True)[0]
            else:
                item.current_version_id = False

    @api.model
    def create(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).create(vals)

    def write(self, vals):
        if 'nostr_private_key' in vals and vals['nostr_private_key']:
            try:
                # Validate and format the private key
                private_key = PrivateKey.from_nsec(vals['nostr_private_key'])
                vals['nostr_private_key'] = private_key.hex()  # Store the private key as a hex string
            except Exception as e:
                raise UserError(_("Invalid Nostr private key: %s") % str(e))
        return super(IVCSItem, self).write(vals)

    def _initialize_repository(self):
        self.ensure_one()
        if not os.path.exists(self.repo_path):
            os.makedirs(self.repo_path)
            repo = git.Repo.init(self.repo_path)
            readme_path = os.path.join(self.repo_path, 'README.md')
            with open(readme_path, 'w') as f:
                f.write(f"# {self.name}\n\n{self.description}")
            repo.index.add(['README.md'])
            commit = repo.index.commit("Initial commit")
            self._create_initial_version(commit.hexsha)
            self._create_nostr_repo_event()

    def _create_initial_version(self, commit_hash):
        version = self.env['ivcs.version'].create({
            'name': 'v1.0',
            'description': 'Initial version',
            'item_id': self.id,
        })
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': "Initial commit",
            'item_id': self.id,
            'version_id': version.id,
        })

    def _create_nostr_repo_event(self):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
    
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31228,
            content=json.dumps({
                "action": "create_repository",
                "repo_name": self.name,
                "description": self.description
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = git.Repo(self.repo_path)
        if not self.branch_manager_id:
            self.branch_manager_id = self.env['ivcs.branch.manager'].create({
                'name': f"Branch Manager for {self.name}",
                'item_id': self.id,
            })
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self.current_branch = branch_name
            self._create_nostr_branch_event(branch_name)
            if self.branch_manager_id:
                self.branch_manager_id.create_branch(branch_name)
            return self._return_success('Branch Created', f'Branch {branch_name} has been created.')
        else:
            return self._return_warning('Branch Exists', f'Branch {branch_name} already exists.')

    def _create_nostr_branch_event(self, branch_name):
        if not self.nostr_private_key:
            raise UserError(_("Nostr private key is not set for this item."))
        
        private_key = PrivateKey(bytes.fromhex(self.nostr_private_key))
        event = Event(
            kind=31227,
            content=json.dumps({
                "action": "create_branch",
                "branch_name": branch_name,
                "repo_name": self.name
            }),
            tags=[['r', self.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def _return_success(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'success',
            }
        }

    def _return_warning(self, title, message):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _(title),
                'message': _(message),
                'type': 'warning',
            }
        }

    def delete_branch(self, branch_name):
        self.ensure_one()
        if self.branch_manager_id.delete_branch(branch_name):
            return self._return_success('Branch Deleted', f'Branch {branch_name} has been deleted.')
        else:
            return self._return_warning('Branch Not Found', f'Branch {branch_name} does not exist.')

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        if self.branch_manager_id.merge_branches(source_branch, target_branch):
            return self._return_success('Branches Merged', f'Branch {source_branch} has been merged into {target_branch}.')
        else:
            return self._return_warning('Merge Failed', f'Failed to merge {source_branch} into {target_branch}.')

    def reconstruct_branches(self):
        self.ensure_one()
        branches = self.branch_manager_id.reconstruct_branches_from_events()
        return self._return_success('Branches Reconstructed', f'Reconstructed {len(branches)} branches from Nostr events.')

    # Add other methods as needed (e.g., commit, push, pull, etc.)
=== ./integrated_ivcs/models/branch_manager.py ===
from odoo import models, fields, api
from git import Repo, GitCommandError
import json
from nostr.event import Event
from nostr.key import PrivateKey
import logging

_logger = logging.getLogger(__name__)

class BranchManager(models.Model):
    _name = 'ivcs.branch.manager'
    _description = 'IVCS Branch Manager'

    name = fields.Char(string='Name', required=True)
    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)

    def create_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name not in repo.heads:
            repo.create_head(branch_name)
            self._create_branch_event(branch_name, 'create')
            return True
        return False

    def delete_branch(self, branch_name):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            repo.delete_head(branch_name, force=True)
            self._create_branch_event(branch_name, 'delete')
            return True
        return False

    def update_branch(self, branch_name, new_commit):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if branch_name in repo.heads:
            branch = repo.heads[branch_name]
            branch.set_commit(new_commit)
            self._create_branch_event(branch_name, 'update', new_commit)
            return True
        return False

    def merge_branches(self, source_branch, target_branch):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        if source_branch in repo.heads and target_branch in repo.heads:
            try:
                repo.git.checkout(target_branch)
                repo.git.merge(source_branch)
                self._create_branch_event(target_branch, 'merge', source_branch)
                return True
            except GitCommandError as e:
                _logger.error(f"Merge conflict: {str(e)}")
                repo.git.merge('--abort')
                return False
        return False

    def _create_branch_event(self, branch_name, action, additional_info=None):
        if not self.item_id.nostr_private_key:
            _logger.warning(f"No Nostr private key for item {self.item_id.name}")
            return

        private_key = PrivateKey(bytes.fromhex(self.item_id.nostr_private_key))
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": self.item_id.name
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.item_id.repo_path]],
            public_key=private_key.public_key.hex()
        )
        private_key.sign_event(event)
        
        self.env['nostr.event'].create_and_publish(event)

    def list_branches(self):
        self.ensure_one()
        repo = Repo(self.item_id.repo_path)
        return [head.name for head in repo.heads]

    def reconstruct_branches_from_events(self):
        self.ensure_one()
        events = self.env['nostr.event'].search([
            ('kind', '=', 31227),
            ('tags', 'ilike', self.item_id.repo_path)
        ], order='created_at asc')

        branches = {}
        for event in events:
            content = json.loads(event.content)
            action = content.get('action')
            branch_name = content.get('branch_name')

            if action == 'create':
                branches[branch_name] = {'created_at': event.created_at}
            elif action == 'delete':
                branches.pop(branch_name, None)
            elif action == 'update':
                if branch_name in branches:
                    branches[branch_name]['last_updated'] = event.created_at
            elif action == 'merge':
                if branch_name in branches:
                    branches[branch_name]['last_merged'] = event.created_at
                    branches[branch_name]['merged_from'] = content.get('additional_info')

        return branches
=== ./integrated_ivcs/__init__.py ===
from . import models
from . import wizards
=== ./integrated_ivcs/wizards/create_commit_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_commit_wizard_form" model="ir.ui.view">
        <field name="name">create.commit.wizard.form</field>
        <field name="model">create.commit.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Commit">
                <group>
                    <field name="item_id"/>
                    <field name="message"/>
                </group>
                <footer>
                    <button name="action_create_commit" string="Create Commit" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_commit_wizard" model="ir.actions.act_window">
        <field name="name">Create Commit</field>
        <field name="res_model">create.commit.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./integrated_ivcs/wizards/__init__.py ===
from . import create_branch_wizard
from . import create_commit_wizard
=== ./integrated_ivcs/wizards/create_commit_wizard.py ===
from odoo import models, fields, api

class CreateCommitWizard(models.TransientModel):
    _name = 'create.commit.wizard'
    _description = 'Create Commit Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    message = fields.Text(string='Commit Message', required=True)

    def action_create_commit(self):
        self.ensure_one()
        repo = self.env['git.repository'].search([('path', '=', self.item_id.repo_path)])
        commit_hash = repo.commit_changes(self.message)
        self.env['ivcs.commit'].create({
            'hash': commit_hash,
            'message': self.message,
            'author': self.env.user.name,
            'date': fields.Datetime.now(),
            'item_id': self.item_id.id,
        })
        return {'type': 'ir.actions.act_window_close'}
=== ./integrated_ivcs/wizards/create_branch_wizard.py ===
from odoo import models, fields, api

class CreateBranchWizard(models.TransientModel):
    _name = 'create.branch.wizard'
    _description = 'Create Branch Wizard'

    item_id = fields.Many2one('ivcs.item', string='IVCS Item', required=True)
    branch_name = fields.Char(string='Branch Name', required=True)

    def action_create_branch(self):
        self.ensure_one()
        return self.item_id.create_branch(self.branch_name)
=== ./integrated_ivcs/wizards/create_branch_wizard_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_create_branch_wizard_form" model="ir.ui.view">
        <field name="name">create.branch.wizard.form</field>
        <field name="model">create.branch.wizard</field>
        <field name="arch" type="xml">
            <form string="Create Branch">
                <group>
                    <field name="item_id"/>
                    <field name="branch_name"/>
                </group>
                <footer>
                    <button name="action_create_branch" string="Create Branch" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_create_branch_wizard" model="ir.actions.act_window">
        <field name="name">Create Branch</field>
        <field name="res_model">create.branch.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>
</odoo>
=== ./integrated_ivcs/cli.py ===
import argparse
import os
import git
from nostr.event import Event
from nostr.key import PrivateKey
import json
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GitNostrCLI:
    def __init__(self, repo_path):
        self.repo_path = repo_path
        self.repo = git.Repo(repo_path)
        self.private_key = PrivateKey()

    def create_branch(self, branch_name):
        logger.info(f"Creating branch: {branch_name}")
        self.repo.create_head(branch_name)
        self._create_branch_event(branch_name, 'create')
        logger.info(f"Branch {branch_name} created successfully")

    def delete_branch(self, branch_name):
        logger.info(f"Deleting branch: {branch_name}")
        self.repo.delete_head(branch_name, force=True)
        self._create_branch_event(branch_name, 'delete')
        logger.info(f"Branch {branch_name} deleted successfully")

    def merge_branches(self, source_branch, target_branch):
        logger.info(f"Merging {source_branch} into {target_branch}")
        self.repo.git.checkout(target_branch)
        try:
            self.repo.git.merge(source_branch)
            self._create_branch_event(target_branch, 'merge', source_branch)
            logger.info(f"Merged {source_branch} into {target_branch} successfully")
        except git.GitCommandError as e:
            logger.error(f"Merge conflict: {str(e)}")
            self.repo.git.merge('--abort')
            logger.info("Merge aborted due to conflicts")

    def commit_changes(self, message):
        logger.info(f"Committing changes with message: {message}")
        self.repo.git.add(A=True)
        commit = self.repo.index.commit(message)
        self._create_commit_event(commit)
        logger.info(f"Changes committed successfully. Commit hash: {commit.hexsha}")

    def _create_branch_event(self, branch_name, action, additional_info=None):
        logger.info(f"Creating Nostr event for branch action: {action}")
        content = {
            "action": action,
            "branch_name": branch_name,
            "repo_name": os.path.basename(self.repo_path)
        }
        if additional_info:
            content["additional_info"] = additional_info

        event = Event(
            kind=31227,
            content=json.dumps(content),
            tags=[['r', self.repo_path]],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

    def _create_commit_event(self, commit):
        logger.info(f"Creating Nostr event for commit: {commit.hexsha}")
        content = json.dumps({
            "action": "commit",
            "message": commit.message,
            "author": commit.author.name,
            "email": commit.author.email,
            "date": commit.authored_datetime.isoformat(),
            "hash": commit.hexsha,
            "parent_hashes": [c.hexsha for c in commit.parents],
            "tree_hash": commit.tree.hexsha,
        })
        
        event = Event(
            kind=3121,
            content=content,
            tags=[
                ["r", self.repo_path],
                ["h", commit.hexsha],
            ],
            public_key=self.private_key.public_key.hex()
        )
        self.private_key.sign_event(event)
        logger.info(f"Nostr event created: {event.id}")
        # Here you would typically publish the event to Nostr relays

def main():
    parser = argparse.ArgumentParser(description="Git-Nostr CLI")
    parser.add_argument('repo_path', help="Path to the Git repository")
    parser.add_argument('action', choices=['create-branch', 'delete-branch', 'merge-branches', 'commit'])
    parser.add_argument('--branch-name', help="Name of the branch (for create-branch and delete-branch)")
    parser.add_argument('--source-branch', help="Source branch for merge")
    parser.add_argument('--target-branch', help="Target branch for merge")
    parser.add_argument('--commit-message', help="Commit message")

    args = parser.parse_args()

    cli = GitNostrCLI(args.repo_path)

    if args.action == 'create-branch':
        cli.create_branch(args.branch_name)
    elif args.action == 'delete-branch':
        cli.delete_branch(args.branch_name)
    elif args.action == 'merge-branches':
        cli.merge_branches(args.source_branch, args.target_branch)
    elif args.action == 'commit':
        cli.commit_changes(args.commit_message)

if __name__ == "__main__":
    main()
=== ./integrated_ivcs/__manifest__.py ===
{
    'name': 'Integrated IVCS',
    'version': '1.0',
    'category': 'Development',
    'summary': 'Integrated Version Control System with Git and Nostr',
    'author': 'Your Name',
    'website': 'https://www.example.com',
    'depends': ['base', 'mail'],
    'data': [
        'security/ir.model.access.csv',
        'views/ivcs_item_views.xml',
        'views/ivcs_version_views.xml',
        'views/ivcs_commit_views.xml',
        'views/git_repository_views.xml',
        'views/nostr_event_views.xml',
        'views/res_config_settings_views.xml',
        'wizards/create_branch_wizard_views.xml',
        'wizards/create_commit_wizard_views.xml',
    ],
    'external_dependencies': {
        'python': ['git', 'nostr'],
    },
    'installable': True,
    'application': True,
    'auto_install': False,
}
=== ./integrated_ivcs/security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_ivcs_item_user,ivcs.item user,model_ivcs_item,base.group_user,1,1,1,1
access_ivcs_version_user,ivcs.version user,model_ivcs_version,base.group_user,1,1,1,1
access_ivcs_commit_user,ivcs.commit user,model_ivcs_commit,base.group_user,1,1,1,1
access_git_repository_user,git.repository user,model_git_repository,base.group_user,1,1,1,1
access_nostr_event_user,nostr.event user,model_nostr_event,base.group_user,1,1,1,1
access_ivcs_branch_manager_user,ivcs.branch.manager user,model_ivcs_branch_manager,base.group_user,1,1,1,1
access_create_branch_wizard_user,create.branch.wizard user,model_create_branch_wizard,base.group_user,1,1,1,0
access_create_commit_wizard_user,create.commit.wizard user,model_create_commit_wizard,base.group_user,1,1,1,0
=== ./integrated_ivcs/tests/test_git_nostr_integration.py ===
import unittest
import tempfile
import os
import git
import json
from nostr.event import Event
from nostr.key import PrivateKey
from odoo.tests.common import TransactionCase
from odoo.exceptions import UserError

class TestGitNostrIntegration(TransactionCase):

    def setUp(self):
        super(TestGitNostrIntegration, self).setUp()
        self.IVCSItem = self.env['ivcs.item']
        self.NostrEvent = self.env['nostr.event']
        self.temp_dir = tempfile.mkdtemp()
        self.repo_path = os.path.join(self.temp_dir, 'test_repo')

    def tearDown(self):
        super(TestGitNostrIntegration, self).tearDown()
        if os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

    def test_create_repository(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        self.assertTrue(os.path.exists(self.repo_path))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, '.git')))
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'README.md')))

    def test_create_branch(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        result = item.create_branch('test-branch')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        repo = git.Repo(self.repo_path)
        self.assertIn('test-branch', repo.heads)

    def test_merge_branches(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        item.create_branch('branch1')
        item.create_branch('branch2')
        repo = git.Repo(self.repo_path)
        repo.heads.branch1.checkout()
        with open(os.path.join(self.repo_path, 'file1.txt'), 'w') as f:
            f.write('Content in branch1')
        repo.index.add(['file1.txt'])
        repo.index.commit('Commit in branch1')
        
        result = item.merge_branches('branch1', 'branch2')
        self.assertEqual(result['type'], 'ir.actions.client')
        self.assertEqual(result['params']['type'], 'success')
        
        repo.heads.branch2.checkout()
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'file1.txt')))

    def test_create_nostr_events(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        event = self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        self.assertEqual(event.kind, 3121)
        self.assertIn(commit.hexsha, event.content)

    def test_reconstruct_git_objects(self):
        item = self.IVCSItem.create({
            'name': 'Test Repo',
            'description': 'Test repository',
            'repo_path': self.repo_path,
        })
        repo = git.Repo(self.repo_path)
        with open(os.path.join(self.repo_path, 'test.txt'), 'w') as f:
            f.write('Test content')
        repo.index.add(['test.txt'])
        commit = repo.index.commit('Test commit')
        
        self.NostrEvent.create_git_event(self.repo_path, commit.hexsha)
        
        # Delete the .git directory to simulate a fresh repository
        import shutil
        shutil.rmtree(os.path.join(self.repo_path, '.git'))
        
        # Reconstruct the repository from Nostr events
        self.NostrEvent.reconstruct_git_objects(self.repo_path)
        
        reconstructed_repo = git.Repo(self.repo_path)
        self.assertIn(commit.hexsha, reconstructed_repo.heads.master.commit.hexsha)
        self.assertTrue(os.path.exists(os.path.join(self.repo_path, 'test.txt')))

if __name__ == '__main__':
    unittest.main()
=== ./integrated_ivcs/views/res_config_settings_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.integrated_ivcs</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[hasclass('settings')]" position="inside">
                <div class="app_settings_block" data-string="Integrated IVCS" string="Integrated IVCS" data-key="integrated_ivcs">
                    <h2>Nostr Settings</h2>
                    <div class="row mt16 o_settings_container">
                        <div class="col-12 col-lg-6 o_setting_box">
                            <div class="o_setting_left_pane"/>
                            <div class="o_setting_right_pane">
                                <span class="o_form_label">Nostr Relay URLs</span>
                                <div class="text-muted">
                                    Comma-separated list of Nostr relay URLs
                                </div>
                                <div class="content-group">
                                    <field name="integrated_ivcs_relay_urls"/>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </xpath>
        </field>
    </record>
</odoo>
=== ./integrated_ivcs/views/ivcs_version_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_version_form" model="ir.ui.view">
        <field name="name">ivcs.version.form</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="item_id"/>
                        <field name="commit_id"/>
                        <field name="create_date"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_version_tree" model="ir.ui.view">
        <field name="name">ivcs.version.tree</field>
        <field name="model">ivcs.version</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="item_id"/>
                <field name="create_date"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_version" model="ir.actions.act_window">
        <field name="name">IVCS Versions</field>
        <field name="res_model">ivcs.version</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_version" name="Versions" parent="menu_ivcs_root" action="action_ivcs_version"/>
</odoo>
=== ./integrated_ivcs/views/nostr_event_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_nostr_event_form" model="ir.ui.view">
        <field name="name">nostr.event.form</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="event_id"/>
                        <field name="kind"/>
                        <field name="event_type"/>
                        <field name="content"/>
                        <field name="tags"/>
                        <field name="public_key"/>
                        <field name="created_at"/>
                        <field name="signature"/>
                        <field name="published"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_nostr_event_tree" model="ir.ui.view">
        <field name="name">nostr.event.tree</field>
        <field name="model">nostr.event</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="event_id"/>
                <field name="kind"/>
                <field name="event_type"/>
                <field name="public_key"/>
                <field name="created_at"/>
                <field name="published"/>
            </tree>
        </field>
    </record>

    <record id="action_nostr_event" model="ir.actions.act_window">
        <field name="name">Nostr Events</field>
        <field name="res_model">nostr.event</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_nostr_event" name="Nostr Events" parent="menu_ivcs_root" action="action_nostr_event"/>
</odoo>
=== ./integrated_ivcs/views/ivcs_item_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_item_form" model="ir.ui.view">
        <field name="name">ivcs.item.form</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="description"/>
                        <field name="repo_path"/>
                        <field name="current_branch"/>
                        <field name="current_version_id"/>
                        <field name="nostr_private_key" password="True"/>
                    </group>
                    <notebook>
                        <page string="Versions">
                            <field name="version_ids"/>
                        </page>
                        <page string="Commits">
                            <field name="commit_ids"/>
                        </page>
                    </notebook>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_item_tree" model="ir.ui.view">
        <field name="name">ivcs.item.tree</field>
        <field name="model">ivcs.item</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="repo_path"/>
                <field name="current_branch"/>
                <field name="current_version_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_item" model="ir.actions.act_window">
        <field name="name">IVCS Items</field>
        <field name="res_model">ivcs.item</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_root" name="Integrated IVCS"/>
    <menuitem id="menu_ivcs_item" name="IVCS Items" parent="menu_ivcs_root" action="action_ivcs_item"/>
</odoo>
=== ./integrated_ivcs/views/git_repository_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_git_repository_form" model="ir.ui.view">
        <field name="name">git.repository.form</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="path"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_git_repository_tree" model="ir.ui.view">
        <field name="name">git.repository.tree</field>
        <field name="model">git.repository</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name"/>
                <field name="path"/>
            </tree>
        </field>
    </record>

    <record id="action_git_repository" model="ir.actions.act_window">
        <field name="name">Git Repositories</field>
        <field name="res_model">git.repository</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_git_repository" name="Git Repositories" parent="menu_ivcs_root" action="action_git_repository"/>
</odoo>
=== ./integrated_ivcs/views/ivcs_commit_views.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ivcs_commit_form" model="ir.ui.view">
        <field name="name">ivcs.commit.form</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <field name="hash"/>
                        <field name="message"/>
                        <field name="author"/>
                        <field name="date"/>
                        <field name="item_id"/>
                        <field name="version_id"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_ivcs_commit_tree" model="ir.ui.view">
        <field name="name">ivcs.commit.tree</field>
        <field name="model">ivcs.commit</field>
        <field name="arch" type="xml">
            <tree>
                <field name="hash"/>
                <field name="message"/>
                <field name="author"/>
                <field name="date"/>
                <field name="item_id"/>
            </tree>
        </field>
    </record>

    <record id="action_ivcs_commit" model="ir.actions.act_window">
        <field name="name">IVCS Commits</field>
        <field name="res_model">ivcs.commit</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_ivcs_commit" name="Commits" parent="menu_ivcs_root" action="action_ivcs_commit"/>
</odoo>
