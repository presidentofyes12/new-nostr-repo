=== ./thread-chat-view/index.tsx ===
import React, {useRef} from 'react';
import {useAtom} from 'jotai';
import Divider from '@mui/material/Divider';
import {darken, lighten} from '@mui/material';
import Box from '@mui/material/Box';
import {useTheme} from '@mui/material/styles';
import IconButton from '@mui/material/IconButton';

import MessageView from 'views/components/message-view';
import ChatInput from 'views/components/chat-input';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import useTranslation from 'hooks/use-translation';
import useStyles from 'hooks/use-styles';
import {threadRootAtom} from 'atoms';
import Close from 'svg/close';


const ThreadChatView = (props: { senderFn: (message: string, mentions: string[]) => Promise<any> }) => {
    const {isMd} = useMediaBreakPoint();
    const theme = useTheme();
    const styles = useStyles();
    const [t] = useTranslation();
    const [threadRoot, setThreadRoot] = useAtom(threadRootAtom);
    const ref = useRef<HTMLDivElement | null>(null);

    if (!threadRoot) return null;

    const scrollToBottom = () => {
        ref.current!.scroll({top: ref.current!.scrollHeight, behavior: 'auto'});
    }

    return <Box sx={{
        width: isMd ? `calc((100% - ${styles.sideBarWidth}) / 2)` : '100%',
        ...(() => isMd ? {} : {
            position: 'absolute',
            left: '0',
            top: '0',
            zIndex: 10
        })(),
        height: '100%',
        flexGrow: 0,
        flexShrink: 0,
        background: lighten(theme.palette.background.default, .03),
        display: 'flex',
        flexDirection: 'column'
    }}>
        <Box sx={{
            flexGrow: 0,
            flexShrink: 0,
        }}>
            <Box sx={{
                height: styles.headerHeight,
                display: 'flex',
                justifyContent: 'space-between',
                borderBottom: `1px solid ${theme.palette.divider}`,
                alignItems: 'center',
                p: '0 20px'
            }}>
                <Box sx={{fontFamily: 'Faktum, sans-serif'}}>
                    {t('Thread')}
                </Box>
                <IconButton onClick={() => {
                    setThreadRoot(null)
                }}><Close height={20}/></IconButton>
            </Box>
            <MessageView message={threadRoot} dateFormat='fromNow' compactView={false} inThreadView/>
            {(threadRoot.children && threadRoot.children.length > 0) && (<Divider textAlign="left" sx={{
                fontSize: '0.7em',
                color: darken(theme.palette.text.secondary, 0.4),
                m: '6px 0'
            }}>{t('{{n}} replies', {n: threadRoot.children.length})}</Divider>)}
        </Box>
        <Box ref={ref} sx={{
            flexGrow: 1,
            ...styles.scrollY,
        }}>
            {threadRoot.children?.map(msg => {
                return <MessageView key={msg.id} message={msg} dateFormat='fromNow' compactView={false} inThreadView/>
            })}
        </Box>
        <ChatInput separator={threadRoot.id} senderFn={(message: string, mentions: string[]) => {
            return props.senderFn(message, mentions).then(() => {
                setTimeout(() => {
                    scrollToBottom();
                }, 500);
            });
        }}/>
    </Box>
}


export default ThreadChatView;
=== ./avatar/index.tsx ===
import React, { useMemo } from 'react';
import Box from '@mui/material/Box';
import { useTheme } from '@mui/material/styles';
import QRCode from 'qrcode.react';
import { nip19 } from 'nostr-tools';

interface AvatarProps {
  src?: string;
  seed: string;
  size: number;
  rounded?: boolean;
}

const Avatar: React.FC<AvatarProps> = ({ src, seed, size, rounded }) => {
  const theme = useTheme();

  const avatar = useMemo(() => {
    if (src && src.startsWith('https://')) {
      return src;
    }
    return null;
  }, [src]);

  return (
    <Box
      sx={{
        background: theme.palette.divider,
        borderRadius: rounded ? '50%' : theme.shape.borderRadius,
        width: `${size}px`,
        height: `${size}px`,
        objectFit: 'cover',
      }}
    >
      {avatar ? (
        <img
          src={avatar}
          style={{
            width: '100%',
            height: '100%',
            borderRadius: rounded ? '50%' : theme.shape.borderRadius,
            objectFit: 'cover',
          }}
          alt="Avatar"
        />
      ) : (
        <QRCode
          value={nip19.npubEncode(seed)}
          size={size}
          includeMargin={false}
          renderAs="svg"
          style={{
            width: '100%',
            height: '100%',
            borderRadius: rounded ? '50%' : theme.shape.borderRadius,
          }}
        />
      )}
    </Box>
  );
};

export default Avatar;=== ./login/index.tsx ===
import React, { useState, useEffect } from 'react';
import { useAtom } from 'jotai';
import { useTranslation } from 'react-i18next';
import { Box, Button, Divider, CircularProgress, Modal, Typography, Checkbox, TextField } from '@mui/material';
import { CiWarning } from 'react-icons/ci';
import { IoMdClose } from 'react-icons/io';
import { nip06, getPublicKey, nip19 } from 'nostr-tools';
import { generateFirstGenKeys, deriveSecondGenKeys, generateCredentials } from 'hooks/keyDerivation';
import { keysAtom, profileAtom, backupWarnAtom, ravenAtom, ravenStatusAtom } from 'atoms';
import useModal from 'hooks/use-modal';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import LoginMetadataForm from 'views/components/metadata-form/loginForm';
import KeyDisplayDialog from 'views/components/KeyDisplayDialog';
import CredentialDisplayDialog from 'views/components/CredentialDisplayDialog';
import DownloadSeedWords from 'views/settings/DownloadSeedWords';
import Creation from 'svg/creation';
import Import from 'svg/import';
import { storeKeys, storeCredentials } from 'local-storage';
import { Keys } from 'types';
import ImportAccount from 'views/components/dialogs/import-account';
import { InstallNip07Dialog } from "views/components/dialogs/no-wallet/nip07";
import axios from 'axios';

import { getUserIP } from './ip';

const style = {
  position: 'absolute' as 'absolute',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)',
  width: '700px',
  maxWidth: '100%',
  bgcolor: 'background.paper',
  border: '2px solid #000',
  boxShadow: 24,
  p: 4,
};

const Login = (props: { onDone: () => void }) => {
  const { onDone } = props;
  const { isSm } = useMediaBreakPoint();
  const { t } = useTranslation();
  const [, showModal] = useModal();
  const [, setKeys] = useAtom(keysAtom);
  const [profile, setProfile] = useAtom(profileAtom);
  const [, setBackupWarn] = useAtom(backupWarnAtom);
  const [raven] = useAtom(ravenAtom);
  const [ravenStatus] = useAtom(ravenStatusAtom);
  const [step, setStep] = useState<0 | 1 | 2>(0);
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [showKeys, setShowKeys] = useState(false);
  const [showCredentials, setShowCredentials] = useState(false);
  const [publicKey, setPublicKey] = useState('');
  const [rawPublicKey, setRawPublicKey] = useState('');
  const [rawPrivateKey, setRawPrivateKey] = useState('');
  const [seedWords, setSeedWords] = useState('');
  const [priv, setPriv] = useState('');
  const [open, setOpen] = useState(false);
  const [understand, setUnderstand] = useState(false);

  const [emailDialogOpen, setEmailDialogOpen] = useState(false);
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');
  const [isCreatingAccount, setIsCreatingAccount] = useState(false);
  const [meshCommands, setMeshCommands] = useState('');
  
  useEffect(() => {
    if (step === 1 && ravenStatus.ready) setStep(2);
  }, [step, ravenStatus.ready]);

  useEffect(() => {
    if (profile) onDone();
  }, [profile]);

  const handleOpen = () => setOpen(true);
  const handleClose = () => setOpen(false);
  
  const [isStartingOdoo, setIsStartingOdoo] = useState(false);
  const [odooStarted, setOdooStarted] = useState(false);

  const createAccount = async () => {
    const { mnemonic, privateKey } = generateFirstGenKeys();
    console.log("Generated mnemonic:", mnemonic);
    console.log("Generated private key:", privateKey);

    if (!mnemonic || !privateKey) {
      console.error("Failed to generate keys");
      alert("Failed to generate account keys. Please try again.");
      return;
    }

    const pubKey = getPublicKey(privateKey);

    // Ensure cookies are set correctly
    document.cookie = `ssoUsername=${pubKey}; path=/; secure; samesite=strict`;
    document.cookie = `ssoPassword=${privateKey}; path=/; secure; samesite=strict`;

    setRawPublicKey(pubKey);
    setRawPrivateKey(privateKey);

    const secondGenKeys = deriveSecondGenKeys(privateKey);
    const { username, password } = generateCredentials(secondGenKeys.privateKey);

    setSeedWords(mnemonic);
    setPriv(privateKey);
    setUsername(username);
    setPassword(password);

    const userIP = await getUserIP();
    await storeCredentials(username, password, userIP);

    localStorage.setItem('seedWords', mnemonic);

    setShowKeys(true);
    setEmailDialogOpen(true);
  };

  const handleEmailSubmit = async () => {
    if (!email) {
      setEmailError('Email is required');
      return;
    }
    if (!/\S+@\S+\.\S+/.test(email)) {
      setEmailError('Invalid email format');
      return;
    }
    setEmailError('');
    
  const npubKey = nip19.npubEncode(rawPublicKey);
  const nsecKey = nip19.nsecEncode(rawPrivateKey);

  setIsCreatingAccount(true);
  try {
    // Start Odoo
    const response = await axios.post('http://localhost:5001/api/start-odoo', {
      publicKey: npubKey,
      privateKey: nsecKey,
      email
    });

    if (response.data.success) {
      console.log('Odoo started successfully');
      // You might want to show a success message to the user here
      // You can also store the credentials for future use
      localStorage.setItem('odooUsername', npubKey);
      localStorage.setItem('odooPassword', nsecKey);
    } else {
      console.error('Failed to start Odoo:', response.data.error);
      // You might want to show an error message to the user here
    }
  } catch (error) {
    console.error('Error starting Odoo:', error);
    // You might want to show an error message to the user here
  } finally {
    setIsCreatingAccount(false);
  }

  setEmailDialogOpen(false);
  setShowCredentials(true);
};

  const importAccount = () => {
    showModal({
      body: (
        <ImportAccount
          onSuccess={(key, type) => {
            showModal(null);
            if (type === 'priv') {
              loginPriv(key);
            } else if (type === 'pub') {
              proceed({ priv: 'none', pub: key });
            }
          }}
        />
      ),
    });
  };

  const loginNip07 = async () => {
    if (!window.nostr) {
      showModal({
        body: <InstallNip07Dialog />,
      });
      return;
    }

    const pub = await window.nostr.getPublicKey();
    if (pub) proceed({ priv: 'nip07', pub });
  };

  const loginPriv = (priv: string) => {
    try {
      const pub = getPublicKey(priv);
      proceed({ priv, pub });
    } catch (error) {
      console.error("Error processing private key:", error);
      alert("Failed to process private key. Please try creating the account again.");
    }
  };

  const proceed = (keys: Keys) => {
    storeKeys(keys).then(() => {
      setKeys(keys);
      setProfile(null);
      if (keys?.priv === 'none') {
        onDone();
        return;
      }
      setStep(1);
    });
  };

  const continueCreateAccount = (priv: string | null) => {
    if (!priv) {
      console.error("Private key is null");
      alert("Invalid private key. Please try creating the account again.");
      return;
    }
    handleClose();
    loginPriv(priv);
    setBackupWarn(true);
  };

  const handleKeyDialogClose = () => {
    setShowKeys(false);
    setShowCredentials(true);
  };


  const startOdoo = async () => {
    setIsStartingOdoo(true);
    try {
      const response = await axios.post('http://localhost:5001/api/start-odoo', {
        publicKey: nip19.npubEncode(rawPublicKey),
        privateKey: nip19.nsecEncode(rawPrivateKey)
      });

      if (response.data.success) {
        console.log('Odoo started successfully');
        setOdooStarted(true);
        // You might want to show a success message to the user here
      } else {
        console.error('Failed to start Odoo:', response.data.error);
        // You might want to show an error message to the user here
      }
    } catch (error) {
      console.error('Error starting Odoo:', error);
      // You might want to show an error message to the user here
    } finally {
      setIsStartingOdoo(false);
    }
  };

  const handleCredentialDialogClose = () => {
    setShowCredentials(false);
    startOdoo(); // Start Odoo after showing credentials
    setOpen(true);
  };

  return (
    <>
      <KeyDisplayDialog
        open={showKeys}
        onClose={handleKeyDialogClose}
        publicKey={rawPublicKey}
        privateKey={rawPrivateKey}
      />

      <CredentialDisplayDialog
        open={showCredentials}
        onClose={handleCredentialDialogClose}
        username={username}
        password={password}
      />

      <Modal open={open} aria-labelledby="modal-modal-title" aria-describedby="modal-modal-description">
        <Box sx={style}>
          <Typography id="modal-modal-title" variant="h6" component="h2">
            <div className="flex_2s">
              <span><CiWarning /> Important</span>
              <span onClick={handleClose} style={{ cursor: 'pointer' }}><IoMdClose /></span>
            </div>
          </Typography>
          <Typography id="modal-modal-description" sx={{ mt: 2, mb: 2 }}>
            Your mnemonic seed phrase will be displayed under your profile (Once you Log in). Please ensure now to Download it and keep it safe as it is crucial for recovering your account if needed.
          </Typography>
          <p>
            <Checkbox onChange={() => setUnderstand(!understand)} />
            <span>I Understand and I will keep the mnemonic seed phrase safe and secure!</span>
          </p>
          {understand && (
            <div className="flex_2s">
              <DownloadSeedWords text={seedWords} title="Download Seed Phrase" />
              <button className="btn btn_primary" onClick={() => continueCreateAccount(priv)}>Next</button>
            </div>
          )}
        </Box>
      </Modal>

      <Modal open={emailDialogOpen} onClose={() => setEmailDialogOpen(false)}>
        <Box sx={style}>
          <Typography variant="h6" component="h2">
            Enter Your Email
          </Typography>
          <Typography sx={{ mt: 2 }}>
            Please enter your email address. This will be used to create your MeshCentral account.
          </Typography>
          <TextField
            fullWidth
            margin="normal"
            label="Email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            error={!!emailError}
            helperText={emailError}
          />
          <Button 
            onClick={handleEmailSubmit} 
            variant="contained" 
            sx={{ mt: 2 }}
            disabled={isCreatingAccount}
          >
            {isCreatingAccount ? <CircularProgress size={24} /> : 'Submit'}
          </Button>
        </Box>
      </Modal>

      <Modal open={isStartingOdoo || odooStarted} onClose={() => setOdooStarted(false)}>
        <Box sx={style}>
          <Typography variant="h6" component="h2">
            {isStartingOdoo ? 'Starting Odoo' : 'Odoo Started'}
          </Typography>
          {isStartingOdoo ? (
            <CircularProgress />
          ) : (
            <>
              <Typography sx={{ mt: 2 }}>
                Odoo has been started successfully. You can now access it at:
              </Typography>
              <TextField
                fullWidth
                margin="normal"
                value="http://localhost:8069"
                InputProps={{
                  readOnly: true,
                }}
              />
              <Button 
                onClick={() => window.open('http://localhost:8069', '_blank')}
                variant="contained" 
                sx={{ mt: 2 }}
              >
                Open Odoo
              </Button>
            </>
          )}
        </Box>
      </Modal>

      {meshCommands && (
        <Modal open={true} onClose={() => setMeshCommands('')}>
          <Box sx={style}>
            <Typography variant="h6" component="h2">
              MeshCentral Commands
            </Typography>
            <Typography sx={{ mt: 2, whiteSpace: 'pre-wrap' }}>
              Please run the following commands to set up your MeshCentral account:
            </Typography>
            <TextField
              fullWidth
              multiline
              variant="outlined"
              value={meshCommands}
              InputProps={{
                readOnly: true,
              }}
              sx={{ mt: 2 }}
            />
            <Button onClick={() => setMeshCommands('')} variant="contained" sx={{ mt: 2 }}>
              Close
            </Button>
          </Box>
        </Modal>
      )}

      <Box
        component="img"
        src="/logo-large-white.png"
        sx={{
          width: isSm ? '526px' : '100%',
          height: isSm ? '132px' : null,
          m: '20px 0 10px 0',
        }}
      />
      <Divider sx={{ m: '28px 0' }} />

      {step === 1 ? (
        <Box sx={{ display: 'flex', justifyContent: 'center' }}>
          <CircularProgress />
        </Box>
      ) : step === 2 ? (
        <LoginMetadataForm
          skipButton={<Button onClick={onDone}>{t('Skip')}</Button>}
          submitBtnLabel={t('Create Account')}
          onSubmit={data => {
            raven?.updateProfile(data).then(() => onDone());
          }}
        />
      ) : (
        <>
          <Box sx={{ color: 'text.secondary', mb: '28px' }}>
            {t('Sign in to get started')}
          </Box>
          <Box sx={{ display: 'flex', flexDirection: isSm ? 'row' : 'column' }}>
            <Button
              variant="login"
              size="large"
              disableElevation
              fullWidth
              onClick={createAccount}
              sx={{ mb: '22px', p: '20px 26px', mr: isSm ? '22px' : null }}
              startIcon={<Creation width={38} />}
            >
              {t('Create Nostr Account')}
            </Button>
            <Button
              variant="login"
              size="large"
              disableElevation
              fullWidth
              onClick={importAccount}
              sx={{ mb: '22px', p: '20px 26px' }}
              startIcon={<Import width={38} />}
            >
              {t('Import Nostr Account')}
            </Button>
          </Box>
        </>
      )}
    </>
  );
};

export default Login;

=== ./login/h/index.tsx ===
import React, { useState, useEffect } from 'react';
import { useAtom } from 'jotai';
import { useTranslation } from 'react-i18next';
import { Box, Button, Divider, CircularProgress, Modal, Typography, Checkbox, TextField } from '@mui/material';
import { CiWarning } from 'react-icons/ci';
import { IoMdClose } from 'react-icons/io';
import { nip06, getPublicKey, nip19 } from 'nostr-tools';
import { generateFirstGenKeys, deriveSecondGenKeys, generateCredentials } from 'hooks/keyDerivation';
import { keysAtom, profileAtom, backupWarnAtom, ravenAtom, ravenStatusAtom } from 'atoms';
import useModal from 'hooks/use-modal';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import LoginMetadataForm from 'views/components/metadata-form/loginForm';
import KeyDisplayDialog from 'views/components/KeyDisplayDialog';
import CredentialDisplayDialog from 'views/components/CredentialDisplayDialog';
import DownloadSeedWords from 'views/settings/DownloadSeedWords';
import Creation from 'svg/creation';
import Import from 'svg/import';
import { storeKeys, storeCredentials } from 'local-storage';
import { Keys } from 'types';
import ImportAccount from 'views/components/dialogs/import-account';
import { InstallNip07Dialog } from "views/components/dialogs/no-wallet/nip07";
import axios from 'axios';

import { getUserIP } from './ip';

const style = {
  position: 'absolute' as 'absolute',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)',
  width: '700px',
  maxWidth: '100%',
  bgcolor: 'background.paper',
  border: '2px solid #000',
  boxShadow: 24,
  p: 4,
};

const Login = (props: { onDone: () => void }) => {
  const { onDone } = props;
  const { isSm } = useMediaBreakPoint();
  const { t } = useTranslation();
  const [, showModal] = useModal();
  const [, setKeys] = useAtom(keysAtom);
  const [profile, setProfile] = useAtom(profileAtom);
  const [, setBackupWarn] = useAtom(backupWarnAtom);
  const [raven] = useAtom(ravenAtom);
  const [ravenStatus] = useAtom(ravenStatusAtom);
  const [step, setStep] = useState<0 | 1 | 2>(0);
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [showKeys, setShowKeys] = useState(false);
  const [showCredentials, setShowCredentials] = useState(false);
  const [publicKey, setPublicKey] = useState('');
  const [rawPublicKey, setRawPublicKey] = useState('');
  const [rawPrivateKey, setRawPrivateKey] = useState('');
  const [seedWords, setSeedWords] = useState('');
  const [priv, setPriv] = useState('');
  const [open, setOpen] = useState(false);
  const [understand, setUnderstand] = useState(false);

  const [emailDialogOpen, setEmailDialogOpen] = useState(false);
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');
  const [isCreatingAccount, setIsCreatingAccount] = useState(false);
  const [meshCommands, setMeshCommands] = useState('');
  
  useEffect(() => {
    if (step === 1 && ravenStatus.ready) setStep(2);
  }, [step, ravenStatus.ready]);

  useEffect(() => {
    if (profile) onDone();
  }, [profile]);

  const handleOpen = () => setOpen(true);
  const handleClose = () => setOpen(false);
  
  const [isStartingOdoo, setIsStartingOdoo] = useState(false);
  const [odooStarted, setOdooStarted] = useState(false);

  const createAccount = async () => {
    const { mnemonic, privateKey } = generateFirstGenKeys();
    console.log("Generated mnemonic:", mnemonic);
    console.log("Generated private key:", privateKey);

    if (!mnemonic || !privateKey) {
      console.error("Failed to generate keys");
      alert("Failed to generate account keys. Please try again.");
      return;
    }

    const pubKey = getPublicKey(privateKey);

    // Ensure cookies are set correctly
    document.cookie = `ssoUsername=${pubKey}; path=/; secure; samesite=strict`;
    document.cookie = `ssoPassword=${privateKey}; path=/; secure; samesite=strict`;

    setRawPublicKey(pubKey);
    setRawPrivateKey(privateKey);

    const secondGenKeys = deriveSecondGenKeys(privateKey);
    const { username, password } = generateCredentials(secondGenKeys.privateKey);

    setSeedWords(mnemonic);
    setPriv(privateKey);
    setUsername(username);
    setPassword(password);

    const userIP = await getUserIP();
    await storeCredentials(username, password, userIP);

    localStorage.setItem('seedWords', mnemonic);

    setShowKeys(true);
    setEmailDialogOpen(true);
  };

  const handleEmailSubmit = async () => {
    if (!email) {
      setEmailError('Email is required');
      return;
    }
    if (!/\S+@\S+\.\S+/.test(email)) {
      setEmailError('Invalid email format');
      return;
    }
    setEmailError('');
    
  const npubKey = nip19.npubEncode(rawPublicKey);
  const nsecKey = nip19.nsecEncode(rawPrivateKey);

  setIsCreatingAccount(true);
  try {
    // Start Odoo
    const response = await axios.post('http://localhost:5001/api/start-odoo', {
      publicKey: npubKey,
      privateKey: nsecKey,
      email
    });

    if (response.data.success) {
      console.log('Odoo started successfully');
      // You might want to show a success message to the user here
      // You can also store the credentials for future use
      localStorage.setItem('odooUsername', npubKey);
      localStorage.setItem('odooPassword', nsecKey);
    } else {
      console.error('Failed to start Odoo:', response.data.error);
      // You might want to show an error message to the user here
    }
  } catch (error) {
    console.error('Error starting Odoo:', error);
    // You might want to show an error message to the user here
  } finally {
    setIsCreatingAccount(false);
  }

  setEmailDialogOpen(false);
  setShowCredentials(true);
};

  const importAccount = () => {
    showModal({
      body: (
        <ImportAccount
          onSuccess={(key, type) => {
            showModal(null);
            if (type === 'priv') {
              loginPriv(key);
            } else if (type === 'pub') {
              proceed({ priv: 'none', pub: key });
            }
          }}
        />
      ),
    });
  };

  const loginNip07 = async () => {
    if (!window.nostr) {
      showModal({
        body: <InstallNip07Dialog />,
      });
      return;
    }

    const pub = await window.nostr.getPublicKey();
    if (pub) proceed({ priv: 'nip07', pub });
  };

  const loginPriv = (priv: string) => {
    try {
      const pub = getPublicKey(priv);
      proceed({ priv, pub });
    } catch (error) {
      console.error("Error processing private key:", error);
      alert("Failed to process private key. Please try creating the account again.");
    }
  };

  const proceed = (keys: Keys) => {
    storeKeys(keys).then(() => {
      setKeys(keys);
      setProfile(null);
      if (keys?.priv === 'none') {
        onDone();
        return;
      }
      setStep(1);
    });
  };

  const continueCreateAccount = (priv: string | null) => {
    if (!priv) {
      console.error("Private key is null");
      alert("Invalid private key. Please try creating the account again.");
      return;
    }
    handleClose();
    loginPriv(priv);
    setBackupWarn(true);
  };

  const handleKeyDialogClose = () => {
    setShowKeys(false);
    setShowCredentials(true);
  };


  const startOdoo = async () => {
    setIsStartingOdoo(true);
    try {
      const response = await axios.post('http://localhost:5001/api/start-odoo', {
        publicKey: nip19.npubEncode(rawPublicKey),
        privateKey: nip19.nsecEncode(rawPrivateKey)
      });

      if (response.data.success) {
        console.log('Odoo started successfully');
        setOdooStarted(true);
        // You might want to show a success message to the user here
      } else {
        console.error('Failed to start Odoo:', response.data.error);
        // You might want to show an error message to the user here
      }
    } catch (error) {
      console.error('Error starting Odoo:', error);
      // You might want to show an error message to the user here
    } finally {
      setIsStartingOdoo(false);
    }
  };

  const handleCredentialDialogClose = () => {
    setShowCredentials(false);
    startOdoo(); // Start Odoo after showing credentials
    setOpen(true);
  };

  return (
    <>
      <KeyDisplayDialog
        open={showKeys}
        onClose={handleKeyDialogClose}
        publicKey={rawPublicKey}
        privateKey={rawPrivateKey}
      />

      <CredentialDisplayDialog
        open={showCredentials}
        onClose={handleCredentialDialogClose}
        username={username}
        password={password}
      />

      <Modal open={open} aria-labelledby="modal-modal-title" aria-describedby="modal-modal-description">
        <Box sx={style}>
          <Typography id="modal-modal-title" variant="h6" component="h2">
            <div className="flex_2s">
              <span><CiWarning /> Important</span>
              <span onClick={handleClose} style={{ cursor: 'pointer' }}><IoMdClose /></span>
            </div>
          </Typography>
          <Typography id="modal-modal-description" sx={{ mt: 2, mb: 2 }}>
            Your mnemonic seed phrase will be displayed under your profile (Once you Log in). Please ensure now to Download it and keep it safe as it is crucial for recovering your account if needed.
          </Typography>
          <p>
            <Checkbox onChange={() => setUnderstand(!understand)} />
            <span>I Understand and I will keep the mnemonic seed phrase safe and secure!</span>
          </p>
          {understand && (
            <div className="flex_2s">
              <DownloadSeedWords text={seedWords} title="Download Seed Phrase" />
              <button className="btn btn_primary" onClick={() => continueCreateAccount(priv)}>Next</button>
            </div>
          )}
        </Box>
      </Modal>

      <Modal open={emailDialogOpen} onClose={() => setEmailDialogOpen(false)}>
        <Box sx={style}>
          <Typography variant="h6" component="h2">
            Enter Your Email
          </Typography>
          <Typography sx={{ mt: 2 }}>
            Please enter your email address. This will be used to create your MeshCentral account.
          </Typography>
          <TextField
            fullWidth
            margin="normal"
            label="Email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            error={!!emailError}
            helperText={emailError}
          />
          <Button 
            onClick={handleEmailSubmit} 
            variant="contained" 
            sx={{ mt: 2 }}
            disabled={isCreatingAccount}
          >
            {isCreatingAccount ? <CircularProgress size={24} /> : 'Submit'}
          </Button>
        </Box>
      </Modal>

      <Modal open={isStartingOdoo || odooStarted} onClose={() => setOdooStarted(false)}>
        <Box sx={style}>
          <Typography variant="h6" component="h2">
            {isStartingOdoo ? 'Starting Odoo' : 'Odoo Started'}
          </Typography>
          {isStartingOdoo ? (
            <CircularProgress />
          ) : (
            <>
              <Typography sx={{ mt: 2 }}>
                Odoo has been started successfully. You can now access it at:
              </Typography>
              <TextField
                fullWidth
                margin="normal"
                value="http://localhost:8069"
                InputProps={{
                  readOnly: true,
                }}
              />
              <Button 
                onClick={() => window.open('http://localhost:8069', '_blank')}
                variant="contained" 
                sx={{ mt: 2 }}
              >
                Open Odoo
              </Button>
            </>
          )}
        </Box>
      </Modal>

      {meshCommands && (
        <Modal open={true} onClose={() => setMeshCommands('')}>
          <Box sx={style}>
            <Typography variant="h6" component="h2">
              MeshCentral Commands
            </Typography>
            <Typography sx={{ mt: 2, whiteSpace: 'pre-wrap' }}>
              Please run the following commands to set up your MeshCentral account:
            </Typography>
            <TextField
              fullWidth
              multiline
              variant="outlined"
              value={meshCommands}
              InputProps={{
                readOnly: true,
              }}
              sx={{ mt: 2 }}
            />
            <Button onClick={() => setMeshCommands('')} variant="contained" sx={{ mt: 2 }}>
              Close
            </Button>
          </Box>
        </Modal>
      )}

      <Box
        component="img"
        src="/logo-large-white.png"
        sx={{
          width: isSm ? '526px' : '100%',
          height: isSm ? '132px' : null,
          m: '20px 0 10px 0',
        }}
      />
      <Divider sx={{ m: '28px 0' }} />

      {step === 1 ? (
        <Box sx={{ display: 'flex', justifyContent: 'center' }}>
          <CircularProgress />
        </Box>
      ) : step === 2 ? (
        <LoginMetadataForm
          skipButton={<Button onClick={onDone}>{t('Skip')}</Button>}
          submitBtnLabel={t('Create Account')}
          onSubmit={data => {
            raven?.updateProfile(data).then(() => onDone());
          }}
        />
      ) : (
        <>
          <Box sx={{ color: 'text.secondary', mb: '28px' }}>
            {t('Sign in to get started')}
          </Box>
          <Box sx={{ display: 'flex', flexDirection: isSm ? 'row' : 'column' }}>
            <Button
              variant="login"
              size="large"
              disableElevation
              fullWidth
              onClick={createAccount}
              sx={{ mb: '22px', p: '20px 26px', mr: isSm ? '22px' : null }}
              startIcon={<Creation width={38} />}
            >
              {t('Create Nostr Account')}
            </Button>
            <Button
              variant="login"
              size="large"
              disableElevation
              fullWidth
              onClick={importAccount}
              sx={{ mb: '22px', p: '20px 26px' }}
              startIcon={<Import width={38} />}
            >
              {t('Import Nostr Account')}
            </Button>
          </Box>
        </>
      )}
    </>
  );
};

export default Login;

=== ./chat-view/ProposalChatView.tsx ===
// @ts-nocheck

import React, { useEffect, useMemo, useRef, useState } from 'react';
import { toast } from 'react-toastify';
import { useAtom } from 'jotai';
import uniq from 'lodash.uniq';
import { darken } from '@mui/material';
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import { useTheme } from '@mui/material/styles';
import Typography from '@mui/material/Typography';
import Tooltip from '@mui/material/Tooltip';
import { grey } from '@mui/material/colors';
import Divider from '@mui/material/Divider';
import useTranslation from 'hooks/use-translation';
import useStyles from 'hooks/use-styles';
import MessageView from 'views/components/message-view';
import {
  FormControl,
  Select,
  MenuItem,
  InputLabel
} from '@mui/material';
import {
  ravenAtom,
  activeProposalIdAtom,
  readMarkMapAtom,
  tempPrivAtom,
  keysAtom,
  channelAtom,
  proposalCommitteesAtom,
  channelsAtom,
  directContactsAtom
} from 'atoms';
import { Message, Committee, Channel, Proposal } from 'types';
import {
  formatMessageTime,
  formatMessageDate,
} from 'helper';
import { SCROLL_DETECT_THRESHOLD, PLATFORM } from 'const';
import { separateByAgreement } from 'util/function';

const ProposalChatView = (props: { messages: Message[], separator: string, loading?: boolean, isDM?: boolean, isPermanentProposal?: boolean }) => {
  const { separator, messages, loading, isDM, isPermanentProposal } = props;
  const theme = useTheme();
  const styles = useStyles();
  const [t] = useTranslation();
  const ref = useRef<HTMLDivElement | null>(null);
  const [isAtBottom, setIsAtBottom] = useState(true);
  const [firstMessageEl, setFirstMessageEl] = useState<HTMLDivElement | null>(null);
  const [scrollTop, setScrollTop] = useState<number>(0);
  const [raven] = useAtom(ravenAtom);
  const [keys] = useAtom(keysAtom);
  const [tempPriv] = useAtom(tempPrivAtom);
  const [readMarkMap] = useAtom(readMarkMapAtom);
  const [proposalCommittees, setProposalCommittees] = useAtom(proposalCommitteesAtom);

  const [activeProposalId] = useAtom(activeProposalIdAtom);
  const [channel] = useAtom(channelAtom);
  const [channels] = useAtom(channelsAtom);

const [directContacts] = useAtom(directContactsAtom);
const [selectedContact, setSelectedContact] = useState<string | null>(null);

  const scrollToBottom = () => {
    ref.current!.scroll({ top: ref.current!.scrollHeight, behavior: 'auto' });
  }

  useEffect(() => {
    if (ref.current && isAtBottom) {
      scrollToBottom();
    }
  }, [messages]);

  useEffect(() => {
    scrollToBottom();
  }, [separator]);

  useEffect(() => {
    if (isAtBottom && keys?.priv !== 'none') {
      if (messages.length === 0) return;

      if (isPermanentProposal) {
        const permanentProposalReadMarkKey = `permanent_proposal_${separator}`;
        if (readMarkMap[permanentProposalReadMarkKey] === undefined) {
          raven?.updateReadMarkMap({ ...readMarkMap, ...{ [permanentProposalReadMarkKey]: Math.floor(Date.now() / 1000) } });
          return;
        }

        const lMessage = messages[messages.length - 1];
        if (lMessage.created > readMarkMap[permanentProposalReadMarkKey]) {
          raven?.updateReadMarkMap({ ...readMarkMap, ...{ [permanentProposalReadMarkKey]: Math.floor(Date.now() / 1000) } });
        }
      } else {
        if (readMarkMap[separator] === undefined) {
          raven?.updateReadMarkMap({ ...readMarkMap, ...{ [separator]: Math.floor(Date.now() / 1000) } });
          return;
        }

        const lMessage = messages[messages.length - 1];
        if (lMessage.created > readMarkMap[separator]) {
          raven?.updateReadMarkMap({ ...readMarkMap, ...{ [separator]: Math.floor(Date.now() / 1000) } });
        }
      }
    }
  }, [separator, isAtBottom, messages, readMarkMap, keys, isPermanentProposal]);

  useEffect(() => {
    let scrollTimer: any;
    const div = ref.current;

    const handleScroll = () => {
      clearTimeout(scrollTimer);
      scrollTimer = setTimeout(() => {
        setScrollTop(div!.scrollTop);
        const isAtBottom = Math.abs((div!.scrollHeight - div!.scrollTop) - div!.clientHeight) <= SCROLL_DETECT_THRESHOLD
        setIsAtBottom(isAtBottom);
        const isAtTop = (div!.scrollHeight > div!.clientHeight) && div!.scrollTop < SCROLL_DETECT_THRESHOLD;
        if (isAtTop) {
          window.dispatchEvent(new Event('chat-view-top', { bubbles: true }))
        }
      }, 50);
    }

    div?.addEventListener('scroll', handleScroll);
    return () => {
      div?.removeEventListener('scroll', handleScroll);
    }
  }, []);

  useEffect(() => {
    const imageLoaded = () => {
      if (ref.current && isAtBottom) {
        scrollToBottom();
      }
    }

    window.addEventListener('chat-media-loaded', imageLoaded);
    return () => {
      window.removeEventListener('chat-media-loaded', imageLoaded)
    }
  }, [isAtBottom]);

  useEffect(() => {
    if (loading) {
      setFirstMessageEl(ref.current!.querySelector('.message') as HTMLDivElement);
    } else {
      if (firstMessageEl) {
        if (firstMessageEl.previousSibling) {
          (firstMessageEl.previousSibling as HTMLDivElement).scrollIntoView(true);
        }
        setFirstMessageEl(null);
      }
    }
  }, [loading]);

  useEffect(() => {
    const messageIds = Array.from(document.querySelectorAll('.message[data-visible=true]'))
      .map(el => el.getAttribute('data-id'))
      .filter(id => id !== null) as string[];
    if (messageIds.length === 0) return;

    const now = Math.floor(Date.now() / 1000)
    const relIds = messageIds.map(m => messages.find(x => x.id === m)?.reactions?.filter(x => x.creator !== keys?.pub).filter(l => now - l.created <= 600).map(l => l.id) || []).flat();

    let interval: any;
    const timer = setTimeout(() => {
      raven?.listenMessages(
        messageIds.filter(id => id !== null) as string[],
        relIds.filter(id => id !== null) as string[]
      );
    }, 500);

    return () => {
      clearTimeout(timer);
      clearInterval(interval);
    }
  }, [raven, messages, scrollTop]);

  useEffect(() => {
    if (!ref.current) return;

    const observer = new ResizeObserver(() => {
      if (ref.current && isAtBottom) {
        scrollToBottom();
      }
    });

    observer.observe(ref.current);

    return () => {
      observer.disconnect();
    }
  }, [isAtBottom]);

  const filteredMessages = useMemo(() => {
    return messages.filter(message => message.proposalID === activeProposalId);
  }, [messages, activeProposalId]);
  // <p>{channel.description}</p>

const isUserInCommittee = useMemo(() => {
  return proposalCommittees.some(committee => 
    committee.members.includes(keys?.pub || '')
  );
}, [proposalCommittees, keys]);

const addMember = async () => {
  if (!selectedContact || !isUserInCommittee || !channel || !keys) return;

  // Check if the proposal has failed
  const hasProposalFailed = ermHasProposalFailed;
  if (hasProposalFailed) {
    toast.error("Cannot add members to failed proposals");
    return;
  }

  setProposalCommittees((prevCommittees: Committee[]) => {
    return prevCommittees.map((committee, index) => {
      if (index === 1) { // Always add to the second committee
        return {
          ...committee,
          members: [...committee.members, selectedContact]
        };
      }
      return committee;
    });
  });

  // Send DM to the added member
  try {
    const message = `You have been added to a proposal committee. Proposal ID: ${channel.id}, Added by: ${keys.pub}`;
    await raven?.sendDirectMessage(selectedContact, message);
    toast.success("Member added and notified");
  } catch (error) {
    console.error("Failed to send DM", error);
    toast.error("Member added but notification failed");
  }

  setSelectedContact(null); // Reset selection after adding
};

const ermHasProposalFailed = useMemo(() => {
  if (!channel || !(channel as Proposal).about) return false;

  const about = JSON.parse((channel as Proposal).about);
  const { agreed, nonAgreed } = separateByAgreement(about.voting);
  return nonAgreed.length >= agreed.length;
}, [channel]);

  const removeMember = (committeeId: string) => {
    setProposalCommittees((prevCommittees: Committee[]) => {
      return prevCommittees.map(committee => {
        if (committee.id === committeeId) {
          const updatedMembers = [...committee.members];
          updatedMembers.pop();
          return {
            ...committee,
            members: updatedMembers,
          };
        }
        return committee;
      });
    });
  };

useEffect(() => {
  if (channel?.id && channel.creator) {
    setProposalCommittees((prevCommittees: Committee[]) => {
      return prevCommittees.map((committee, index) => {
        if (index === 0 && !committee.members.includes(channel.creator)) {
          return {
            ...committee,
            members: [...committee.members, channel.creator],
          };
        }
        return committee;
      });
    });
  }
}, [channel]);

console.log("Proposal Committees: ", proposalCommittees);
  console.log("Channel: ", channel);
  console.log("Channels: ", channels);


/*
      <div className="committees">
{proposalCommittees.map((committee, index) => (
  <div key={committee.id} className="committee">
    <div className="committee-header">{committee.name}</div>
    <div className="committee-members">
      <p>Members: {committee.members.join(', ')}</p>
      <div className="add-remove-buttons">
        {channel?.id && <button onClick={() => addMember(channel.id)}>Add Member</button>}
        <button onClick={() => removeMember(committee.id)}>Remove Member</button>
      </div>
    </div>
  </div>
))}
      </div>
*/

const ContactDropdown = () => (
  <FormControl fullWidth>
    <InputLabel>Select Contact</InputLabel>
    <Select
      value={selectedContact || ''}
      onChange={(e) => setSelectedContact(e.target.value as string)}
      disabled={!isUserInCommittee}
    >
      {directContacts.map((contact) => (
        <MenuItem key={contact.pub} value={contact.pub}>
          {contact.npub}
        </MenuItem>
      ))}
    </Select>
  </FormControl>
);

  return (
    <Box sx={{ display: 'flex', height: 'calc(100vh - 64px)' }}>
      {/* Chat Section */}
<Box 
  ref={ref} 
  sx={{ 
    flex: 2, 
    mt: 'auto', 
    overflowY: 'auto', // Add this line
    maxHeight: 'calc(100vh - 64px)', // Add this line
    ...styles.scrollY, 
    borderRight: `1px solid ${theme.palette.divider}` 
  }}
>
        <div className="proposal-info">
          <h3>{channel?.name}</h3>
        </div>
        {filteredMessages.map(message => (
          <MessageView 
            key={message.id} 
            message={message} 
            compactView={false} 
            dateFormat="time"
          />
        ))}
        {messages.map((msg, i) => {
          const prevMsg = messages[i - 1];
          const msgDate = formatMessageDate(msg.created);
          const prevMsgDate = prevMsg ? formatMessageDate(prevMsg.created) : null;
          const isCompact = prevMsg ? msg.creator === prevMsg?.creator && formatMessageTime(msg.created) === formatMessageTime(prevMsg.created) : false;

          if (msgDate !== prevMsgDate) {
            return (
              <React.Fragment key={msg.id}>
                <Divider
                  sx={{
                    m: '0 24px',
                    fontSize: '0.7em',
                    color: darken(theme.palette.text.secondary, 0.4),
                    mt: i === 0 ? '100px' : null,
                  }}
                >
                  {msgDate}
                </Divider>
                <MessageView message={msg} dateFormat="time" compactView={isCompact} />
              </React.Fragment>
            );
          }

          return <MessageView key={msg.id} message={msg} dateFormat="time" compactView={isCompact} />;
        })}

        {(channel as Proposal)?.readyForMarket && (channel as Proposal).productDetails && (
          <Box>
            <Typography variant="h6">Marketplace Product Details</Typography>
            <Typography>
              Price: {(channel as Proposal).productDetails?.price ?? 'N/A'}
            </Typography>
            <Typography>
              Quantity: {(channel as Proposal).productDetails?.quantity ?? 'N/A'}
            </Typography>
          </Box>
        )}

        {isDM && keys?.priv === 'none' && !tempPriv && (
          <Box sx={{ textAlign: 'center', m: '20px 0' }}>
            <Button
              variant="contained"
              onClick={() => {
                window.requestPrivateKey().then();
              }}
            >
              {t('Decrypt chat')}
            </Button>
          </Box>
        )}
      </Box>

      {/* Dashboard Section */}
      <Box sx={{ flex: 1, overflow: 'auto', p: 2, backgroundColor: theme.palette.background.default }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Dashboard
        </Typography>

<Box sx={{ mb: 4 }}>
  <Typography variant="h5" component="h2" gutterBottom>
    Committees
  </Typography>
  {proposalCommittees.map((committee, index) => (
    <Box key={committee.id} sx={{ mb: 2, p: 2, backgroundColor: theme.palette.background.paper, borderRadius: 1 }}>
      <Typography variant="h6">{committee.name}</Typography>
      <Typography>Members: {committee.members.join(', ')}</Typography>
      {index === 1 && isUserInCommittee && !ermHasProposalFailed && (
        <Box sx={{ mt: 1 }}>
          <ContactDropdown />
          <Button 
            variant="contained" 
            size="small" 
            sx={{ mt: 1 }} 
            onClick={addMember}
            disabled={!selectedContact || ermHasProposalFailed}
          >
            Add Member
          </Button>
        </Box>
      )}
    </Box>
  ))}
</Box>

        <Box sx={{ mb: 4 }}>
          <Typography variant="h5" component="h2" gutterBottom>
            Proposal Details
          </Typography>
          <Box sx={{ p: 2, backgroundColor: theme.palette.background.paper, borderRadius: 1 }}>
            <Typography><strong>Name:</strong> {channel?.name}</Typography>
            <Typography><strong>Creator:</strong> {channel?.creator}</Typography>
            <Typography><strong>Status:</strong> {(channel as Proposal)?.readyForMarket ? 'Ready for Market' : 'In Progress'}</Typography>
          </Box>
        </Box>

        <Box sx={{ mb: 4 }}>
          <Typography variant="h5" component="h2" gutterBottom>
            Activities
          </Typography>
          {filteredMessages.slice(0, 5).map((message) => (
            <Box key={message.id} sx={{ mb: 2, p: 2, backgroundColor: theme.palette.background.paper, borderRadius: 1 }}>
              <Typography><strong>Contributor:</strong> {message.creator}</Typography>
              <Typography><strong>Message:</strong> {message.content}</Typography>
            </Box>
          ))}
        </Box>

        <Box>
          <Typography variant="h5" component="h2" gutterBottom>
            Rewards
          </Typography>
          <Box sx={{ p: 2, backgroundColor: theme.palette.background.paper, borderRadius: 1 }}>
            <Typography>Reward distribution to be implemented</Typography>
          </Box>
        </Box>
      </Box>
    </Box>
  );
};

export default ProposalChatView;=== ./chat-view/index.tsx ===
import React, { useEffect, useRef, useState } from 'react';
import { Box, darken } from '@mui/material';
import Divider from '@mui/material/Divider';
import { useTheme } from '@mui/material/styles';
import Button from '@mui/material/Button';
import { useAtom } from 'jotai';
import { activeProposalIdAtom, channelAtom, proposalCommitteesAtom } from 'atoms';

import MessageView from 'views/components/message-view';
import useStyles from 'hooks/use-styles';
import useTranslation from 'hooks/use-translation';
import { formatMessageDate, formatMessageTime } from 'helper';
import { Message, Committee, Channel } from 'types';
import { SCROLL_DETECT_THRESHOLD } from 'const';
import { keysAtom, ravenAtom, readMarkMapAtom, tempPrivAtom, channelsAtom } from 'atoms';
import { notEmpty } from 'util/misc';

const ChatView = (props: { messages: Message[], separator: string, loading?: boolean, isDM?: boolean }) => {
  const { separator, messages, loading, isDM } = props;
  const theme = useTheme();
  const styles = useStyles();
  const [t] = useTranslation();
  const ref = useRef<HTMLDivElement | null>(null);
  const [isAtBottom, setIsAtBottom] = useState(true);
  const [firstMessageEl, setFirstMessageEl] = useState<HTMLDivElement | null>(null);
  const [scrollTop, setScrollTop] = useState<number>(0);
  const [raven] = useAtom(ravenAtom);
  const [keys] = useAtom(keysAtom);
  const [tempPriv] = useAtom(tempPrivAtom);
  const [readMarkMap] = useAtom(readMarkMapAtom);
  const [activeProposalId] = useAtom(activeProposalIdAtom);
  const [channel] = useAtom(channelAtom);
  const [channels] = useAtom(channelsAtom);
  const [proposalCommittees, setProposalCommittees] = useAtom(proposalCommitteesAtom);

  const filteredMessages = messages.filter(message => message.proposalID === activeProposalId);

  const scrollToBottom = () => {
    ref.current!.scroll({ top: ref.current!.scrollHeight, behavior: 'auto' });
  }

  useEffect(() => {
    if (ref.current && isAtBottom) {
      scrollToBottom();
    }
  }, [messages]);

  useEffect(() => {
    scrollToBottom();
  }, [separator]);

  useEffect(() => {
    if (isAtBottom && keys?.priv !== 'none') {
      if (messages.length === 0) return;

      if (readMarkMap[separator] === undefined) {
        raven?.updateReadMarkMap({ ...readMarkMap, ...{ [separator]: Math.floor(Date.now() / 1000) } });
        return;
      }

      const lMessage = messages[messages.length - 1];
      if (lMessage.created > readMarkMap[separator]) {
        raven?.updateReadMarkMap({ ...readMarkMap, ...{ [separator]: Math.floor(Date.now() / 1000) } });
      }
    }
  }, [separator, isAtBottom, messages, readMarkMap, keys]);

  useEffect(() => {
    let scrollTimer: any;
    const div = ref.current;

    const handleScroll = () => {
      clearTimeout(scrollTimer);
      scrollTimer = setTimeout(() => {
        setScrollTop(div!.scrollTop);
        const isAtBottom = Math.abs((div!.scrollHeight - div!.scrollTop) - div!.clientHeight) <= SCROLL_DETECT_THRESHOLD
        setIsAtBottom(isAtBottom);
        const isAtTop = (div!.scrollHeight > div!.clientHeight) && div!.scrollTop < SCROLL_DETECT_THRESHOLD;
        if (isAtTop) {
          window.dispatchEvent(new Event('chat-view-top', { bubbles: true }))
        }
      }, 50);
    }

    div?.addEventListener('scroll', handleScroll);
    return () => {
      div?.removeEventListener('scroll', handleScroll);
    }
  }, []);

  useEffect(() => {
    const imageLoaded = () => {
      if (ref.current && isAtBottom) {
        scrollToBottom();
      }
    }

    window.addEventListener('chat-media-loaded', imageLoaded);
    return () => {
      window.removeEventListener('chat-media-loaded', imageLoaded)
    }
  }, [isAtBottom]);

  useEffect(() => {
    if (loading) {
      setFirstMessageEl(ref.current!.querySelector('.message') as HTMLDivElement);
    } else {
      if (firstMessageEl) {
        if (firstMessageEl.previousSibling) {
          (firstMessageEl.previousSibling as HTMLDivElement).scrollIntoView(true);
        }
        setFirstMessageEl(null);
      }
    }
  }, [loading]);

  useEffect(() => {
    const messageIds = Array.from(document.querySelectorAll('.message[data-visible=true]')).map(el => el.getAttribute('data-id')).filter(notEmpty);
    if (messageIds.length === 0) return;

    const now = Math.floor(Date.now() / 1000)
    const relIds = messageIds.map(m => messages.find(x => x.id === m)?.reactions?.filter(x => x.creator !== keys?.pub).filter(l => now - l.created <= 600).map(l => l.id) || []).flat();

    let interval: any;
    const timer = setTimeout(() => {
      raven?.listenMessages(messageIds, relIds);
      interval = setInterval(() => {
        raven?.listenMessages(messageIds, relIds);
      }, 10000);
    }, 500);

    return () => {
      clearTimeout(timer);
      clearInterval(interval);
    }
  }, [raven, messages, scrollTop]);

  useEffect(() => {
    if (!ref.current) return;

    const observer = new ResizeObserver(() => {
      if (ref.current && isAtBottom) {
        scrollToBottom();
      }
    });

    observer.observe(ref.current);

    return () => {
      observer.disconnect();
    }
  }, [isAtBottom]);
  // <p>{channel.description}</p>

  const addMember = (proposalId: string) => {
    if (!channels) {
      console.error('Channels not found');
      return;
    }

    const channel = channels.find((ch: Channel) => ch.id === proposalId);

    if (!channel) {
      console.error('Channel not found');
      return;
    }

    const creator = channel.creator;
    const voters = JSON.parse(channel.about).voting.map((vote: { voter: string }) => vote.voter);

    setProposalCommittees((prevCommittees: Committee[]) => {
      return prevCommittees.map((committee, index) => {
        if (index === 0 && !committee.members.includes(creator)) {
          return {
            ...committee,
            members: [...committee.members, creator],
          };
        } else if (index === 1) {
          const newMembers = voters.filter((voter: string) => !committee.members.includes(voter));
          return {
            ...committee,
            members: [...committee.members, ...newMembers],
          };
        }
        return committee;
      });
    });
  };

  const removeMember = (committeeId: string) => {
    setProposalCommittees((prevCommittees: Committee[]) => {
      return prevCommittees.map(committee => {
        if (committee.id === committeeId) {
          const updatedMembers = [...committee.members];
          updatedMembers.pop();
          return {
            ...committee,
            members: updatedMembers,
          };
        }
        return committee;
      });
    });
  };

/*
<div className="committees">
        {proposalCommittees.map((committee, index) => (
          <div key={committee.id} className="committee">
            <div className="committee-header">{committee.name}</div>
            <div className="committee-members">
              <p>Members: {committee.members.join(', ')}</p>
              <div className="add-remove-buttons">
                {channel?.id && <button onClick={() => addMember(channel.id)}>Add Member</button>}
                <button onClick={() => removeMember(committee.id)}>Remove Member</button>
              </div>
            </div>
          </div>
        ))}
      </div>
*/

  return (
    <Box ref={ref} sx={{ mt: 'auto', ...styles.scrollY }}>
      <div className="proposal-info">
        <h3>{channel?.name}</h3>
      </div>
      {filteredMessages.map(message => (
        <MessageView 
          key={message.id} 
          message={message} 
          compactView={false} 
          dateFormat="time"
        />
      ))}
      {messages.map((msg, i) => {
        const prevMsg = messages[i - 1];
        const msgDate = formatMessageDate(msg.created);
        const prevMsgDate = prevMsg ? formatMessageDate(prevMsg.created) : null;
        const isCompact = prevMsg ? msg.creator === prevMsg?.creator && formatMessageTime(msg.created) === formatMessageTime(prevMsg.created) : false;

        if (msgDate !== prevMsgDate) {
          return (
            <React.Fragment key={msg.id}>
              <Divider sx={{ m: '0 24px', fontSize: '0.7em', color: darken(theme.palette.text.secondary, 0.4), mt: i === 0 ? '100px' : null }}>
                {msgDate}
              </Divider>
              <MessageView message={msg} dateFormat='time' compactView={isCompact} />
            </React.Fragment>
          )
        }

        return <MessageView key={msg.id} message={msg} dateFormat='time' compactView={isCompact} />;
      })}
      {(isDM && keys?.priv === 'none' && !tempPriv) && (
        <Box sx={{ textAlign: 'center', m: '20px 0' }}>
          <Button variant="contained" onClick={() => { window.requestPrivateKey().then(); }}>{t('Decrypt chat')}</Button>
        </Box>
      )}
    </Box>
  );
}

export default ChatView;
=== ./dm-input/index.tsx ===
import React, {useState} from 'react';
import {useAtom} from 'jotai';
import TextField from '@mui/material/TextField';
import Button from '@mui/material/Button';
import useTranslation from 'hooks/use-translation';
import {ravenAtom} from 'atoms';
import Send from 'svg/send';

const DmInput = (props: { pubkey: string, onDM: () => void }) => {
    const {pubkey, onDM} = props;
    const [message, setMessage] = useState('');
    const [raven] = useAtom(ravenAtom);
    const [t] = useTranslation();

    const send = () => {
        if (message.trim() !== '') {
            raven?.sendDirectMessage(pubkey, message).then(() => {
                setMessage('');
                onDM();
            });
        }
    }

    return <TextField
        autoComplete="off"
        InputProps={{
            sx: {
                fontSize: '14px',
                pr: '3px'
            },
            endAdornment: <>
                <Button variant="contained" size="small" color="primary" sx={{
                    minWidth: 'auto',
                    width: '28px',
                    height: '28px',
                    padding: '6px',
                    borderRadius: '4px'
                }} onClick={send}><Send height={28}/></Button>
            </>
        }}
        size="small"
        fullWidth
        placeholder={t('Send direct message')}
        value={message}
        onChange={(e) => {
            setMessage(e.target.value);
        }}
        onKeyUp={(e) => {
            if (e.key === 'Enter') {
                send();
            }
        }}
    />
}

export default DmInput;
=== ./app-menu-base/index.tsx ===
import React, {useEffect} from 'react';
import {useAtom} from 'jotai';
import {useLocation} from '@reach/router';
import Box from '@mui/material/Box';
import {useTheme} from '@mui/material/styles';
import UserMenu from 'views/components/app-menu/user-menu';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import useStyles from 'hooks/use-styles';
import {appMenuAtom} from 'atoms';
import Github from 'svg/github';
import pack from '../../../../package.json';


const AppMenuBase = (props: { children: React.ReactNode }) => {
    const theme = useTheme();
    const styles = useStyles();
    const {isMd} = useMediaBreakPoint();
    const [appMenu, setAppMenu] = useAtom(appMenuAtom);
    const location = useLocation();

    useEffect(() => {
        if (appMenu) {
            setAppMenu(false);
        }
    }, [location]);

    const isSmallScreen = !isMd;

    if (isSmallScreen && !appMenu) {
        return null;
    }

    return <Box sx={{
        height: '100%',
        width: styles.sideBarWidth,
        p: '0 16px',
        flexShrink: 0,
        flexGrow: 0,
        borderRight: `1px solid ${theme.palette.divider}`,
        display: 'flex',
        justifyContent: 'space-between',
    }}>
        <Box sx={{
            width: '100%',
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
        }}>
            <UserMenu/>
            <Box sx={{
                height: `calc(100% - calc(${styles.headerHeight} + ${styles.sideBarFooterHeight}))`,
                flexShrink: 0,
                ...styles.scrollY
            }}>
                {props.children}
            </Box>
            <Box sx={{
                height: styles.sideBarFooterHeight,
                pt: '10px',
                flexShrink: 0,
                display: 'flex',
                fontSize: '0.8em',
                marginBottom:'20px',
                color: theme.palette.text.disabled
            }}>
                {/* <button className='btn btn_success'
                style={{fontSize:'16px',fontWeight:'600'}}
                >Logout</button> */}
                {/* <Box sx={{mr: '20px'}}>{`NostrChat v${pack.version}`}</Box>
                <Box component="a" href="https://github.com/NostrChat/NostrChat" target="_blank" rel="noreferrer"
                     sx={{color: theme.palette.text.secondary}}>
                    <Github height={20} style={{marginRight: '4px'}}/>
                </Box> */}
            </Box>
        </Box>
    </Box>
}

export default AppMenuBase;
=== ./KeyDisplayDialog/index.tsx ===
// KeyDisplayDialog.tsx
import React from 'react';
import { 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions, 
  Button, 
  TextField
} from '@mui/material';
import { nip19 } from 'nostr-tools';

interface KeyDisplayDialogProps {
  open: boolean;
  onClose: () => void;
  publicKey: string;
  privateKey: string;
}

const KeyDisplayDialog: React.FC<KeyDisplayDialogProps> = ({ 
  open, 
  onClose, 
  publicKey, 
  privateKey 
}) => {
  const npub = nip19.npubEncode(publicKey);
  const nsec = nip19.nsecEncode(privateKey);

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle>Your Public and Private Keys</DialogTitle>
      <DialogContent>
        <p>Please write down these keys and store them securely. You will need them to recover your account.</p>
        <TextField
          margin="dense"
          label="Public Key (npub)"
          type="text"
          fullWidth
          value={npub}
          InputProps={{
            readOnly: true,
          }}
        />
        <TextField
          margin="dense"
          label="Private Key (nsec)"
          type="text"
          fullWidth
          value={nsec}
          InputProps={{
            readOnly: true,
          }}
        />
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>I've written down my keys</Button>
      </DialogActions>
    </Dialog>
  );
};

export default KeyDisplayDialog;=== ./storage/index.tsx ===
// @ts-nocheck

import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { Box, TextField, Button, List, ListItem, ListItemText, Typography, Select, MenuItem, FormControl, InputLabel, CircularProgress } from '@mui/material';
import { RouteComponentProps } from '@reach/router';
import { useAtom } from 'jotai';
import { directMessagesAtom, profilesAtom, ravenAtom } from 'atoms';
import { DirectContact } from 'types';
import { nip19 } from 'nostr-tools';
import { v4 as uuidv4 } from 'uuid';

interface StorageProps extends RouteComponentProps {}

interface Proposal {
  id: string;
  header: string;
  content: string;
  owner: string;
  modifiedAt?: Date;
  size?: number;
}

const Storage: React.FC<StorageProps> = (props) => {
  const [proposals, setProposals] = useState<Proposal[]>([]);
  const [newProposal, setNewProposal] = useState('');
  const [fileContent, setFileContent] = useState('');
  const [fileName, setFileName] = useState('');
  const [selectedContact, setSelectedContact] = useState<DirectContact | null>(null);
  const [fileIdToShare, setFileIdToShare] = useState('');
  const [fileIdToView, setFileIdToView] = useState('');
  const [directMessages] = useAtom(directMessagesAtom);
  const [profiles] = useAtom(profilesAtom);
  const [raven] = useAtom(ravenAtom);
  const [isUploading, setIsUploading] = useState(false);
  const [isDownloading, setIsDownloading] = useState(false);

  useEffect(() => {
    const savedProposals = JSON.parse(localStorage.getItem('proposals') || '[]') as Proposal[];
    setProposals(savedProposals);
  }, []);

  const generateFileId = (fileName: string): string => {
    const transactionId = uuidv4();
    const extension = fileName.split('.').pop() || '';
    const timestamp = Date.now();
    return `${transactionId}_${timestamp}.${extension}`;
  };

  const saveProposal = async () => {
    setIsUploading(true);
    try {
      const newId = generateFileId('manual_entry.txt');
      await axios.post('http://localhost:3001/upload', { content: newProposal, fileId: newId });
      const updatedProposals = [...proposals, { id: newId, header: 'Manual Entry', content: newProposal, owner: 'self' }];
      setProposals(updatedProposals);
      localStorage.setItem('proposals', JSON.stringify(updatedProposals));
      setNewProposal('');
    } catch (err) {
      console.error("Error saving proposal:", err);
      alert("Failed to save proposal. Please try again.");
    } finally {
      setIsUploading(false);
    }
  };

  const deleteProposal = async (id: string) => {
    try {
      await axios.delete(`http://localhost:3001/delete/${id}`);
      const updatedProposals = proposals.filter(proposal => proposal.id !== id);
      setProposals(updatedProposals);
      localStorage.setItem('proposals', JSON.stringify(updatedProposals));
    } catch (err) {
      console.error("Error deleting proposal:", err);
      alert("Failed to delete proposal. Please try again.");
    }
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file && file.type === 'text/plain') {
      setFileName(file.name);
      const reader = new FileReader();
      reader.onload = (e) => {
        const result = e.target?.result;
        if (typeof result === 'string') {
          setFileContent(result);
        }
      };
      reader.readAsText(file);
    } else {
      alert('Please upload a .txt file');
    }
  };

const saveFileContent = async () => {
  setIsUploading(true);
  try {
    const newId = generateFileId(fileName);
    const response = await axios.post('http://localhost:3001/upload', { 
      content: fileContent,  // Ensure this is a string
      fileId: newId 
    });
    console.log("Server response:", response.data);
    if (response.data.success) {
      const updatedProposals = [...proposals, { id: newId, header: fileName, content: fileContent, owner: 'self' }];
      setProposals(updatedProposals);
      localStorage.setItem('proposals', JSON.stringify(updatedProposals));
      setFileContent('');
      setFileName('');
    } else {
      throw new Error(response.data.error || "Unknown error occurred");
    }
  } catch (err) {
    console.error("Error saving file content:", err);
    alert(`Failed to save file content. ${err.response?.data?.error || err.message}`);
  } finally {
    setIsUploading(false);
  }
};

  const shareFile = async () => {
    if (selectedContact && fileIdToShare) {
      try {
        await raven?.sendDirectMessage(selectedContact.pub, `Shared file: ${fileIdToShare}`);
        console.log(`Sharing file ${fileIdToShare} with contact ${selectedContact.npub}`);
        alert("File shared successfully!");
      } catch (err) {
        console.error("Error sharing file:", err);
        alert("Failed to share file. Please try again.");
      }
    }
  };

  const viewSharedFile = async () => {
    setIsDownloading(true);
    const maxRetries = 3;
    let retries = 0;

    const attemptDownload = async () => {
      try {
        const response = await axios.get(`http://localhost:3001/download/${fileIdToView}`);
        console.log("Server response:", response.data);
        if (response.data.success) {
          const { fileInfo, content } = response.data;
          
          // Save the file as a shared file
          const newSharedFile: Proposal = {
            id: fileInfo.id,
            header: fileInfo.name,
            content: content,
            owner: 'shared', // or you could set this to the actual owner if available
            modifiedAt: new Date(fileInfo.modifiedAt),
            size: fileInfo.size
          };

          setProposals(prevProposals => [...prevProposals, newSharedFile]);
          
          // Update localStorage
          const updatedProposals = [...proposals, newSharedFile];
          localStorage.setItem('proposals', JSON.stringify(updatedProposals));

          alert(`File "${fileInfo.name}" has been saved as a shared file.`);
        } else {
          throw new Error(response.data.error || "Unknown error occurred");
        }
      } catch (err) {
        console.error("Error viewing shared file:", err);
        if (retries < maxRetries) {
          retries++;
          console.log(`Retrying download (attempt ${retries})`);
          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before retrying
          return attemptDownload();
        }
        let errorMessage = "Failed to view shared file. ";
        if (err.response && err.response.data) {
          errorMessage += err.response.data.error || "";
          console.error("Detailed error:", err.response.data);
        } else {
          errorMessage += err.message;
        }
        alert(errorMessage);
      }
    };

    await attemptDownload();
    setIsDownloading(false);
  };

  const uniqueContacts = Array.from(new Set(directMessages.map(dm => dm.peer)))
    .map(peer => ({
      pub: peer,
      npub: nip19.npubEncode(peer)
    }));

  console.log(proposals.filter(proposal => proposal.id));

  return (
    <Box sx={{ width: '100%', maxWidth: 600, mx: 'auto', mt: 4 }}>
      <Typography variant="h4" gutterBottom>Storage</Typography>
      
      <TextField
        label="New Proposal"
        value={newProposal}
        onChange={(e) => setNewProposal(e.target.value)}
        fullWidth
        margin="normal"
      />
      <Button 
        variant="contained" 
        onClick={saveProposal}
        disabled={isUploading}
      >
        {isUploading ? <CircularProgress size={24} /> : 'Save Proposal'}
      </Button>

      <Box sx={{ mt: 2 }}>
        <input
          type="file"
          accept=".txt"
          onChange={handleFileUpload}
        />
        <Button
          variant="contained"
          onClick={saveFileContent}
          disabled={!fileContent || isUploading}
          sx={{ mt: 1 }}
        >
          {isUploading ? <CircularProgress size={24} /> : 'Save File Content'}
        </Button>
      </Box>

      <Box sx={{ mt: 2 }}>
        <Typography variant="h6">Share File</Typography>
        <FormControl fullWidth sx={{ mt: 1 }}>
          <InputLabel>Select Contact</InputLabel>
          <Select
            value={selectedContact?.pub || ''}
            onChange={(e) => {
              const contact = uniqueContacts.find(c => c.pub === e.target.value);
              setSelectedContact(contact || null);
            }}
          >
            {uniqueContacts.map((contact) => (
              <MenuItem key={contact.pub} value={contact.pub}>
                {profiles.find(p => p.creator === contact.pub)?.name || contact.npub}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
        <TextField
          label="File ID to Share"
          value={fileIdToShare}
          onChange={(e) => setFileIdToShare(e.target.value)}
          fullWidth
          margin="normal"
        />
        <Button variant="contained" onClick={shareFile}>Share File</Button>
      </Box>

      <Box sx={{ mt: 2 }}>
        <Typography variant="h6">View Shared File</Typography>
        <TextField
          label="File ID to View"
          value={fileIdToView}
          onChange={(e) => setFileIdToView(e.target.value)}
          fullWidth
          margin="normal"
        />
        <Button 
          variant="contained" 
          onClick={viewSharedFile}
          disabled={isDownloading}
        >
          {isDownloading ? <CircularProgress size={24} /> : 'View Shared File'}
        </Button>
      </Box>

      <Typography variant="h6" sx={{ mt: 2 }}>Your Files</Typography>
      <List>
        {proposals.filter(p => p.owner === 'self').map(proposal => (
          <ListItem key={proposal.id}>
            <ListItemText
              primary={proposal.header}
              secondary={`ID: ${proposal.id}`}
            />
            <Button onClick={() => deleteProposal(proposal.id)}>Delete</Button>
          </ListItem>
        ))}
      </List>

    <Typography variant="h6" sx={{ mt: 2 }}>Shared Files</Typography>
    <List>
      {proposals.filter(p => p.owner === 'shared').map(proposal => (
        <ListItem key={proposal.id}>
          <ListItemText
            primary={proposal.header}
            secondary={`ID: ${proposal.id}, Size: ${proposal.size} bytes, Modified: ${proposal.modifiedAt?.toLocaleString()}`}
          />
          <Button onClick={() => alert(proposal.content)}>View Content</Button>
        </ListItem>
      ))}
    </List>
    </Box>
  );
};

export default Storage;=== ./mute-btn/index.tsx ===
import React from 'react';
import {useAtom} from 'jotai';
import useModal from 'hooks/use-modal';
import usePopover from 'hooks/use-popover';
import ConfirmDialog from 'components/confirm-dialog';
import {muteListAtom, ravenAtom} from 'atoms';

const MuteBtn = (props: { pubkey: string, children: JSX.Element, }) => {
    const {pubkey, children} = props;
    const [, showModal] = useModal();
    const [, showPopover] = usePopover();
    const [raven] = useAtom(ravenAtom);
    const [muteList] = useAtom(muteListAtom);

    const clicked = () => {
        showModal({
            body: <ConfirmDialog onConfirm={() => {
                raven?.updateMuteList([...muteList.pubkeys, pubkey]);
                showPopover(null);
            }}/>
        });
    }

    return React.cloneElement(children, {
        onClick: clicked
    });
}

export default MuteBtn;
=== ./dialogs/login/index.tsx ===
import React from 'react';
import DialogTitle from '@mui/material/DialogTitle';
import DialogContent from '@mui/material/DialogContent';

import CloseModal from 'components/close-modal';
import Login from 'views/components/login';
import useModal from 'hooks/use-modal';

const LoginDialog = (props: {  onDone: () => void }) => {
    const {onDone} = props;
    const [, showModal] = useModal();

    const handleClose = () => showModal(null);

    return (
        <>
            <DialogTitle><CloseModal onClick={handleClose}/></DialogTitle>
            <DialogContent>
                <Login onDone={onDone} />
            </DialogContent>
        </>
    );
}

export default LoginDialog;
=== ./dialogs/import-account/index.tsx ===
import React, { useState } from 'react';
import Button from '@mui/material/Button';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import { TextField } from '@mui/material';
import { nip06, nip19 } from 'nostr-tools';
import { DecodeResult } from 'nostr-tools/lib/nip19';

import CloseModal from 'components/close-modal';
import useModal from 'hooks/use-modal';
import useTranslation from 'hooks/use-translation';
import { toast } from 'react-toastify';

const ImportAccount = (props: {
  onSuccess: (key: string, type: 'pub' | 'priv') => void;
}) => {
  const { onSuccess } = props;
  const [, showModal] = useModal();
  const [t] = useTranslation();
  const [userKey, setUserKey] = useState('');
  const [isInvalid, setIsInvalid] = useState(false);
  const [seed, setSeed] = useState(false);
  const [seedText, setSeedText] = useState('');

  const handleClose = () => {
    showModal(null);
  };

  const handleSubmit = () => {
    if (seed) {
      try {
        const priv = nip06.privateKeyFromSeedWords(seedText);
        onSuccess(priv, 'priv');
      } catch (error: any) {
        if (error.message) {
          toast.error(error.message);
        } else {
          toast.error('Invalid Mnemonic or try later again !');
        }
      }
    } else {
      if (userKey.startsWith('nsec') || userKey.startsWith('npub')) {
        let dec: DecodeResult;
        try {
          dec = nip19.decode(userKey);
          console.log('decoded', dec);
        } catch (e) {
          setIsInvalid(true);
          return;
        }

        const key = dec.data as string;
        if (dec.type === 'nsec') {
          onSuccess(key, 'priv');
        } else if (dec.type === 'npub') {
          onSuccess(key, 'pub');
        } else {
          setIsInvalid(true);
        }
      } else {
        setIsInvalid(true);
      }
    }
  };

  const handleUserKeyChange = (
    e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    setUserKey(e.target.value);
    setIsInvalid(false);
  };

  return (
    <>
      <DialogTitle>
        {t('Import Account')}
        <CloseModal onClick={handleClose} />
      </DialogTitle>
      <DialogContent sx={{ pb: '0' }}>
        {!seed ? (
          <TextField
            fullWidth
            autoComplete="off"
            autoFocus
            value={userKey}
            onChange={handleUserKeyChange}
            placeholder={t('Enter nsec or npub')}
            error={isInvalid}
            helperText={isInvalid ? t('Invalid key') : ' '}
            inputProps={{
              autoCorrect: 'off',
            }}
            onKeyPress={e => {
              if (e.key === 'Enter') {
                handleSubmit();
              }
            }}
          />
        ) : (
          <TextField
            fullWidth
            autoComplete="off"
            autoFocus
            value={seedText}
            onChange={e => setSeedText(e.target.value)}
            placeholder={t('Enter  mnemonic seed phrase')}
            error={isInvalid}
            helperText={isInvalid ? t('Invalid mnemonic') : ' '}
            inputProps={{
              autoCorrect: 'off',
            }}
            onKeyPress={e => {
              if (e.key === 'Enter') {
                handleSubmit();
              }
            }}
          />
        )}
      </DialogContent>
      <DialogActions style={{ padding: '0 23px', margin: '30px 0 ' }}>
        <div className="flex_2s" style={{ width: '100%' }}>
          <button className="btn btn_primary" onClick={e => setSeed(!seed)}>
            {!seed ? t('Login by Seed Phrase') : t('Login by nsec or npub')}
          </button>
          <button className="btn btn_success" onClick={handleSubmit}>
            {t('Submit')}
          </button>
        </div>
      </DialogActions>
    </>
  );
};

export default ImportAccount;
=== ./dialogs/join-channel/index.tsx ===
import React, {useState} from 'react';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import Box from '@mui/material/Box';
import TextField from '@mui/material/TextField';
import Button from '@mui/material/Button';

import CloseModal from 'components/close-modal';
import useModal from 'hooks/use-modal';
import useTranslation from 'hooks/use-translation';
import {isSha256} from 'util/crypto';


const JoinChannel = (props: { onSuccess: (id: string) => void }) => {
    const {onSuccess} = props;
    const [, showModal] = useModal();
    const [t] = useTranslation();
    const [id, setID] = useState('');
    const [error, setError] = useState('');

    const handleClose = () => {
        showModal(null);
    };

    const idChanged = (e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>) => {
        setID(e.target.value);
    };

    const submit = () => {
        setError('');
        if (!isSha256(id)) {
            setError(t('Invalid id'));
            return;
        }
        onSuccess(id);
    }

    return (
        <>
            <DialogTitle>{t('Join a Proposal')}<CloseModal onClick={handleClose}/></DialogTitle>
            <DialogContent>
                <Box sx={{pt: '6px'}}>
                    <TextField label={t('Enter Proposal ID')} value={id} onChange={idChanged} fullWidth autoFocus
                               error={!!error} helperText={error || ' '}/>
                    <Box sx={{display: 'flex', justifyContent: 'flex-end'}}>
                        <Button variant="contained" onClick={submit}>{t('Go')}</Button>
                    </Box>
                </Box>
            </DialogContent>
        </>
    );
}

export default JoinChannel;
=== ./dialogs/profile/index.tsx ===
import {useAtom} from 'jotai';
import React, {useEffect, useMemo, useState} from 'react';
import Box from '@mui/material/Box';
import {useTheme} from '@mui/material/styles';
import IconButton from '@mui/material/IconButton';
import Tooltip from '@mui/material/Tooltip';
import DialogContent from '@mui/material/DialogContent';
import {nip05, nip19} from 'nostr-tools';
import useTranslation from 'hooks/use-translation';
import useModal from 'hooks/use-modal';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import CloseModal from 'components/close-modal';
import CopyToClipboard from 'components/copy-clipboard';
import Avatar from 'views/components/avatar';
import MuteBtn from 'views/components/mute-btn';
import DmInput from 'views/components/dm-input';
import {keysAtom} from 'atoms';
import {Profile} from 'types';
import KeyVariant from 'svg/key-variant';
import EyeOff from 'svg/eye-off';
import CheckDecagram from 'svg/check-decagram';
import {truncate, truncateMiddle} from 'util/truncate';

const ProfileDialog = (props: { profile?: Profile | null, pubkey: string, onDM: () => void }) => {
    const { profile, pubkey, onDM } = props;
    const [keys] = useAtom(keysAtom);
    const theme = useTheme();
    const [t] = useTranslation();
    const [, showModal] = useModal();
    const {isSm} = useMediaBreakPoint();
    const [nip05Verified, setNip05Verified] = useState<boolean>(false);

    const profileName = useMemo(() => profile?.name ? truncateMiddle(profile.name, 22, ':') : null, [profile]);
    const pub = useMemo(() => nip19.npubEncode(pubkey), [pubkey]);
    const isMe = keys?.pub === pubkey;

    const boxSx = {
        position: 'absolute',
        top: '4px',
        zIndex: 2,
        padding: '3px',
        borderRadius: theme.shape.borderRadius,
        background: theme.palette.background.paper,
        width: '36px',
        height: '36px',
    };

    useEffect(() => {
        if (!profile?.nip05) return;
        nip05.queryProfile(profile.nip05).then((resp) => {
            setNip05Verified(resp?.pubkey === profile.creator);
        })
    }, [profile]);

    const handleClose = () => {
        showModal(null);
    };

    return <>
        <DialogContent>
            <CloseModal onClick={handleClose}/>
            <Box sx={{fontSize: '0.8em'}}>
                <Box sx={{
                    mb: '10px',
                    display: 'flex',
                    position: 'relative',
                    height: '200px',
                    width: '200px',
                    margin: 'auto'
                }}>
                    {nip05Verified && (
                        <Box sx={{...boxSx, left: '4px'}}>
                            <Tooltip title={t('NIP-05 verified')}>
                                <Box sx={{
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    height: '100%',
                                }}>
                                    <CheckDecagram height={18}/>
                                </Box>
                            </Tooltip>
                        </Box>
                    )}
                    {!isMe && (<Box sx={{...boxSx, right: '4px'}}>
                        <Tooltip title={t('Mute')}>
                            <Box>
                                <MuteBtn pubkey={pubkey}>
                                    <IconButton><EyeOff height={14}/></IconButton>
                                </MuteBtn>
                            </Box>
                        </Tooltip>
                    </Box>)}
                    <Box sx={{
                        position: 'absolute',
                        left: 0,
                        top: 0,
                        zIndex: 1
                    }}>
                        <Avatar src={profile?.picture} seed={pubkey} size={200}/>
                    </Box>
                </Box>
                <Box sx={{textAlign: 'center', mt: '12px'}}>
                    {profileName && (<Box sx={{mb: '10px', fontWeight: 600, fontSize: '1.2em'}}>{profileName}</Box>)}
                    {profile?.about && (
                        <Box sx={{
                            mb: '10px',
                            wordBreak: 'break-word',
                            lineHeight: '1.4em',
                            color: theme.palette.text.secondary
                        }}>{truncate(profile.about, 160)}</Box>
                    )}
                    <CopyToClipboard copy={pub}>
                        <Box sx={{
                            mb: '16px',
                            fontSize: '0.9em',
                            color: theme.palette.text.secondary,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            cursor: 'pointer'
                        }}>
                            <Box sx={{
                                mr: '4px',
                                display: 'flex',
                                color: theme.palette.warning.main
                            }}><KeyVariant height={14}/></Box>
                            {truncateMiddle(pub, (isSm ? 46 : 36), ':')}
                        </Box>
                    </CopyToClipboard>
                </Box>
                {!isMe && (<DmInput pubkey={pubkey} onDM={onDM}/>)}
            </Box>
        </DialogContent>
    </>;
}

export default ProfileDialog;=== ./dialogs/create-channel/index.tsx ===
import React from 'react';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import Box from '@mui/material/Box';
import {useAtom} from 'jotai';

import CloseModal from 'components/close-modal';
import useModal from 'hooks/use-modal';
import useToast from 'hooks/use-toast';
import useTranslation from 'hooks/use-translation';
import MetadataForm from 'views/components/metadata-form';
import {ravenAtom} from 'atoms';

const CreateChannel = (props: { onSuccess: (id: string) => void }) => {
    const {onSuccess} = props;
    const [, showModal] = useModal();
    const [, showMessage] = useToast();
    const [t] = useTranslation();
    const [raven] = useAtom(ravenAtom);

    const handleClose = () => {
        showModal(null);
    };

    return (
        <>
            <DialogTitle>{t('Create Proposal')}<CloseModal onClick={handleClose}/></DialogTitle>
            <DialogContent>
                <Box sx={{pt: '6px'}}>
                    <MetadataForm submitBtnLabel='Submit' skipButton={<span/>} labels={{
                        name: 'Channel name',
                        about: 'Description',
                        picture: 'Channel picture'
                    }} onSubmit={(data) => {
                        console.log("Data at proposal creation", data);
                        raven?.createChannel(data).then((ev) => {
                            onSuccess(ev.id);
                        }).catch((e) => {
                            showMessage(e.toString(), 'error');
                        });
                    }}/>
                </Box>
            </DialogContent>
        </>
    );
}

export default CreateChannel;
=== ./dialogs/start-dm/index.tsx ===
import React, {useState} from 'react';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import Box from '@mui/material/Box';
import TextField from '@mui/material/TextField';
import Button from '@mui/material/Button';
import {nip19} from 'nostr-tools';

import CloseModal from 'components/close-modal';
import useModal from 'hooks/use-modal';
import useTranslation from 'hooks/use-translation';


const StartDM = (props: { onSuccess: (npub: string) => void }) => {
    const {onSuccess} = props;
    const [, showModal] = useModal();
    const [t] = useTranslation();
    const [npub, setNpub] = useState('');
    const [error, setError] = useState('');

    const handleClose = () => {
        showModal(null);
    };

    const idChanged = (e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>) => {
        setNpub(e.target.value);
    };

    const submit = () => {
        setError('');
        let decoded;
        try {
            decoded = nip19.decode(npub)
        } catch (_) {
            setError(t('Invalid npub'));
            return;
        }

        if (decoded.type !== 'npub') {
            setError(t('Invalid npub'));
            return;
        }

        onSuccess(npub);
    }

    return (
        <>
            <DialogTitle>{t('Direct Message')}<CloseModal onClick={handleClose}/></DialogTitle>
            <DialogContent>
                <Box sx={{pt: '6px'}}>
                    <TextField label={t('npub')} value={npub} onChange={idChanged} fullWidth autoFocus
                               error={!!error} helperText={error || ' '}/>
                    <Box sx={{display: 'flex', justifyContent: 'flex-end'}}>
                        <Button variant="contained" onClick={submit}>{t('Go')}</Button>
                    </Box>
                </Box>
            </DialogContent>
        </>
    );
}

export default StartDM;
=== ./dialogs/no-wallet/nip07.tsx ===
import React from 'react';
import DialogTitle from '@mui/material/DialogTitle';
import DialogContent from '@mui/material/DialogContent';
import {DialogContentText} from '@mui/material';
import DialogActions from '@mui/material/DialogActions';
import Button from '@mui/material/Button';
import Box from '@mui/material/Box';
import Link from '@mui/material/Link';

import CloseModal from 'components/close-modal';
import useTranslation from 'hooks/use-translation';
import useModal from 'hooks/use-modal';


export const InstallNip07Dialog = () => {
    const [t] = useTranslation();
    const [, showModal] = useModal();

    const handleClose = () => {
        showModal(null);
    };

    return (
        <>
            <DialogTitle>{t('No NIP-07 wallet found!')}
                <CloseModal onClick={handleClose}/>
            </DialogTitle>
            <DialogContent>
                <DialogContentText>
                   <Box component="p"> {t('Please install one of the following wallets to continue.')}</Box>
                    <ul>
                        <li><Link target="_blank" rel="noreferrer"  href="https://github.com/fiatjaf/nos2x">nos2x</Link> <small>(Chrome and derivatives)</small></li>
                        <li><Link target="_blank" rel="noreferrer"  href="https://getalby.com/">Alby</Link> <small>(Chrome and derivatives, Firefox, Safari)</small></li>
                        <li><Link target="_blank" rel="noreferrer"  href="https://www.blockcore.net/wallet">Blockcore</Link> <small>(Chrome and derivatives)</small></li>
                        <li><Link target="_blank" rel="noreferrer"  href="https://diegogurpegui.com/nos2x-fox/">nos2x-fox</Link> <small>(Firefox)</small></li>
                        <li><Link target="_blank" rel="noreferrer"  href="https://www.getflamingo.org/">Flamingo</Link> <small>(Chrome and derivatives)</small></li>
                    </ul>
                </DialogContentText>
            </DialogContent>
            <DialogActions>
                <Button variant="contained" onClick={handleClose}>{t('Dismiss')}</Button>
            </DialogActions>
        </>
    );
};
=== ./profile-card/index.tsx ===
import React, {useEffect, useMemo, useState} from 'react';
import {useAtom} from 'jotai';
import {nip05, nip19} from 'nostr-tools';
import Box from '@mui/material/Box';
import Divider from '@mui/material/Divider';
import Button from '@mui/material/Button';
import Paper from '@mui/material/Paper';
import Tooltip from '@mui/material/Tooltip';
import {useTheme} from '@mui/material/styles';
import CopyToClipboard from 'components/copy-clipboard';
import DmInput from 'views/components/dm-input';
import Avatar from 'views/components/avatar';
import useTranslation from 'hooks/use-translation';
import useStyles from 'hooks/use-styles';
import KeyVariant from 'svg/key-variant';
import {Profile} from 'types';
import {keysAtom} from 'atoms';
import CheckDecagram from 'svg/check-decagram';
import {truncate} from 'util/truncate';

const ProfileCard = (props: { profile: Profile, pub: string, onDM: () => void }) => {
    const {profile, pub, onDM} = props;
    const theme = useTheme();
    const [t] = useTranslation();
    const [keys] = useAtom(keysAtom);
    const styles = useStyles();
    const [nip05Verified, setNip05Verified] = useState<boolean>(false);

    const npub = useMemo(() => nip19.npubEncode(pub), [pub]);
    const isMe = keys?.pub === pub;

    useEffect(() => {
        if (!profile?.nip05) return;
        nip05.queryProfile(profile.nip05).then((resp) => {
            setNip05Verified(resp?.pubkey === profile.creator);
        })
    }, [profile]);

    return <Paper sx={{textAlign: 'center', p: '20px'}}>
        <Box sx={{mb: '10px'}}>
            <Avatar src={profile?.picture} seed={pub} size={140} rounded/>
        </Box>
        {(profile.name || nip05Verified) && (<Box sx={{
            fontFamily: 'Faktum, sans-serif',
            fontSize: '1.1em',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center'
        }}>
            {profile.name ? truncate(profile.name, 60) : ''}
            {nip05Verified && (<Tooltip title={t('NIP-05 verified')}>
                    <Box sx={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        ml: '6px'
                    }}>
                        <CheckDecagram height={18}/>
                    </Box>
                </Tooltip>
            )}
        </Box>)}
        {profile.about && (
            <>
                <Divider sx={{m: '12px 0'}}/>
                <Box sx={{
                    color: theme.palette.text.secondary,
                    fontSize: '0.9em',
                }}>{truncate(profile.about, 360)}</Box>
            </>
        )}
        <CopyToClipboard copy={pub}>
            <Box sx={{
                m: '16px 0',
                fontSize: '0.9em',
                display: 'flex',
                alignItems: 'center',
                cursor: 'pointer',
                minWidth: '0'
            }}>
                <Box sx={{
                    mr: '4px',
                    display: 'flex',
                    color: theme.palette.warning.main
                }}><KeyVariant height={14}/></Box>
                <Box sx={{
                    color: theme.palette.primary.dark,
                    fontSize: '0.9em',
                    ...styles.ellipsis
                }}>{npub}</Box>
            </Box>
        </CopyToClipboard>
        {(() => {
            if (isMe) return null;
            if (!keys) return <Button variant="contained" size="small" onClick={onDM}>{t('Login to send DM')}</Button>;
            return <DmInput pubkey={pub} onDM={onDM}/>;
        })()}
    </Paper>
}

export default ProfileCard;
=== ./app-menu/default-channel-list.tsx ===
import React, { useEffect, useState } from 'react';
import { useLocation } from '@reach/router';
import { useAtom } from 'jotai';
import { Box } from '@mui/material';
import { useTheme } from '@mui/material/styles';

import useTranslation from 'hooks/use-translation';
import useLiveChannels from 'hooks/use-live-channels';
import useLivePublicMessages from 'hooks/use-live-public-messages';
import ChannelAddMenu from 'views/components/app-menu/channel-add-menu';
import ListItem from 'views/components/app-menu/list-item';
import { channelAtom, keysAtom, ravenAtom, readMarkMapAtom } from 'atoms';
import { CiFileOff } from 'react-icons/ci';
import { Channel } from 'types';
import useToast from 'hooks/use-toast';
import { PROPOSAL_TYPES, proposalTypes, votingPeriod } from 'util/constant';
import { isTimeRemaining } from 'util/function';

import FilterProposalDropdown from './FilterProposalDropdown';

const ChannelListItem = (props: { c: Channel }) => {
  const { c } = props;

  const location = useLocation();
  const messages = useLivePublicMessages(c.id);
  const [readMarkMap] = useAtom(readMarkMapAtom);
  const [channel] = useAtom(channelAtom);
  const [keys] = useAtom(keysAtom);

  const lMessage = messages[messages.length - 1];
  const hasUnread =
    keys?.priv !== 'none' &&
    !!(readMarkMap[c.id] && lMessage && lMessage.created > readMarkMap[c.id]);

  const isSelected =
    c.id === channel?.id && location.pathname.startsWith('/channel/');

  return (
    <>
      {c.id ==
      'f412192fdc846952c75058e911d37a7392aa7fd2e727330f4344badc92fb8a22' ? (
        ''
      ) : (
        <ListItem
          key={c.id}
          label={c.name}
          href={`/channel/${c.id}`}
          selected={isSelected}
          hasUnread={hasUnread}
        />
      )}
    </>
  );
};

/*
Mostr
Ephemeral Relays
Public and private AI profiles for version control
Marketplace
Smart contract
NewLaw/Everyone is right/Force for peace
Withdrawal Rights/Disclaimer/ Privacy standards 
Embedded application 
Multi ID system 
If you don't rate, you can't be rated.
Privacy, scalability,  security,  transparency,  decentralization,  and identification.
Autotranslate
*/

const permanentProposals = [
        {
          name: 'Mostr',
          about: '{"problem":"Lack of connection between Fediverse and Nostr","solution":"","targetAudience":"","qualifications":"","purpose":"A platform feature enabling dynamic and flexible presentation of content.","approach":"A platform feature enabling dynamic and flexible presentation of content.","outcome":"A platform feature enabling dynamic and flexible presentation of content.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Ephemeral Relays',
          about: '{"problem":"Need for temporary communication channels","solution":"","targetAudience":"","qualifications":"","purpose":"Temporary communication channels that expire after a set duration.","approach":"Temporary communication channels that expire after a set duration.","outcome":"Temporary communication channels that expire after a set duration.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Public and private AI profiles for version control',
          about: '{"problem":"Lack of version control for AI profiles","solution":"","targetAudience":"","qualifications":"","purpose":"Profiles that manage and track changes in AI models and datasets.","approach":"Profiles that manage and track changes in AI models and datasets.","outcome":"Profiles that manage and track changes in AI models and datasets.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Marketplace',
          about: '{"problem":"Need for a decentralized marketplace","solution":"","targetAudience":"","qualifications":"","purpose":"A decentralized marketplace for trading goods and services.","approach":"A decentralized marketplace for trading goods and services.","outcome":"A decentralized marketplace for trading goods and services.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Smart contract',
          about: '{"problem":"Need for automated and self-executing contracts","solution":"","targetAudience":"","qualifications":"","purpose":"Automated and self-executing contracts with predefined rules.","approach":"Automated and self-executing contracts with predefined rules.","outcome":"Automated and self-executing contracts with predefined rules.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'NewLaw/Everyone is right/Force for peace',
          about: '{"problem":"Need for a fair governance system","solution":"","targetAudience":"","qualifications":"","purpose":"A governance system promoting universal fairness and conflict resolution.","approach":"A governance system promoting universal fairness and conflict resolution.","outcome":"A governance system promoting universal fairness and conflict resolution.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Withdrawal Rights/Disclaimer/ Privacy standards',
          about: '{"problem":"Need for user rights and privacy policies","solution":"","targetAudience":"","qualifications":"","purpose":"User rights and privacy policies ensuring data protection and transparency.","approach":"User rights and privacy policies ensuring data protection and transparency.","outcome":"User rights and privacy policies ensuring data protection and transparency.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Embedded application',
          about: '{"problem":"Need for seamless application integration","solution":"","targetAudience":"","qualifications":"","purpose":"Integration of applications directly within the platform for seamless user experience.","approach":"Integration of applications directly within the platform for seamless user experience.","outcome":"Integration of applications directly within the platform for seamless user experience.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Multi ID system',
          about: '{"problem":"Need for secure management of multiple identities","solution":"","targetAudience":"","qualifications":"","purpose":"A system allowing users to manage multiple identities securely.","approach":"A system allowing users to manage multiple identities securely.","outcome":"A system allowing users to manage multiple identities securely.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: "If you don't rate, you can't be rated.",
          about: '{"problem":"Lack of user participation in ratings","solution":"","targetAudience":"","qualifications":"","purpose":"A feedback system encouraging user participation in ratings.","approach":"A feedback system encouraging user participation in ratings.","outcome":"A feedback system encouraging user participation in ratings.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Privacy, scalability, security, transparency, decentralization, and identification.',
          about: '{"problem":"Need for core platform principles","solution":"","targetAudience":"","qualifications":"","purpose":"Core principles guiding platform development and operations.","approach":"Core principles guiding platform development and operations.","outcome":"Core principles guiding platform development and operations.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Autotranslate',
          about: '{"problem":"Need for multilingual support","solution":"","targetAudience":"","qualifications":"","purpose":"Automatic translation feature for multilingual support.","approach":"Automatic translation feature for multilingual support.","outcome":"Automatic translation feature for multilingual support.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
      ];

const AllProposalChannelListItem = (props: { c: any }) => {
  const { c } = props;

  const location = useLocation();
  const messages = useLivePublicMessages(c.id);
  const [readMarkMap] = useAtom(readMarkMapAtom);
  const [channel] = useAtom(channelAtom);
  const [keys] = useAtom(keysAtom);

  const lMessage = messages[messages.length - 1];
  const hasUnread =
    keys?.priv !== 'none' &&
    !!(readMarkMap[c.id] && lMessage && lMessage.created > readMarkMap[c.id]);

  const isSelected =
    c.id === channel?.id && location.pathname.startsWith('/channel/');


  return (
    <>
      {typeof c === 'object' && c.id && c.name ? (
        <div>
          <ListItem
            key={c.id}
            label={c.name}
            href={`/channel/${encodeURIComponent(JSON.stringify({ name: c.name, id: c.id }))}`}
            selected={isSelected}
            hasUnread={hasUnread}
          />
        </div>
      ) : (
        <div>
          <ListItem
            key={c.id}
            label={JSON.parse(c.content).name}
            href={`/channel/${JSON.parse(JSON.parse(c.content).about).proposalID}`}
            selected={isSelected}
            hasUnread={hasUnread}
          />
        </div>
      )}
    </>
  );
};

const ChannelList = () => {
  const theme = useTheme();
  const [t] = useTranslation();
  const channels = useLiveChannels();
  const [raven] = useAtom(ravenAtom);
  const [allProposal, setAllProposal] = useState<any>([]);
  const [fetchedAllProposal, setFetchedAllProposal] = useState<any>([]);
  const [filterType, setfilterType] = useState(PROPOSAL_TYPES.all);
  const [, showMessage] = useToast();

  useEffect(() => {
  const init = async () => {
    const allProposal = await raven?.fetchAllProposal();
    console.log("allprops", allProposal);
    setFetchedAllProposal(allProposal);
    if (filterType === PROPOSAL_TYPES.all) {
      setAllProposal(allProposal);
    } else {
      filterProposalsByTime();
    }
  };
  init();
}, []);

  useEffect(() => {
    console.log(filterType);
    const init = async () => {
      filterProposalsByTime();
    };
    init();
  }, [filterType]);

  function filterProposalsByTime(  ) {
    let filteredProposals = [];
    if (filterType === PROPOSAL_TYPES.active) {
      filteredProposals = fetchedAllProposal.filter((proposal: any) => {
        console.log(proposal.created_at, votingPeriod)
        return !isTimeRemaining(proposal.created_at , votingPeriod);
      });
    } else if (filterType === PROPOSAL_TYPES.expired) {
      filteredProposals = fetchedAllProposal.filter((proposal: any) => {
        return isTimeRemaining(proposal.created_at, votingPeriod);
      });
    } else if (filterType === PROPOSAL_TYPES.all) {
      filteredProposals = fetchedAllProposal;
    }

    setAllProposal(filteredProposals);
  }
  return (
    <>
      <div>
        <Box
          sx={{
            mt: '10px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
          }}
        >
          <Box
            sx={{
              fontFamily: 'Faktum, sans-serif',
              fontWeight: 'bold',
              color: theme.palette.primary.dark,
            }}
          >
            <h3 onClick={async e => console.log('p...', channels)}>
              {t('Proposal History')}
            </h3>
          </Box>
          <ChannelAddMenu />
        </Box>
        <hr />
        {(() => {
          if (channels.length === 1) {
            return (
              <Box
                component="span"
                sx={{
                  color: theme.palette.primary.dark,
                  fontSize: '85%',
                  opacity: '0.6',
                }}
              >
                <h4 className="text-center">
                  {t('No Proposal Finded')} <CiFileOff />
                </h4>
              </Box>
            );
          } else {
            return channels.map(c => <ChannelListItem key={c.id} c={c} />);
          }
        })()}
      </div>

      <div>
        <Box
          sx={{
            mt: '50px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
          }}
        >
          <Box
            sx={{
              fontFamily: 'Faktum, sans-serif',
              fontWeight: 'bold',
              color: theme.palette.primary.dark,
            }}
          >
            <h3 onClick={e => console.log(allProposal)}>
              {t(`${filterType} Proposal `)}
            </h3>
          </Box>
          <FilterProposalDropdown proposalTypeSetter={setfilterType} />
        </Box>

        {(() => {
  if (!allProposal || allProposal.length === 0) {
    return (
      <Box
        component="span"
        sx={{
          color: theme.palette.primary.dark,
          fontSize: '85%',
          opacity: '0.6',
        }}
      >
        <h4 className="text-center">
          {t('No Proposal Found')} <CiFileOff />
        </h4>
      </Box>
    );
  } else {
    return allProposal.map((c: any) => (
      <>
        <AllProposalChannelListItem key={c.id} c={c} />
      </>
    ));
  }
})()}
      </div>
    </>
  );
};

export default ChannelList;=== ./app-menu/dm-list.tsx ===
import React, { useState, useMemo } from 'react';
import { Box, Button } from '@mui/material';
import { useTheme } from '@mui/material/styles';
import { useAtom } from 'jotai';
import { useLocation, useNavigate } from '@reach/router';
import useTranslation from 'hooks/use-translation';
import ListItem from 'views/components/app-menu/list-item';
import StartDM from 'views/components/dialogs/start-dm'; // Ensure this import is correct
import useLiveDirectContacts from 'hooks/use-live-direct-contacts';
import useLiveDirectMessages from 'hooks/use-live-direct-messages';
import useModal from 'hooks/use-modal'; // Ensure this import is correct
import { directMessageAtom, directMessagesAtom, keysAtom, profilesAtom, readMarkMapAtom, showRequestsAtom, ravenAtom } from 'atoms';
import Plus from 'svg/plus';
import { DirectContact } from 'types';
import { truncateMiddle } from 'util/truncate';

const DmListItem = (props: { contact: DirectContact, onAddUserClick: (contact: DirectContact) => void, isDmRequest: boolean }) => {
    const { contact, onAddUserClick, isDmRequest } = props;
    const navigate = useNavigate();
    const [profiles] = useAtom(profilesAtom);
    const [directMessage] = useAtom(directMessageAtom);
    const [readMarkMap] = useAtom(readMarkMapAtom);
    const [keys] = useAtom(keysAtom);
    const location = useLocation();
    const messages = useLiveDirectMessages(contact.pub);

    const lMessage = messages[messages.length - 1];
    const hasUnread = keys?.priv !== 'none' && !!(readMarkMap[contact.pub] && lMessage && lMessage.created > readMarkMap[contact.pub]);

    const profile = profiles.find(x => x.creator === contact.pub);
    const label = profile?.name || truncateMiddle(contact.npub, 28, ':');
    const isSelected = contact.pub === directMessage && location.pathname.startsWith('/dm/');

    const handleItemClick = () => {
        if (isDmRequest) {
            onAddUserClick(contact);
        } else {
            navigate(`/dm/${contact.npub}`);
        }
    };

    return (
        <div onClick={handleItemClick}>
            <ListItem 
                label={label} 
                href={isDmRequest ? '#' : `/dm/${contact.npub}`}
                selected={isSelected} 
                hasUnread={hasUnread}
            />
        </div>
    );
}


const DmList = () => {
    const theme = useTheme();
    const [showInviteePopup, setShowInviteePopup] = useState(false);
    const [t] = useTranslation();
    const directContacts = useLiveDirectContacts();
    const [, showModal] = useModal();
    const navigate = useNavigate();
    const [directMessages] = useAtom(directMessagesAtom);
    const [showRequests, setShowRequests] = useAtom(showRequestsAtom);
    const [showPopup, setShowPopup] = useState(false);
    const [selectedContact, setSelectedContact] = useState<DirectContact | null>(null);
    const [isSendingRequest, setIsSendingRequest] = useState(false);
    const [raven] = useAtom(ravenAtom);

    const switchShowRequests = () => {
        setShowRequests(!showRequests);
    }

    const search = () => {
        showModal({
            body: <StartDM onSuccess={(id) => {
                showModal(null);
                navigate(`/dm/${id}`).then();
            }} />
        })
    }

const handleAddUserClick = (contact: DirectContact, sendingRequest: boolean = false) => {
    console.log("Selected contact: ", contact); // Debug log
    setSelectedContact(contact);
    setIsSendingRequest(sendingRequest);
    setShowPopup(true);
};

    const handleConfirmDMRequest = () => {
    setShowPopup(false);
    // Logic to add the user and send the confirmation message
    if (selectedContact) {
        // Add the user to the contact list
        const newContact: DirectContact = {
            pub: selectedContact.pub,
            npub: selectedContact.npub,
        };
        const updatedDirectContacts = [...directContacts, newContact];
        const updatedRequests = requests.filter(r => r.pub !== selectedContact.pub);
        
        // Update the directContacts and requests state or perform any necessary state management
        // For example, if using a state management library like Redux:
        // dispatch(updateDirectContacts(updatedDirectContacts));
        // dispatch(updateRequests(updatedRequests));

        // Check if raven is defined before sending the confirmation message
        if (raven) {
            raven.sendDirectMessage(selectedContact.pub, "This DM has been accepted!");
            // Navigate to the DM page after sending the message
            navigate(`/dm/${selectedContact.npub}`);
        } else {
            // Show an error message to the user and prevent navigation
            alert("Unable to send confirmation message. Please try again later.");
            console.error("Raven is undefined, unable to send message.");
        }
    }
};

    const handleConfirm = () => {
        setShowPopup(false);
        search(); // Show the StartDM component after confirmation
    };

    const handleCancel = () => {
        setShowPopup(false);
        setSelectedContact(null);
    };

const combinedSearchAndAddUser = (contact: DirectContact) => {
    handleAddUserClick(contact, true); // For sending a request
};


    const handleInviteeConfirm = () => {
        setShowInviteePopup(false);
    };

    const handleInviteeCancel = () => {
        setShowInviteePopup(false);
    };

    const requests = useMemo(() => directContacts.filter(d => directMessages.find(m => m.peer === d.pub && m.creator !== d.pub) === undefined), [directContacts, directMessages]);
    const dmList = useMemo(() => directContacts.filter(d => requests.find(r => r.pub === d.pub) === undefined), [directContacts, requests]);

    const popupStyles = {
        position: 'fixed' as 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        background: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 2000, // Ensure this is higher than the "direct message" box
    };

    const popupContentStyles = {
        background: 'black',
        padding: '20px',
        borderRadius: '10px',
        textAlign: 'center' as 'center',
        maxWidth: '600px',
        width: '100%',
        zIndex: 2100, // Ensure this is higher than the "direct message" box
    };

    const buttonStyles = {
        margin: '10px',
        padding: '10px 20px',
        border: 'none',
        backgroundColor: '#007BFF',
        color: 'white',
        cursor: 'pointer',
        borderRadius: '5px',
        fontSize: '16px',
    };

    const buttonHoverStyles = {
        backgroundColor: '#0056b3',
    };

    return <>
        {showPopup && (  // Ensure the popup is rendered before the rest of the content
            <div style={popupStyles}>
                <div style={popupContentStyles}>
                    <h2>{t('Confirmation of Connection')}</h2>
                    <p>{t('Before proceeding with connecting to another user on this platform, please carefully read and acknowledge the following:')}</p>
                    <p><strong>{t('Important:')}</strong></p>
                    <ul>
                        <li>{t('By choosing to connect, you affirm that you have a personal acquaintance with the user you wish to connect with.')}</li>
                        <li>{t('You may be required to verify your acquaintance with the other user at any time. Failure to provide satisfactory identification when requested may lead to the assumption that you own or control the other user\'s account.')}</li>
                        <li>{t('You must confirm that you have not requested, offered, initiated, or accepted any form of payment in relation to establishing this connection.')}</li>
                    </ul>
                    <p>{t('Please indicate your confirmation that you personally know the user you wish to connect with and that no payment has been requested, offered, initiated, or accepted in association with this connection.')}</p>
                    <button 
    style={buttonStyles} 
    onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = buttonHoverStyles.backgroundColor)} 
    onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = buttonStyles.backgroundColor)} 
    onClick={isSendingRequest ? handleConfirm : handleConfirmDMRequest}>
    {t('I Confirm')}
</button>
<button 
    style={buttonStyles} 
    onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = buttonHoverStyles.backgroundColor)} 
    onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = buttonStyles.backgroundColor)} 
    onClick={handleCancel}>
    {t('Cancel')}
</button>
                </div>
            </div>
        )}

        <Box sx={{
            mt: '40px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between'
        }}>
            <Box sx={{
                fontFamily: 'Faktum, sans-serif',
                fontWeight: 'bold',
                color: theme.palette.primary.dark,
            }}>
                {showRequests ? t('DM Requests') : t('DM Contacts')}
            </Box>
<button onClick={() => combinedSearchAndAddUser(selectedContact!)} className='btn btn_success btn_sm'>
    <span>+</span>  Add User
</button>

        </Box>

        {!showRequests && requests.length > 0 && (
            <Box sx={{ m: '12px 0' }}>
                <Button size='small' onClick={switchShowRequests}>
                    {t(requests.length === 1 ? '{{n}} DM request' : '{{n}} DM requests', { n: requests.length })}
                </Button>
            </Box>
        )}

        {showRequests && (
            <Box sx={{ m: '12px 0' }}>
                <Button size='small' onClick={switchShowRequests}>
                    {t('< Back to DMs')}
                </Button>
            </Box>
        )}

        {(() => {
            const theList = showRequests ? requests : dmList;

            if (theList.length === 0) {
                return <Box component='span' sx={{
                    color: theme.palette.primary.dark,
                    fontSize: '85%',
                    opacity: '0.6',
                }}>{t('No direct message')}</Box>
            }

            return theList.map(p => (
                <div key={p.npub}>
                    <DmListItem contact={p} onAddUserClick={handleAddUserClick} isDmRequest={showRequests} />
                </div>
            ));
        })()}
    </>
}

export default DmList;
=== ./app-menu/list-item.tsx ===
import React from 'react';
import {useNavigate} from '@reach/router';
import Box from '@mui/material/Box';
import {useTheme} from '@mui/material/styles';

const ListItem = (props: { label: React.ReactNode, href: string, selected: boolean, hasUnread?: boolean }) => {
    const navigate = useNavigate();
    const theme = useTheme();

    return <Box component="a" href={props.href} onClick={(e) => {
        e.preventDefault();
        navigate(props.href).then();
    }} sx={{
        height: '40px',
        display: 'flex',
        alignItems: 'center',
        fontSize: '15px',
        position: 'relative',
        zIndex: 0,
        fontWeight: props.hasUnread ? 'bold' : null,
        color: theme.palette.text.primary,
        textDecoration: 'none',
        pl: '10px',
        ':before': {
            content: "''",
            position: 'absolute',
            top: '12px',
            left: '0',
            width: '4px',
            height: '16px',
            borderRadius:  theme.shape.borderRadius,
            background: theme.palette.primary.main,
            display: props.selected ? null : 'none'
        },
        ':hover': {
            ':before': {display: 'inline-block'}
        }
    }}>
        <Box sx={{
            overflow: 'hidden',
            whiteSpace: 'nowrap',
        }}>{props.label}</Box>
    </Box>;
}

export default ListItem;
=== ./app-menu/user-menu.tsx ===
import React from 'react';
import {useAtom} from 'jotai';
import {useNavigate} from '@reach/router';
import {Box} from '@mui/material';
import {useTheme} from '@mui/material/styles';
import {nip19} from 'nostr-tools';

import Avatar from 'views/components/avatar';
import useStyles from 'hooks/use-styles';
import {keysAtom, profileAtom} from 'atoms';
import {truncateMiddle} from 'util/truncate';


const UserMenu = () => {
    const [profile] = useAtom(profileAtom);
    const theme = useTheme();
    const styles = useStyles();
    const [keys] = useAtom(keysAtom);
    const navigate = useNavigate();

    if (!keys) {
        return null;
    }

    const clicked = () => {
        navigate('/settings').then();
    }

    return <Box sx={{
        height: styles.headerHeight,
        display: 'flex',
        alignItems: 'center',
        flexShrink: 0
    }}>
        <Box sx={{
            display: 'flex',
            alignItems: 'center',
            flexGrow: 1,
            background: theme.palette.divider,
            borderRadius: theme.shape.borderRadius,
            cursor: 'pointer',
            transition: 'background-color 100ms linear',
            border: '1px solid transparent',
            ':hover': {
                background: 'transparent',
                border: `1px solid ${theme.palette.divider}`
            }
        }} onClick={clicked}>
            <Box sx={{mr: '8px', display: 'flex'}}>
                <Avatar src={profile?.picture} seed={keys.pub} size={42} rounded/>
            </Box>
            {(() => {

                const sx = {
                    whiteSpace: 'nowrap',
                    overflow: 'hidden',
                    width: '184px',
                    mr: '6px',
                }

                if (profile?.name) {
                    return <Box sx={{
                        ...sx,
                        fontFamily: 'Faktum, sans-serif',
                        fontWeight: 'bold',

                    }}>{profile.name || ''}</Box>
                }

                return <Box sx={{
                    ...sx,
                    fontSize: '90%',
                    color: theme.palette.primary.dark,
                    opacity: '0.6',
                }}>{truncateMiddle(nip19.npubEncode(keys.pub), 20, ':')}</Box>
            })()}
        </Box>
    </Box>
}

export default UserMenu;
=== ./app-menu/index.tsx ===
import React, { useState } from 'react';
import ChannelList from 'views/components/app-menu/channel-list';
import DmList from 'views/components/app-menu/dm-list';
import AppMenuBase from 'views/components/app-menu-base';
import { useRecoilValue } from 'recoil';
import { userState } from 'state/userState';
import { Link, navigate } from '@reach/router';

const AppMenu = () => {
  const getUserState: any = useRecoilValue(userState);
  const [showPopup, setShowPopup] = useState(false);

  const handleNostrClick = (e: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {
    e.preventDefault();
    setShowPopup(true);
  };

  const handleContinue = () => {
    setShowPopup(false);
    navigate('/home');
  };

  const handleCancel = () => {
    setShowPopup(false);
  };

  const popupStyles = {
    position: 'fixed' as 'fixed',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    background: 'rgba(0, 0, 0, 0.5)',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  };

  const popupContentStyles = {
    background: 'black',
    padding: '20px',
    borderRadius: '10px',
    textAlign: 'center' as 'center',
    maxWidth: '400px',
    width: '100%',
  };

  const buttonStyles = {
    margin: '10px',
    padding: '10px 20px',
    border: 'none',
    backgroundColor: '#007BFF',
    color: 'white',
    cursor: 'pointer',
    borderRadius: '5px',
    fontSize: '16px',
  };

  const buttonHoverStyles = {
    backgroundColor: '#0056b3',
  };

  return (
    <AppMenuBase>
      <div className="custom_items">
        <Link to="/">Home</Link>
        <a href="/home" onClick={handleNostrClick}>Nostr</a>
        <Link to="/settings/profile">Profile</Link>
        <Link to="/settings/keys">Keys & Wallet</Link>
        <Link to="/marketplace">Marketplace</Link>
        <Link to="/storage">Storage</Link>
        <Link to="/calendar">Calendar</Link>
        <Link to="/relay">Relay (Admin Only!)</Link>
      </div>
      {/* <ChannelList /> */}
      <DmList />
      {showPopup && (
        <div style={popupStyles}>
          <div style={popupContentStyles}>
            <h2>Warning: Age-Restricted Content Ahead</h2>
            <p>
              You are about to enter a section of this site that is restricted to individuals 18 years of age and older. 
              This area contains content that may be inappropriate for underage users.
            </p>
            <button 
              style={buttonStyles} 
              onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = buttonHoverStyles.backgroundColor)} 
              onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = buttonStyles.backgroundColor)} 
              onClick={handleContinue}>
                I confirm that I am at least 18 years old
            </button>
            <button 
              style={buttonStyles} 
              onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = buttonHoverStyles.backgroundColor)} 
              onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = buttonStyles.backgroundColor)} 
              onClick={handleCancel}>
                I am under the age of 18
            </button>
          </div>
        </div>
      )}
    </AppMenuBase>
  );
};

export default AppMenu;=== ./app-menu/channel-add-menu.tsx ===
import React, {useState} from 'react';
import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import Button from '@mui/material/Button';
import {useNavigate} from '@reach/router';

import CreateChannel from 'views/components/dialogs/create-channel';
import JoinChannel from 'views/components/dialogs/join-channel';
import useTranslation from 'hooks/use-translation';
import useModal from 'hooks/use-modal';
import Plus from 'svg/plus';

const ChannelAddMenu = () => {
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const navigate = useNavigate();
    const open = Boolean(anchorEl);
    const [t] = useTranslation();
    const [, showModal] = useModal();

    const openMenu = (event: React.MouseEvent<HTMLButtonElement>) => {
        setAnchorEl(event.currentTarget);
    };

    const closeMenu = () => {
        setAnchorEl(null);
    };

    const create = () => {
        showModal({
            body: <CreateChannel onSuccess={(id) => {
                showModal(null);
                navigate(`/channel/${id}`).then();
            }}/>
        })

        closeMenu();
    }

    const join = () => {
        showModal({
            body: <JoinChannel onSuccess={(id) => {
                showModal(null);
                navigate(`/channel/${id}`).then();
            }}/>
        })

        closeMenu();
    }

    return <>
        <button onClick={openMenu}  className='btn btn_success'><Plus height={18}/> New Proposal</button>
        <Menu anchorEl={anchorEl} open={open} onClose={closeMenu}>
            <MenuItem dense onClick={create}>{t('Create a New Proposal')}</MenuItem>
            <MenuItem dense onClick={join}>{t('Join in a Proposal')}</MenuItem>
        </Menu>
    </>
}

export default ChannelAddMenu;=== ./app-menu/FilterProposalDropdown.tsx ===
import * as React from 'react';
import { styled, alpha } from '@mui/material/styles';
import Button from '@mui/material/Button';
import Menu, { MenuProps } from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import Divider from '@mui/material/Divider';
import { IoMdArrowDropdown } from 'react-icons/io';
import { PROPOSAL_TYPES } from 'util/constant';

const StyledMenu = styled((props: MenuProps) => (
  <Menu
    elevation={0}
    anchorOrigin={{
      vertical: 'bottom',
      horizontal: 'right',
    }}
    transformOrigin={{
      vertical: 'top',
      horizontal: 'right',
    }}
    {...props}
  />
))(({ theme }) => ({
  '& .MuiPaper-root': {
    borderRadius: 6,
    marginTop: theme.spacing(1),
    minWidth: 180,
    color:
      theme.palette.mode === 'light'
        ? 'rgb(55, 65, 81)'
        : theme.palette.grey[300],
    boxShadow:
      'rgb(255, 255, 255) 0px 0px 0px 0px, rgba(0, 0, 0, 0.05) 0px 0px 0px 1px, rgba(0, 0, 0, 0.1) 0px 10px 15px -3px, rgba(0, 0, 0, 0.05) 0px 4px 6px -2px',
    '& .MuiMenu-list': {
      padding: '4px 0',
    },
    '& .MuiMenuItem-root': {
      '& .MuiSvgIcon-root': {
        fontSize: 18,
        color: theme.palette.text.secondary,
        marginRight: theme.spacing(1.5),
      },
      '&:active': {
        backgroundColor: alpha(
          theme.palette.primary.main,
          theme.palette.action.selectedOpacity
        ),
      },
    },
  },
}));

export default function FilterProposalDropdown({
  proposalTypeSetter,
}: {
  proposalTypeSetter: any;
}) {
  const [anchorEl, setAnchorEl] = React.useState<null | HTMLElement>(null);
  const open = Boolean(anchorEl);
  const handleClick = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };
  const handleClose = (type: any) => {
    setAnchorEl(null);
    if (type==PROPOSAL_TYPES.active || type== PROPOSAL_TYPES.all || type== PROPOSAL_TYPES.expired) {
      proposalTypeSetter(type);
    }
  };

  return (
    <div>
      <button
        className="btn btn_primary"
        id="demo-customized-button"
        aria-controls={open ? 'demo-customized-menu' : undefined}
        aria-haspopup="true"
        aria-expanded={open ? 'true' : undefined}
        onClick={handleClick}
      >
        Filter Proposal
        <IoMdArrowDropdown />
      </button>
      <StyledMenu
        id="demo-customized-menu"
        MenuListProps={{
          'aria-labelledby': 'demo-customized-button',
        }}
        anchorEl={anchorEl}
        open={open}
        onClose={handleClose}
      >
        <MenuItem onClick={e=>handleClose(PROPOSAL_TYPES.all)} disableRipple>
          All Proposal
        </MenuItem>
        <Divider sx={{ my: 0.5 }} />
        <MenuItem  onClick={e=>handleClose(PROPOSAL_TYPES.active)}  disableRipple>
          Active Proposal
        </MenuItem>
        <MenuItem  onClick={e=>handleClose(PROPOSAL_TYPES.expired)}  disableRipple>
          Closed Proposal
        </MenuItem>
      </StyledMenu>
    </div>
  );
}
=== ./app-menu/channel-list.tsx ===
import React, { useEffect, useState } from 'react';
import { useLocation } from '@reach/router';
import { useAtom } from 'jotai';
import { Box, CircularProgress } from '@mui/material';
import { useTheme } from '@mui/material/styles';

import useTranslation from 'hooks/use-translation';
import useLiveChannels from 'hooks/use-live-channels';
import useLivePublicMessages from 'hooks/use-live-public-messages';
import ChannelAddMenu from 'views/components/app-menu/channel-add-menu';
import ListItem from 'views/components/app-menu/list-item';
import { channelAtom, keysAtom, ravenAtom, readMarkMapAtom } from 'atoms';
import { CiFileOff } from 'react-icons/ci';
import { Channel } from 'types';
import useToast from 'hooks/use-toast';
import { PROPOSAL_TYPES, permVotingPeriod, votingPeriod } from 'util/constant';
import { isTimeRemaining } from 'util/function';

import FilterProposalDropdown from './FilterProposalDropdown';

const isPermanentProposal = (proposalName: string) => {
  return permanentProposalsList.some((proposal) => proposal.name === proposalName);
};

const permanentProposalsList = [
  {
    name: 'Mostr',
    about: '{"problem":"Lack of connection between Fediverse and Nostr","solution":"","targetAudience":"","qualifications":"","purpose":"A platform feature enabling dynamic and flexible presentation of content.","approach":"A platform feature enabling dynamic and flexible presentation of content.","outcome":"A platform feature enabling dynamic and flexible presentation of content.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Ephemeral Relays',
    about: '{"problem":"Need for temporary communication channels","solution":"","targetAudience":"","qualifications":"","purpose":"Temporary communication channels that expire after a set duration.","approach":"Temporary communication channels that expire after a set duration.","outcome":"Temporary communication channels that expire after a set duration.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Public and private AI profiles for version control',
    about: '{"problem":"Lack of version control for AI profiles","solution":"","targetAudience":"","qualifications":"","purpose":"Profiles that manage and track changes in AI models and datasets.","approach":"Profiles that manage and track changes in AI models and datasets.","outcome":"Profiles that manage and track changes in AI models and datasets.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Marketplace',
    about: '{"problem":"Need for a decentralized marketplace","solution":"","targetAudience":"","qualifications":"","purpose":"A decentralized marketplace for trading goods and services.","approach":"A decentralized marketplace for trading goods and services.","outcome":"A decentralized marketplace for trading goods and services.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Smart contract',
    about: '{"problem":"Need for automated and self-executing contracts","solution":"","targetAudience":"","qualifications":"","purpose":"Automated and self-executing contracts with predefined rules.","approach":"Automated and self-executing contracts with predefined rules.","outcome":"Automated and self-executing contracts with predefined rules.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'NewLaw/Everyone is right/Force for peace',
    about: '{"problem":"Need for a fair governance system","solution":"","targetAudience":"","qualifications":"","purpose":"A governance system promoting universal fairness and conflict resolution.","approach":"A governance system promoting universal fairness and conflict resolution.","outcome":"A governance system promoting universal fairness and conflict resolution.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Withdrawal Rights/Disclaimer/ Privacy standards',
    about: '{"problem":"Need for user rights and privacy policies","solution":"","targetAudience":"","qualifications":"","purpose":"User rights and privacy policies ensuring data protection and transparency.","approach":"User rights and privacy policies ensuring data protection and transparency.","outcome":"User rights and privacy policies ensuring data protection and transparency.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Embedded application',
    about: '{"problem":"Need for seamless application integration","solution":"","targetAudience":"","qualifications":"","purpose":"Integration of applications directly within the platform for seamless user experience.","approach":"Integration of applications directly within the platform for seamless user experience.","outcome":"Integration of applications directly within the platform for seamless user experience.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Multi ID system',
    about: '{"problem":"Need for secure management of multiple identities","solution":"","targetAudience":"","qualifications":"","purpose":"A system allowing users to manage multiple identities securely.","approach":"A system allowing users to manage multiple identities securely.","outcome":"A system allowing users to manage multiple identities securely.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: "If you don't rate, you can't be rated.",
    about: '{"problem":"Lack of user participation in ratings","solution":"","targetAudience":"","qualifications":"","purpose":"A feedback system encouraging user participation in ratings.","approach":"A feedback system encouraging user participation in ratings.","outcome":"A feedback system encouraging user participation in ratings.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Privacy, scalability, security, transparency, decentralization, and identification.',
    about: '{"problem":"Need for core platform principles","solution":"","targetAudience":"","qualifications":"","purpose":"Core principles guiding platform development and operations.","approach":"Core principles guiding platform development and operations.","outcome":"Core principles guiding platform development and operations.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Autotranslate',
    about: '{"problem":"Need for multilingual support","solution":"","targetAudience":"","qualifications":"","purpose":"Automatic translation feature for multilingual support.","approach":"Automatic translation feature for multilingual support.","outcome":"Automatic translation feature for multilingual support.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
];

const ChannelListItem = (props: { c: Channel }) => {
  const { c } = props;

  const location = useLocation();
  const messages = useLivePublicMessages(c.id);
  const [readMarkMap] = useAtom(readMarkMapAtom);
  const [channel] = useAtom(channelAtom);
  const [keys] = useAtom(keysAtom);

  const lMessage = messages[messages.length - 1];
  const hasUnread =
    keys?.priv !== 'none' &&
    !!(readMarkMap[c.id] && lMessage && lMessage.created > readMarkMap[c.id]);

  const isSelected =
    c.id === channel?.id && location.pathname.startsWith('/channel/');

  return (
    <>
      {c.id === 'f412192fdc846952c75058e911d37a7392aa7fd2e727330f4344badc92fb8a22' ? (
        ''
      ) : (
        <ListItem
          key={c.id}
          label={c.name}
          href={`/channel/${c.id}`}
          selected={isSelected}
          hasUnread={hasUnread}
        />
      )}
    </>
  );
};

const permanentProposals = [
  {
    name: 'Mostr',
    about: '{"problem":"Lack of connection between Fediverse and Nostr","solution":"","targetAudience":"","qualifications":"","purpose":"A platform feature enabling dynamic and flexible presentation of content.","approach":"A platform feature enabling dynamic and flexible presentation of content.","outcome":"A platform feature enabling dynamic and flexible presentation of content.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Ephemeral Relays',
    about: '{"problem":"Need for temporary communication channels","solution":"","targetAudience":"","qualifications":"","purpose":"Temporary communication channels that expire after a set duration.","approach":"Temporary communication channels that expire after a set duration.","outcome":"Temporary communication channels that expire after a set duration.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Public and private AI profiles for version control',
    about: '{"problem":"Lack of version control for AI profiles","solution":"","targetAudience":"","qualifications":"","purpose":"Profiles that manage and track changes in AI models and datasets.","approach":"Profiles that manage and track changes in AI models and datasets.","outcome":"Profiles that manage and track changes in AI models and datasets.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Marketplace',
    about: '{"problem":"Need for a decentralized marketplace","solution":"","targetAudience":"","qualifications":"","purpose":"A decentralized marketplace for trading goods and services.","approach":"A decentralized marketplace for trading goods and services.","outcome":"A decentralized marketplace for trading goods and services.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Smart contract',
    about: '{"problem":"Need for automated and self-executing contracts","solution":"","targetAudience":"","qualifications":"","purpose":"Automated and self-executing contracts with predefined rules.","approach":"Automated and self-executing contracts with predefined rules.","outcome":"Automated and self-executing contracts with predefined rules.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'NewLaw/Everyone is right/Force for peace',
    about: '{"problem":"Need for a fair governance system","solution":"","targetAudience":"","qualifications":"","purpose":"A governance system promoting universal fairness and conflict resolution.","approach":"A governance system promoting universal fairness and conflict resolution.","outcome":"A governance system promoting universal fairness and conflict resolution.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Withdrawal Rights/Disclaimer/ Privacy standards',
    about: '{"problem":"Need for user rights and privacy policies","solution":"","targetAudience":"","qualifications":"","purpose":"User rights and privacy policies ensuring data protection and transparency.","approach":"User rights and privacy policies ensuring data protection and transparency.","outcome":"User rights and privacy policies ensuring data protection and transparency.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Embedded application',
    about: '{"problem":"Need for seamless application integration","solution":"","targetAudience":"","qualifications":"","purpose":"Integration of applications directly within the platform for seamless user experience.","approach":"Integration of applications directly within the platform for seamless user experience.","outcome":"Integration of applications directly within the platform for seamless user experience.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Multi ID system',
    about: '{"problem":"Need for secure management of multiple identities","solution":"","targetAudience":"","qualifications":"","purpose":"A system allowing users to manage multiple identities securely.","approach":"A system allowing users to manage multiple identities securely.","outcome":"A system allowing users to manage multiple identities securely.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: "If you don't rate, you can't be rated.",
    about: '{"problem":"Lack of user participation in ratings","solution":"","targetAudience":"","qualifications":"","purpose":"A feedback system encouraging user participation in ratings.","approach":"A feedback system encouraging user participation in ratings.","outcome":"A feedback system encouraging user participation in ratings.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Privacy, scalability, security, transparency, decentralization, and identification.',
    about: '{"problem":"Need for core platform principles","solution":"","targetAudience":"","qualifications":"","purpose":"Core principles guiding platform development and operations.","approach":"Core principles guiding platform development and operations.","outcome":"Core principles guiding platform development and operations.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
  {
    name: 'Autotranslate',
    about: '{"problem":"Need for multilingual support","solution":"","targetAudience":"","qualifications":"","purpose":"Automatic translation feature for multilingual support.","approach":"Automatic translation feature for multilingual support.","outcome":"Automatic translation feature for multilingual support.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
    picture: '',
  },
];

const AllProposalChannelListItem = (props: { c: any }) => {
  const { c } = props;

  const location = useLocation();
  const messages = useLivePublicMessages(c.id);
  const [readMarkMap] = useAtom(readMarkMapAtom);
  const [channel] = useAtom(channelAtom);
  const [keys] = useAtom(keysAtom);

  const lMessage = messages[messages.length - 1];
  const hasUnread =
    keys?.priv !== 'none' &&
    !!(readMarkMap[c.id] && lMessage && lMessage.created > readMarkMap[c.id]);

  const isSelected =
    c.id === channel?.id && location.pathname.startsWith('/channel/');

  let label, href;
  if (typeof c === 'object' && c.id && c.name) {
    label = c.name;
    href = `/channel/${encodeURIComponent(JSON.stringify({ name: c.name, id: c.id }))}`;
  } else {
    try {
      const parsedContent = JSON.parse(c.content);
      label = parsedContent.name;
      href = `/channel/${JSON.parse(parsedContent.about).proposalID}`;
    } catch (e) {
      console.error('Failed to parse proposal content:', e);
      return null;
    }
  }

  return (
    <div>
      <ListItem
        key={c.id}
        label={label}
        href={href}
        selected={isSelected}
        hasUnread={hasUnread}
      />
    </div>
  );
};

const proposalExists = (proposals: any[] | undefined, name: string) => {
  return proposals?.some((proposal) => {
    try {
      return JSON.parse(proposal.content).name === name;
    } catch (e) {
      console.error('Failed to parse proposal content:', e);
      return false;
    }
  }) || false;
};

const ChannelList = () => {
  const theme = useTheme();
  const [t] = useTranslation();
  const channels = useLiveChannels();
  const [raven] = useAtom(ravenAtom);
  const [allProposal, setAllProposal] = useState<any[]>([]);
  const [fetchedAllProposal, setFetchedAllProposal] = useState<any[]>([]);
  const [permanentProposalList, setPermanentProposalList] = useState<any[]>([]);
  const [filterType, setfilterType] = useState(PROPOSAL_TYPES.all);
  const [, showMessage] = useToast();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const init = async () => {
      try {
        setIsLoading(true);
        const allProposal = await raven?.fetchAllProposal();
        console.log('allprops', allProposal);
        setFetchedAllProposal(allProposal || []);
        if (filterType === PROPOSAL_TYPES.all) {
          setAllProposal(allProposal || []);
        } else {
          filterProposalsByTime();
        }

        const permanentProposalsArray = [];

        for (const proposal of permanentProposals) {
          if (!proposalExists(allProposal, proposal.name)) {
            const newProposal = await raven?.createChannel(proposal);
            if (newProposal) permanentProposalsArray.push(newProposal);
          } else {
            const existingProposal = allProposal?.find((p) => {
              try {
                return JSON.parse(p.content).name === proposal.name;
              } catch (e) {
                console.error('Failed to parse proposal content:', e);
                return false;
              }
            });
            if (existingProposal) {
              permanentProposalsArray.push(existingProposal);
            }
          }
        }

        setPermanentProposalList(permanentProposalsArray);

        console.log('All proposals:', allProposal);
        console.log('All fetched proposals:', fetchedAllProposal);
        console.log('Permanent proposals:', permanentProposalsArray);
      } catch (err) {
        console.error('Error initializing proposals:', err);
        setError(err instanceof Error ? err : new Error('An unknown error occurred'));
      } finally {
        setIsLoading(false);
      }
    };
    init();
  }, [filterType, raven]);

  useEffect(() => {
    console.log(filterType);
    filterProposalsByTime();
  }, [filterType, fetchedAllProposal]);

  function filterProposalsByTime() {
    let filteredProposals = [];
    if (filterType === PROPOSAL_TYPES.active) {
      filteredProposals = fetchedAllProposal.filter((proposal: any) => {
        console.log(proposal.created_at, isPermanentProposal(proposal.name) ? permVotingPeriod : votingPeriod);
        return !isTimeRemaining(proposal.created_at, isPermanentProposal(proposal.name) ? permVotingPeriod : votingPeriod);
      });
    } else if (filterType === PROPOSAL_TYPES.expired) {
      filteredProposals = fetchedAllProposal.filter((proposal: any) => {
        return isTimeRemaining(proposal.created_at, isPermanentProposal(proposal.name) ? permVotingPeriod : votingPeriod);
      });
    } else if (filterType === PROPOSAL_TYPES.all) {
      filteredProposals = fetchedAllProposal;
    }

    setAllProposal(filteredProposals);
  }

  if (isLoading) return <CircularProgress />;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <>
      {/* Proposal History section */}
      <div>
        <Box sx={{ mt: '10px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Box sx={{ fontFamily: 'Faktum, sans-serif', fontWeight: 'bold', color: theme.palette.primary.dark }}>
            <h3 onClick={() => console.log('p...', channels)}>{t('Proposal History')}</h3>
          </Box>
          <ChannelAddMenu />
        </Box>
        <hr />
        {channels.length <= 1 ? (
          <Box component="span" sx={{ color: theme.palette.primary.dark, fontSize: '85%', opacity: '0.6' }}>
            <h4 className="text-center">{t('No Proposal Found')} <CiFileOff /></h4>
          </Box>
        ) : (
          channels.map((c) => <ChannelListItem key={c.id} c={c} />)
        )}
      </div>

      {/* All Proposals section */}
      <div>
        <Box sx={{ mt: '50px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Box sx={{ fontFamily: 'Faktum, sans-serif', fontWeight: 'bold', color: theme.palette.primary.dark }}>
            <h3 onClick={() => console.log(allProposal)}>{t(`${filterType} Proposal `)}</h3>
          </Box>
          <FilterProposalDropdown proposalTypeSetter={setfilterType} />
        </Box>

        {!allProposal || allProposal.length === 0 ? (
          <Box component="span" sx={{ color: theme.palette.primary.dark, fontSize: '85%', opacity: '0.6' }}>
            <h4 className="text-center">{t('No Proposal Found')} <CiFileOff /></h4>
          </Box>
        ) : (
          allProposal.map((c: any, index: number) => (
            <AllProposalChannelListItem key={c?.id ?? index} c={c} />
          ))
        )}
      </div>

      {/* Permanent Proposals section */}
      <div>
        <Box sx={{ mt: '50px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Box sx={{ fontFamily: 'Faktum, sans-serif', fontWeight: 'bold', color: theme.palette.primary.dark }}>
            <h3 onClick={() => console.log(permanentProposalList)}>{t('Permanent Proposals')}</h3>
          </Box>
        </Box>

        {!permanentProposalList || permanentProposalList.length === 0 ? (
          <Box component="span" sx={{ color: theme.palette.primary.dark, fontSize: '85%', opacity: '0.6' }}>
            <h4 className="text-center">{t('No Permanent Proposal Found')} <CiFileOff /></h4>
          </Box>
        ) : (
          permanentProposalList.map((c: any, index: number) => (
            <AllProposalChannelListItem key={c?.id ?? index} c={c} />
          ))
        )}
      </div>
    </>
  );
};

export default ChannelList;=== ./app-menu/old-channel-list.tsx ===
import React, { useEffect, useState } from 'react';
import { useLocation } from '@reach/router';
import { useAtom } from 'jotai';
import { Box } from '@mui/material';
import { useTheme } from '@mui/material/styles';

import useTranslation from 'hooks/use-translation';
import useLiveChannels from 'hooks/use-live-channels';
import useLivePublicMessages from 'hooks/use-live-public-messages';
import ChannelAddMenu from 'views/components/app-menu/channel-add-menu';
import ListItem from 'views/components/app-menu/list-item';
import { channelAtom, keysAtom, ravenAtom, readMarkMapAtom } from 'atoms';
import { CiFileOff } from 'react-icons/ci';
import { Channel } from 'types';
import useToast from 'hooks/use-toast';
import { PROPOSAL_TYPES, proposalTypes, votingPeriod } from 'util/constant';
import { isTimeRemaining } from 'util/function';

import FilterProposalDropdown from './FilterProposalDropdown';

const ChannelListItem = (props: { c: Channel }) => {
  const { c } = props;

  const location = useLocation();
  const messages = useLivePublicMessages(c.id);
  const [readMarkMap] = useAtom(readMarkMapAtom);
  const [channel] = useAtom(channelAtom);
  const [keys] = useAtom(keysAtom);

  const lMessage = messages[messages.length - 1];
  const hasUnread =
    keys?.priv !== 'none' &&
    !!(readMarkMap[c.id] && lMessage && lMessage.created > readMarkMap[c.id]);

  const isSelected =
    c.id === channel?.id && location.pathname.startsWith('/channel/');

  return (
    <>
      {c.id ==
      'f412192fdc846952c75058e911d37a7392aa7fd2e727330f4344badc92fb8a22' ? (
        ''
      ) : (
        <ListItem
          key={c.id}
          label={c.name}
          href={`/channel/${c.id}`}
          selected={isSelected}
          hasUnread={hasUnread}
        />
      )}
    </>
  );
};

/*
Mostr
Ephemeral Relays
Public and private AI profiles for version control
Marketplace
Smart contract
NewLaw/Everyone is right/Force for peace
Withdrawal Rights/Disclaimer/ Privacy standards 
Embedded application 
Multi ID system 
If you don't rate, you can't be rated.
Privacy, scalability,  security,  transparency,  decentralization,  and identification.
Autotranslate
*/

const AllProposalChannelListItem = (props: { c: any }) => {
  const { c } = props;

  const location = useLocation();
  const messages = useLivePublicMessages(c.id);
  const [readMarkMap] = useAtom(readMarkMapAtom);
  const [channel] = useAtom(channelAtom);
  const [keys] = useAtom(keysAtom);

  const lMessage = messages[messages.length - 1];
  const hasUnread =
    keys?.priv !== 'none' &&
    !!(readMarkMap[c.id] && lMessage && lMessage.created > readMarkMap[c.id]);

  const isSelected =
    c.id === channel?.id && location.pathname.startsWith('/channel/');


  return (
    <>
      {typeof c === 'object' && c.id && c.name ? (
        <div>
          <ListItem
            key={c.id}
            label={c.name}
            href={`/channel/${encodeURIComponent(JSON.stringify({ name: c.name, id: c.id }))}`}
            selected={isSelected}
            hasUnread={hasUnread}
          />
        </div>
      ) : (
        <div>
          <ListItem
            key={c.id}
            label={JSON.parse(c.content).name}
            href={`/channel/${JSON.parse(JSON.parse(c.content).about).proposalID}`}
            selected={isSelected}
            hasUnread={hasUnread}
          />
        </div>
      )}
    </>
  );
};

const proposalExists = (proposals: any[] | undefined, name: string) => {
  return proposals?.some((proposal) => JSON.parse(proposal.content).name === name) || false;
};

const ChannelList = () => {
  const theme = useTheme();
  const [t] = useTranslation();
  const channels = useLiveChannels();
  const [raven] = useAtom(ravenAtom);
  const [allProposal, setAllProposal] = useState<any>([]);
  const [fetchedAllProposal, setFetchedAllProposal] = useState<any>([]);
  const [filterType, setfilterType] = useState(PROPOSAL_TYPES.all);
  const [, showMessage] = useToast();

  useEffect(() => {
  const init = async () => {
    const allProposal = await raven?.fetchAllProposal();
    console.log("allprops", allProposal);
    setFetchedAllProposal(allProposal);
    if (filterType === PROPOSAL_TYPES.all) {
      setAllProposal(allProposal);
    } else {
      filterProposalsByTime();
    }

      const permanentProposals = [
        {
          name: 'Mostr',
          about: '{"problem":"Lack of connection between Fediverse and Nostr","solution":"","targetAudience":"","qualifications":"","purpose":"A platform feature enabling dynamic and flexible presentation of content.","approach":"A platform feature enabling dynamic and flexible presentation of content.","outcome":"A platform feature enabling dynamic and flexible presentation of content.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Ephemeral Relays',
          about: '{"problem":"Need for temporary communication channels","solution":"","targetAudience":"","qualifications":"","purpose":"Temporary communication channels that expire after a set duration.","approach":"Temporary communication channels that expire after a set duration.","outcome":"Temporary communication channels that expire after a set duration.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Public and private AI profiles for version control',
          about: '{"problem":"Lack of version control for AI profiles","solution":"","targetAudience":"","qualifications":"","purpose":"Profiles that manage and track changes in AI models and datasets.","approach":"Profiles that manage and track changes in AI models and datasets.","outcome":"Profiles that manage and track changes in AI models and datasets.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Marketplace',
          about: '{"problem":"Need for a decentralized marketplace","solution":"","targetAudience":"","qualifications":"","purpose":"A decentralized marketplace for trading goods and services.","approach":"A decentralized marketplace for trading goods and services.","outcome":"A decentralized marketplace for trading goods and services.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Smart contract',
          about: '{"problem":"Need for automated and self-executing contracts","solution":"","targetAudience":"","qualifications":"","purpose":"Automated and self-executing contracts with predefined rules.","approach":"Automated and self-executing contracts with predefined rules.","outcome":"Automated and self-executing contracts with predefined rules.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'NewLaw/Everyone is right/Force for peace',
          about: '{"problem":"Need for a fair governance system","solution":"","targetAudience":"","qualifications":"","purpose":"A governance system promoting universal fairness and conflict resolution.","approach":"A governance system promoting universal fairness and conflict resolution.","outcome":"A governance system promoting universal fairness and conflict resolution.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Withdrawal Rights/Disclaimer/ Privacy standards',
          about: '{"problem":"Need for user rights and privacy policies","solution":"","targetAudience":"","qualifications":"","purpose":"User rights and privacy policies ensuring data protection and transparency.","approach":"User rights and privacy policies ensuring data protection and transparency.","outcome":"User rights and privacy policies ensuring data protection and transparency.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Embedded application',
          about: '{"problem":"Need for seamless application integration","solution":"","targetAudience":"","qualifications":"","purpose":"Integration of applications directly within the platform for seamless user experience.","approach":"Integration of applications directly within the platform for seamless user experience.","outcome":"Integration of applications directly within the platform for seamless user experience.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Multi ID system',
          about: '{"problem":"Need for secure management of multiple identities","solution":"","targetAudience":"","qualifications":"","purpose":"A system allowing users to manage multiple identities securely.","approach":"A system allowing users to manage multiple identities securely.","outcome":"A system allowing users to manage multiple identities securely.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: "If you don't rate, you can't be rated.",
          about: '{"problem":"Lack of user participation in ratings","solution":"","targetAudience":"","qualifications":"","purpose":"A feedback system encouraging user participation in ratings.","approach":"A feedback system encouraging user participation in ratings.","outcome":"A feedback system encouraging user participation in ratings.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Privacy, scalability, security, transparency, decentralization, and identification.',
          about: '{"problem":"Need for core platform principles","solution":"","targetAudience":"","qualifications":"","purpose":"Core principles guiding platform development and operations.","approach":"Core principles guiding platform development and operations.","outcome":"Core principles guiding platform development and operations.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
        {
          name: 'Autotranslate',
          about: '{"problem":"Need for multilingual support","solution":"","targetAudience":"","qualifications":"","purpose":"Automatic translation feature for multilingual support.","approach":"Automatic translation feature for multilingual support.","outcome":"Automatic translation feature for multilingual support.","timeline":"","budget":"","callToAction":"","voting":[],"proposalID":""}',
          picture: '',
        },
      ];

      for (const proposal of permanentProposals) {
      if (!proposalExists(allProposal, proposal.name)) {
        console.log("All Proposals:");
        console.log(allProposal);
        raven?.createChannel(proposal).then((ev) => {
          console.log(ev.id);
          setFetchedAllProposal((prevProposals: any[]) => [...prevProposals, ev]);
        }).catch((e) => {
          showMessage(e.toString(), 'error');
        });
      } else {
        console.log("Already exists!");
      }
    }
  };
  init();
}, []);

  useEffect(() => {
    console.log(filterType);
    const init = async () => {
      filterProposalsByTime();
    };
    init();
  }, [filterType]);

  function filterProposalsByTime(  ) {
    let filteredProposals = [];
    if (filterType === PROPOSAL_TYPES.active) {
      filteredProposals = fetchedAllProposal.filter((proposal: any) => {
        console.log(proposal.created_at, votingPeriod)
        return !isTimeRemaining(proposal.created_at , votingPeriod);
      });
    } else if (filterType === PROPOSAL_TYPES.expired) {
      filteredProposals = fetchedAllProposal.filter((proposal: any) => {
        return isTimeRemaining(proposal.created_at, votingPeriod);
      });
    } else if (filterType === PROPOSAL_TYPES.all) {
      filteredProposals = fetchedAllProposal;
    }

    setAllProposal(filteredProposals);
  }
  return (
    <>
      <div>
        <Box
          sx={{
            mt: '10px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
          }}
        >
          <Box
            sx={{
              fontFamily: 'Faktum, sans-serif',
              fontWeight: 'bold',
              color: theme.palette.primary.dark,
            }}
          >
            <h3 onClick={async e => console.log('p...', channels)}>
              {t('Proposal History')}
            </h3>
          </Box>
          <ChannelAddMenu />
        </Box>
        <hr />
        {(() => {
          if (channels.length === 1) {
            return (
              <Box
                component="span"
                sx={{
                  color: theme.palette.primary.dark,
                  fontSize: '85%',
                  opacity: '0.6',
                }}
              >
                <h4 className="text-center">
                  {t('No Proposal Finded')} <CiFileOff />
                </h4>
              </Box>
            );
          } else {
            return channels.map(c => <ChannelListItem key={c.id} c={c} />);
          }
        })()}
      </div>

      <div>
        <Box
          sx={{
            mt: '50px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
          }}
        >
          <Box
            sx={{
              fontFamily: 'Faktum, sans-serif',
              fontWeight: 'bold',
              color: theme.palette.primary.dark,
            }}
          >
            <h3 onClick={e => console.log(allProposal)}>
              {t(`${filterType} Proposal `)}
            </h3>
          </Box>
          <FilterProposalDropdown proposalTypeSetter={setfilterType} />
        </Box>

        {(() => {
  if (!allProposal || allProposal.length === 0) {
    return (
      <Box
        component="span"
        sx={{
          color: theme.palette.primary.dark,
          fontSize: '85%',
          opacity: '0.6',
        }}
      >
        <h4 className="text-center">
          {t('No Proposal Found')} <CiFileOff />
        </h4>
      </Box>
    );
  } else {
    return allProposal.map((c: any) => (
      <>
        <AllProposalChannelListItem key={c.id} c={c} />
      </>
    ));
  }
})()}
      </div>
    </>
  );
};

export default ChannelList;=== ./app-wrapper/priv-requester.tsx ===
import React, {useEffect, useMemo, useState} from 'react';
import {useAtom} from 'jotai';
import DialogTitle from '@mui/material/DialogTitle';
import DialogContent from '@mui/material/DialogContent';
import DialogActions from '@mui/material/DialogActions';
import {DialogContentText, TextField} from '@mui/material';
import Button from '@mui/material/Button';
import Box from '@mui/material/Box';
import {useTheme} from '@mui/material/styles';
import {getPublicKey, nip19} from 'nostr-tools';
import {DecodeResult} from 'nostr-tools/lib/nip19';
import CloseModal from 'components/close-modal';
import useModal from 'hooks/use-modal';
import useTranslation from 'hooks/use-translation';
import {keysAtom, tempPrivAtom} from 'atoms';


window.requestPrivateKey = (data: any) => {
    return new Promise((resolve, reject) => {
        window.dispatchEvent(new CustomEvent('request-priv', {detail: {data}}));

        const handleResolve = (ev: CustomEvent) => {
            window.removeEventListener('resolve-priv', handleResolve as EventListener);
            window.removeEventListener('reject-priv', handleReject);
            resolve(ev.detail.key);
        }

        const handleReject = () => {
            reject('Cancelled');
            window.removeEventListener('resolve-priv', handleResolve as EventListener);
            window.removeEventListener('reject-priv', handleReject);
        }

        window.addEventListener('resolve-priv', handleResolve as EventListener);
        window.addEventListener('reject-priv', handleReject);
    })
}

const PrivRequiredDialog = (props: { data: any, onSuccess: (key: string) => void, onHide: () => void }) => {
    const {data, onSuccess, onHide} = props;
    const [, showModal] = useModal();
    const [t] = useTranslation();
    const theme = useTheme();
    const [keys,] = useAtom(keysAtom);
    const [tempPriv, setTempPriv] = useAtom(tempPrivAtom);
    const [userKey, setUserKey] = useState(tempPriv ? nip19.nsecEncode(tempPriv) : '');
    const [isInvalid, setIsInvalid] = useState(false);

    const isObject = typeof data === 'object';
    const isEvent = isObject && data.id !== undefined && data.sig !== undefined;
    const dataToRender = useMemo(() => {
        if (isEvent) {
            const {id: _, sig: __, ...ev} = data;
            return JSON.stringify(ev, null, 2);
        } else if (isObject) {
            return JSON.stringify(data, null, 2);
        }

        return null;
    }, [data]);

    const handleClose = () => {
        showModal(null);
        onHide();
    };

    const handleUserKeyChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setUserKey(e.target.value);
        setIsInvalid(false);
    }

    const handleSubmit = () => {
        if (!userKey.startsWith('nsec')) {
            setIsInvalid(true);
            return;
        }

        if (userKey.startsWith('nsec')) {
            let dec: DecodeResult;
            try {
                dec = nip19.decode(userKey);
            } catch (e) {
                setIsInvalid(true);
                return;
            }

            const key = dec.data as string;
            if (dec.type === 'nsec' && keys?.pub === getPublicKey(key)) {
                onSuccess(key);
                setTempPriv(key);
                return;
            }

            setIsInvalid(true);
        }
    }

    let subTitle;
    if (isEvent) {
        subTitle = t('Please provide your private key in nsec format to sign this event:');
    } else if (isObject) {
        subTitle = t('Please provide your private key in nsec format to encrypt this message:');
    } else {
        subTitle = t('Please provide your private key in nsec format for decryption');
    }

    return (
        <>
            <DialogTitle>{t('Private key required')}<CloseModal onClick={handleClose}/></DialogTitle>
            <DialogContent sx={{pb: '0'}}>
                <DialogContentText sx={{fontSize: '.8em', mb: '12px'}}>{subTitle}</DialogContentText>
                {dataToRender && (
                    <Box component="pre" sx={{
                        fontSize: '.6em',
                        overflowY: 'auto',
                        border: `1px solid ${theme.palette.divider}`,
                        borderRadius: '6px',
                        p: '2px',
                        color: theme.palette.text.secondary
                    }}>{dataToRender}</Box>
                )}
                <TextField fullWidth autoComplete="off" autoFocus={userKey === ''}
                           value={userKey} onChange={handleUserKeyChange}
                           placeholder={t('Enter nsec')}
                           error={isInvalid}
                           helperText={isInvalid ? t('Invalid key') : <Box component="span" sx={{
                               background: theme.palette.divider,
                               fontSize: '.9em'
                           }}>{t('This will stay in memory and be remembered until you refresh page/app.')} </Box>}
                           inputProps={{
                               autoCorrect: 'off',
                           }}
                           onKeyPress={(e) => {
                               if (e.key === 'Enter') {
                                   handleSubmit()
                               }
                           }}/>
            </DialogContent>
            <DialogActions sx={{
                display: 'flex',
                justifyContent: 'space-between',
                mt: '10px'
            }}>
                <Button onClick={handleClose} sx={{mr: '6px'}}>{t('Skip')}</Button>
                <Button variant="contained" onClick={handleSubmit} disableElevation>{t('Submit')}</Button>
            </DialogActions>
        </>
    );
}

const PrivRequester = () => {
    const [, showModal] = useModal();

    const rejected = () => {
        window.dispatchEvent(new Event('reject-priv'));
        showModal(null);
    }

    const handleRequest = (ev: CustomEvent) => {
        setTimeout(() => { // use a timer to solve modal rendering conflicts.
            showModal({
                body: <PrivRequiredDialog data={ev.detail.data} onSuccess={(key) => {
                    window.dispatchEvent(new CustomEvent('resolve-priv', {detail: {key}}));
                    showModal(null);
                }} onHide={rejected}/>,
                onHide: rejected,
                hideOnBackdrop: true
            });
        }, 200);
    }

    useEffect(() => {
        window.addEventListener('request-priv', handleRequest as EventListener);

        return () => {
            window.removeEventListener('request-priv', handleRequest as EventListener);
        }
    }, []);

    return null;
}


export default PrivRequester;=== ./app-wrapper/index.tsx ===
import React, {useEffect} from 'react';
import {useAtom} from 'jotai';
import {useLocation, useNavigate} from '@reach/router';
import Box from '@mui/material/Box';
import {useTheme} from '@mui/material/styles';
import useTranslation from 'hooks/use-translation';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import usePopover from 'hooks/use-popover';
import useModal from 'hooks/use-modal';
import PrivRequester from 'views/components/app-wrapper/priv-requester';
import {backupWarnAtom} from 'atoms';
import Alert from 'svg/alert';


const AppWrapper = (props: { children: React.ReactNode }) => {
    const theme = useTheme();
    const {isSm} = useMediaBreakPoint();
    const [t,] = useTranslation();
    const navigate = useNavigate();
    const location = useLocation();
    const [backupWarn, setBackupWarn] = useAtom(backupWarnAtom);
    const [, setPopover] = usePopover();
    const [, setModal] = useModal();

    // Hide popover and modal on page change
    useEffect(() => {
        setPopover(null);
        setModal(null);
    }, [location.pathname]);

    const warnHeight = isSm ? '36px' : '50px';

    return <>
        {backupWarn && (
            <Box sx={{
                width: '100%',
                height: warnHeight,
                background: theme.palette.warning.main,
                color: '#000',
                fontSize: '0.9em',
                display: 'flex',
                justifyContent: 'center',
            }}>
                <Box sx={{
                    display: 'flex',
                    alignItems: 'center',
                    cursor: 'pointer'
                }} onClick={() => {
                    navigate('/settings/keys').then();
                    setBackupWarn(false);
                }}>
                    <Box sx={{
                        display: 'inline-flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        mr: '10px',
                        ml: isSm ? null : '10px'
                    }}>
                        <Alert height={18}/>
                    </Box>
                    {t('Please take a moment to save a copy of your private key  and Mnemonic Seed Phrase.')}
                </Box>
            </Box>
        )}
        <Box sx={{
            flexGrow: 1,
            width: '100%',
            height: backupWarn ? `calc(100% - ${warnHeight})` : '100%',
            overflow: 'hidden',
            display: 'flex',
        }}>
            {props.children}
        </Box>
        <PrivRequester />
    </>
}

export default AppWrapper;
=== ./relay/index.tsx ===
// @ts-nocheck

import React, { useState } from 'react';
import { Button, TextField, Typography, Box, CircularProgress } from '@mui/material';
import { toast } from 'react-toastify';
import axios from 'axios';

const NostrRelaySetup: React.FC = () => {
  const [port, setPort] = useState('');
  const [nostrKey, setNostrKey] = useState('');
  const [isLoading, setIsLoading] = useState(false);

const handleSetupRelay = async () => {
  setIsLoading(true);
  try {
    console.log('Sending setup request to server...');
    const response = await axios.post('http://localhost:5001/api/setup-relay', { port: '8080', nostrKey });
    console.log('Server response:', response.data);
    if (response.data.success) {
      toast.success('Nostr relay and OpenVPN setup completed successfully');
    } else {
      toast.error(`Setup failed: ${response.data.error}`);
    }
  } catch (error) {
    console.error('Setup failed:', error);
    toast.error(`Setup failed: ${error.response?.data?.error || error.message}`);
  } finally {
    setIsLoading(false);
  }
};

  return (
    <Box sx={{ p: 4 }}>
      <Typography variant="h4" gutterBottom>
        Set Up Nostr Relay with OpenVPN
      </Typography>
      <TextField
        label="Port"
        value={port}
        onChange={(e) => setPort(e.target.value)}
        fullWidth
        margin="normal"
      />
      <TextField
        label="Nostr Private Key"
        value={nostrKey}
        onChange={(e) => setNostrKey(e.target.value)}
        fullWidth
        margin="normal"
      />
      <Button 
        variant="contained" 
        color="primary" 
        onClick={handleSetupRelay}
        disabled={isLoading}
      >
        {isLoading ? <CircularProgress size={24} /> : 'Set Up Relay and VPN'}
      </Button>
    </Box>
  );
};

export default NostrRelaySetup;=== ./app-content/DashboardContent.tsx ===
import React from 'react';
import Box from '@mui/material/Box';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import useStyles from 'hooks/use-styles';

const DashboardContent = (props: { children: React.ReactNode, divide?: boolean }) => {
    const {isMd} = useMediaBreakPoint();
    const styles = useStyles();

    const isSmallScreen = !isMd;

    return <Box sx={{
        width: isSmallScreen ? '100%' : (props.divide ? `calc((100% - ${styles.sideBarWidth}) / 2)` : `calc(100% - ${styles.sideBarWidth})`),
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        flexGrow: 0,
        flexShrink: 0,
        overflow:'scroll'
    }}>
        {props.children}
    </Box>
}

export default DashboardContent;
=== ./app-content/index.tsx ===
import React from 'react';
import Box from '@mui/material/Box';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import useStyles from 'hooks/use-styles';

const AppContent = (props: { children: React.ReactNode, divide?: boolean }) => {
    const {isMd} = useMediaBreakPoint();
    const styles = useStyles();

    const isSmallScreen = !isMd;

    return <Box sx={{
        width: isSmallScreen ? '100%' : (props.divide ? `calc((100% - ${styles.sideBarWidth}) / 2)` : `calc(100% - ${styles.sideBarWidth})`),
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        flexGrow: 0,
        flexShrink: 0
    }}>
        {props.children}
    </Box>
}

export default AppContent;
=== ./marketplace/MarketplacePage.tsx ===
import React, { useState, useEffect } from 'react';
import { useMarketplace } from 'hooks/useMarketplace';
import { Card, CardContent, Typography, Grid, Button, TextField, Box } from '@mui/material';
import { Link } from '@reach/router';
import useTranslation from 'hooks/use-translation';
import { RouteComponentProps } from '@reach/router';
import { Product } from 'types';
import { Helmet } from 'react-helmet';
import AppWrapper from 'views/components/app-wrapper';
import AppMenu from 'views/components/app-menu';
import AppContent from 'views/components/app-content';

interface MarketplaceProps extends RouteComponentProps {}

const MarketplacePage: React.FC<MarketplaceProps> = (props) => {
  const [t] = useTranslation();
  const { stalls, products } = useMarketplace();
  const [searchQuery, setSearchQuery] = useState('');
  const [currentPage, setCurrentPage] = useState(1);
  const productsPerPage = 18;

  const filteredProducts = products.filter(product => 
    product.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    product.description.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const indexOfLastProduct = currentPage * productsPerPage;
  const indexOfFirstProduct = indexOfLastProduct - productsPerPage;
  const currentProducts = filteredProducts.slice(indexOfFirstProduct, indexOfLastProduct);
  const totalPages = Math.ceil(filteredProducts.length / productsPerPage);

  const handleSearchChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(event.target.value);
    setCurrentPage(1);
  };

  const handlePageChange = (newPage: number) => {
    setCurrentPage(newPage);
  };

  const renderProduct = (product: Product) => (
    <Grid item xs={12} sm={6} md={4} key={product.id}>
      <Card className="product-card">
        <CardContent>
          <Typography variant="h6">{product.name}</Typography>
          <Typography variant="body2">{product.description}</Typography>
          <Typography variant="body1">
            {t('Price: {{price}} {{currency}}', { price: product.price, currency: product.currency })}
          </Typography>
          {product.proposalId && (
            <Typography variant="body2">
              This product is based on a proposal.
              <Link to={`/channel/${product.proposalId}`}>View Proposal</Link>
            </Typography>
          )}
          {product.images && product.images.length > 0 && (
            <Box sx={{
              width: '100%',
              height: '200px',
              overflow: 'hidden',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
            }}>
              <img 
                src={product.images[0]} 
                alt={product.name} 
                style={{
                  maxWidth: '100%',
                  maxHeight: '100%',
                  objectFit: 'contain',
                }}
              />
            </Box>
          )}
        </CardContent>
      </Card>
    </Grid>
  );

  return (
    <>
      <Helmet>
        <title>{t("NostrChat - Marketplace")}</title>
      </Helmet>
      <AppWrapper>
        <AppMenu />
        <AppContent>
    <Box className="marketplace-container" sx={{
      height: 'calc(100vh - 64px)', // Adjust based on your app's header height
      overflow: 'auto',
      padding: '20px',
    }}>
      <Box className="marketplace-content">
        <TextField
          fullWidth
          label={t('Search products')}
          value={searchQuery}
          onChange={handleSearchChange}
          margin="normal"
        />
        
        <Grid container spacing={2}>
          {currentProducts.map(renderProduct)}
        </Grid>
        <Box sx={{ marginTop: '20px', textAlign: 'center' }}>
          <Button 
            disabled={currentPage === 1} 
            onClick={() => handlePageChange(currentPage - 1)}
          >
            {t('Previous')}
          </Button>
          <span style={{ margin: '0 10px' }}>
            {t('Page {{current}} of {{total}}', { current: currentPage, total: totalPages })}
          </span>
          <Button 
            disabled={currentPage === totalPages} 
            onClick={() => handlePageChange(currentPage + 1)}
          >
            {t('Next')}
          </Button>
        </Box>
      </Box>
    </Box>
       </AppContent>
      </AppWrapper>
    </>
  );
};

export default MarketplacePage;=== ./marketplace/CombinedList.tsx ===
import React from 'react';
import { Grid, Card, CardContent, Typography, Box, Button } from '@mui/material';
import { Link } from '@reach/router';
import { Product, Stall } from 'types';
import useTranslation from 'hooks/use-translation';

interface CombinedListProps {
  stalls: Stall[];
  products: Product[];
}

const CombinedList: React.FC<CombinedListProps> = ({ stalls, products }) => {
  const [t] = useTranslation();

  return (
    <div>
      {stalls.map((stall) => {
        console.log("All products list: ", products);
        console.log("All stalls list: ", stalls);
        const stallProducts = products.filter(product => product.stall_id === stall.id);
        console.log("All products matching to stalls: ", stallProducts);

        return (
          <Box key={stall.id} mb={4}>
            <Link to={`/marketplace/stall/${stall.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
              <Typography variant="h4" component="h2">{stall.name}</Typography>
              <Typography variant="body1" mb={2}>{stall.description}</Typography>
            </Link>
            {stallProducts.length > 0 ? (
              <Grid container spacing={2}>
                {stallProducts.map((product) => (
                  <Grid item xs={12} sm={6} md={4} key={product.id}>
                    <Card>
                      <CardContent>
                        <Typography variant="h6" component="h3">{product.name}</Typography>
                        <Typography variant="body2">{product.description}</Typography>
                        <Typography variant="body1" mt={1}>
                          {t('Price: {{price}} {{currency}}', { price: product.price, currency: product.currency })}
                        </Typography>
                        <Link to={`/marketplace/product/${product.id}`}>
                          <Button variant="contained" color="primary" sx={{ mt: 2 }}>
                            {t('View Details')}
                          </Button>
                        </Link>
                      </CardContent>
                    </Card>
                  </Grid>
                ))}
              </Grid>
            ) : (
              <Typography variant="body1">{t('No products available for this stall')}</Typography>
            )}
          </Box>
        );
      })}
    </div>
  );
};

export default CombinedList;=== ./marketplace/ProductCard.tsx ===
import React from 'react';
import { Card, CardContent, CardMedia, Typography, Button } from '@mui/material';
import { Product } from 'types';

const ProductCard = ({ product }: { product: Product }) => {
  return (
    <Card>
      <CardMedia
        component="img"
        height="140"
        image={product.images[0] || 'placeholder-image-url'}
        alt={product.name}
      />
      <CardContent>
        <Typography gutterBottom variant="h6" component="div">
          {product.name}
        </Typography>
        <Typography variant="body2" color="text.secondary">
          {product.description.slice(0, 100)}...
        </Typography>
        <Typography variant="h6" color="primary" sx={{ mt: 2 }}>
          {product.price} {product.currency}
        </Typography>
        <Button variant="contained" color="primary" sx={{ mt: 1 }}>
          View Details
        </Button>
      </CardContent>
    </Card>
  );
};

export default ProductCard;=== ./marketplace/ProductList.tsx ===
import React from 'react';
import { Grid } from '@mui/material';
import { Product } from 'types';
import ProposalProductView from './ProposalProductView';
import ProductView from './ProductView';

interface ProductListProps {
  products: Product[];
}

const ProductList: React.FC<{ products: Product[] }> = ({ products }) => {
  return (
    <Grid container spacing={2}>
      {products.map(product => (
        <Grid item xs={12} sm={6} md={4} key={product.id}>
          {product.proposalId ? (
            <ProposalProductView product={product} />
          ) : (
            <ProductView product={product} />
          )}
        </Grid>
      ))}
    </Grid>
  );
};

export default ProductList;=== ./marketplace/OrderHistory.tsx ===
import React from 'react';
import { RouteComponentProps } from '@reach/router';

const OrderHistory: React.FC<RouteComponentProps> = () => {
  return <div>Order History placeholder</div>;
};

export default OrderHistory;=== ./marketplace/MerchantDashboard.tsx ===
import React, { useEffect, useState } from 'react';
import { RouteComponentProps } from '@reach/router';
import { useMarketplace } from 'hooks/useMarketplace';
import { Stall, Order } from 'types';

const MerchantDashboard: React.FC<RouteComponentProps> = () => {
  const { stalls } = useMarketplace();
  const [merchantStalls, setMerchantStalls] = useState<Stall[]>([]);
  const [pendingOrders, setPendingOrders] = useState<Order[]>([]);

  useEffect(() => {
    // TODO: Fetch merchant's stalls and pending orders
  }, []);

  const handleCreateStall = () => {
    // TODO: Implement create stall functionality
  };

  const handleCreateProduct = (stallId: string) => {
    // TODO: Implement create product functionality
  };

  const handleUpdateOrderStatus = (orderId: string, status: string) => {
    // TODO: Implement update order status functionality
  };

  return (
    <div>
      <h1>Merchant Dashboard</h1>
      <h2>Your Stalls</h2>
      {merchantStalls.map((stall) => (
        <div key={stall.id}>
          <h3>{stall.name}</h3>
          <button onClick={() => handleCreateProduct(stall.id)}>Add Product</button>
        </div>
      ))}
      <button onClick={handleCreateStall}>Create New Stall</button>
      <h2>Pending Orders</h2>
      {pendingOrders.map((order) => (
        <div key={order.id}>
          <h3>Order #{order.id}</h3>
          <p>Status: {order.status}</p>
          <button onClick={() => handleUpdateOrderStatus(order.id, 'shipped')}>Mark as Shipped</button>
        </div>
      ))}
    </div>
  );
};

export default MerchantDashboard;=== ./marketplace/ProductView.tsx ===
import React from 'react';
import { Box, Typography, Button } from '@mui/material';
import { Product } from 'types';

const ProductView: React.FC<{ product: Product }> = ({ product }) => {
  return (
    <Box>
      <Typography variant="h6">{product.name}</Typography>
      <Typography variant="body1">{product.description}</Typography>
      <Typography variant="body2">Price: {product.price}</Typography>
      <Typography variant="body2">Quantity: {product.quantity}</Typography>
      <Button variant="contained">Add to Cart</Button>
    </Box>
  );
};

export default ProductView;=== ./marketplace/ProposalProductView.tsx ===
import React from 'react';
import { Box, Typography, Button } from '@mui/material';
import { Product } from 'types';

const ProposalProductView: React.FC<{ product: Product }> = ({ product }) => {
  return (
    <Box>
      <Typography variant="h6">{product.name}</Typography>
      <Typography variant="body1">{product.description}</Typography>
      <Typography variant="body2">Price: {product.price}</Typography>
      <Typography variant="body2">Quantity: {product.quantity}</Typography>
      <Button variant="contained">View Proposal</Button>
      <Button variant="contained">Add to Cart</Button>
    </Box>
  );
};

export default ProposalProductView;=== ./marketplace/SimpleMarketplace.tsx ===
/*import React, { useState, useEffect } from 'react';
import { Grid, Typography, Pagination, Box } from '@mui/material';
import { useMarketplace } from 'hooks/useMarketplace';
import ProductCard from './ProductCard';

const SimpleMarketplace = () => {
  const { products } = useMarketplace();
  const [currentPage, setCurrentPage] = useState(1);
  const productsPerPage = 12;

  const indexOfLastProduct = currentPage * productsPerPage;
  const indexOfFirstProduct = indexOfLastProduct - productsPerPage;
  const currentProducts = products.slice(indexOfFirstProduct, indexOfLastProduct);

  const pageCount = Math.ceil(products.length / productsPerPage);

  const handlePageChange = (event, value) => {
    setCurrentPage(value);
  };

  return (
    <Box sx={{ padding: 3 }}>
      <Typography variant="h4" gutterBottom>Simple Marketplace</Typography>
      <Grid container spacing={3}>
        {currentProducts.map((product) => (
          <Grid item xs={12} sm={6} md={4} lg={3} key={product.id}>
            <ProductCard product={product} />
          </Grid>
        ))}
      </Grid>
      <Box sx={{ display: 'flex', justifyContent: 'center', marginTop: 3 }}>
        <Pagination 
          count={pageCount} 
          page={currentPage} 
          onChange={handlePageChange} 
          color="primary" 
        />
      </Box>
    </Box>
  );
};

export default SimpleMarketplace;*/=== ./marketplace/StallList.tsx ===
import React from 'react';
import { Link } from '@reach/router';
import { Stall } from 'types';

interface StallListProps {
  stalls: Stall[];
}

const StallList: React.FC<StallListProps> = ({ stalls }) => {
  return (
    <div>
      {stalls.map((stall) => (
        <div key={stall.id}>
          <Link to={`/marketplace/stall/${stall.id}`}>
            <h2>{stall.name}</h2>
            <p>{stall.description}</p>
          </Link>
        </div>
      ))}
    </div>
  );
};

export default StallList;=== ./marketplace/StallDetail.tsx ===
import React, { useEffect, useState } from 'react';
import { RouteComponentProps } from '@reach/router';
import { useMarketplace } from 'hooks/useMarketplace';
import { Stall, Product } from 'types';
import ProductList from './ProductList';

interface StallDetailProps extends RouteComponentProps {
  stallId?: string;
}

const StallDetail: React.FC<StallDetailProps> = ({ stallId }) => {
  const { stalls, products } = useMarketplace();
  const [stall, setStall] = useState<Stall | null>(null);
  const [stallProducts, setStallProducts] = useState<Product[]>([]);

  useEffect(() => {
    if (stallId) {
      // TODO: Fetch stall details and products
    }
  }, [stallId]);

  if (!stall) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>{stall.name}</h1>
      <p>{stall.description}</p>
      <ProductList products={stallProducts} />
    </div>
  );
};

export default StallDetail;=== ./marketplace/Checkout.tsx ===
import React from 'react';
import { RouteComponentProps } from '@reach/router';

const Checkout: React.FC<RouteComponentProps> = () => {
  return <div>Checkout placeholder</div>;
};

export default Checkout;=== ./marketplace/CombinedStallProductList.tsx ===
import React from 'react';
import { Link } from '@reach/router';
import { Box, Typography, Grid, Card, CardContent, Button } from '@mui/material';
import { Stall, Product } from 'types';
import useTranslation from 'hooks/use-translation';

interface CombinedStallProductListProps {
  stalls: Stall[];
  products: Product[];
}

const CombinedStallProductList: React.FC<CombinedStallProductListProps> = ({ stalls, products }) => {
  const [t] = useTranslation();
  console.log("Every stall: ", stalls);
  console.log("Every product: ", products);
  stalls.map((stall) => {
    const stallProducts = products.filter(product => product.id === stall.id);
    //console.log("All products with matching stalls: ", stallProducts);
  });
  return (
    <Box>
      {stalls.map((stall) => (
        <Box key={stall.id} mb={4}>
          <Typography variant="h4" component="h2">
            <Link to={`/marketplace/stall/${stall.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
              {stall.name}
            </Link>
          </Typography>
          <Typography variant="body1" mb={2}>{stall.description}</Typography>
          <Grid container spacing={2}>
            {products
              .filter(product => product.stall_id === stall.id)
              .map((product) => (
                <Grid item xs={12} sm={6} md={4} key={product.id}>
                  <Card>
                    <CardContent>
                      <Typography variant="h6" component="h3">{product.name}</Typography>
                      <Typography variant="body2">{product.description}</Typography>
                      <Typography variant="body1" mt={1}>
                        {t('Price: {{price}} {{currency}}', { price: product.price, currency: product.currency })}
                      </Typography>
                      <Link to={`/marketplace/product/${product.id}`}>
                        <Button variant="contained" color="primary" sx={{ mt: 2 }}>
                          {t('View Details')}
                        </Button>
                      </Link>
                    </CardContent>
                  </Card>
                </Grid>
              ))}
          </Grid>
        </Box>
      ))}
    </Box>
  );
};

export default CombinedStallProductList;
=== ./marketplace/ProductDetail.tsx ===
import React, { useEffect, useState } from 'react';
import { RouteComponentProps } from '@reach/router';
import { useMarketplace } from 'hooks/useMarketplace';
import { Product } from 'types';

interface ProductDetailProps extends RouteComponentProps {
  productId?: string;
}

const ProductDetail: React.FC<ProductDetailProps> = ({ productId }) => {
  const { products } = useMarketplace();
  const [product, setProduct] = useState<Product | null>(null);

  useEffect(() => {
    if (productId) {
      // TODO: Fetch product details
    }
  }, [productId]);

  const handleAddToCart = () => {
    // TODO: Implement add to cart functionality
  };

  if (!product) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <p>Price: {product.price} {product.currency}</p>
      <button onClick={handleAddToCart}>Add to Cart</button>
    </div>
  );
};

export default ProductDetail;=== ./marketplace/Cart.tsx ===
import React from 'react';
import { RouteComponentProps } from '@reach/router';

const Cart: React.FC<RouteComponentProps> = () => {
  return <div>Cart placeholder</div>;
};

export default Cart;=== ./message-menu/web.tsx ===
import React, {useRef} from 'react';
import {Message} from 'types';
import IconButton from '@mui/material/IconButton';
import Box from '@mui/material/Box';
import Tooltip from '@mui/material/Tooltip';
import {useTheme} from '@mui/material/styles';
import {useAtom} from 'jotai';
import {activeMessageAtom, keysAtom, ravenAtom, threadRootAtom} from 'atoms';
import useModal from 'hooks/use-modal';
import ConfirmDialog from 'components/confirm-dialog';
import EmojiPicker from 'components/emoji-picker';
import ShortEmojiPicker from 'components/short-emoji-picker';
import useTranslation from 'hooks/use-translation';
import usePopover from 'hooks/use-popover';
import useToast from 'hooks/use-toast';
import EyeOff from 'svg/eye-off';
import MessageReplyText from 'svg/message-reply-text';
import Emoticon from 'svg/emoticon';
import Close from 'svg/close';


const MessageMenu = (props: { message: Message, inThreadView?: boolean }) => {
    const {message, inThreadView} = props;
    const theme = useTheme();
    const [keys] = useAtom(keysAtom);
    const [raven] = useAtom(ravenAtom);
    const [, setActiveMessage] = useAtom(activeMessageAtom);
    const [, setThreadRoot] = useAtom(threadRootAtom);
    const [, showMessage] = useToast();
    const [, showModal] = useModal();
    const [t] = useTranslation();
    const [, showPopover] = usePopover();
    const emojiButton = useRef<HTMLButtonElement | null>(null);

    const emojiSelected = (emoji: string) => {
        if (message.reactions?.find(x => x.creator === keys?.pub && x.content === emoji) === undefined) {
            raven?.sendReaction(message.id, message.creator, emoji).catch(e => {
                showMessage(e.toString(), 'error');
            });
        }
        setActiveMessage(null);
        showPopover(null);
    }

    const emoji = () => {
        setActiveMessage(message.id);
        showPopover({
            body: <Box sx={{width: '280px'}}>
                <ShortEmojiPicker
                    onSelect={emojiSelected}
                    onMore={emojiFull}
                />
            </Box>,
            toRight: true,
            toBottom: true,
            anchorEl: emojiButton.current!,
            onClose: () => {
                setActiveMessage(null);
            }
        });
    }

    const emojiFull = () => {
        setActiveMessage(message.id);
        showPopover({
            body: <Box sx={{width: '298px'}}>
                <EmojiPicker onSelect={emojiSelected}/>
            </Box>,
            toRight: true,
            toBottom: true,
            anchorEl: emojiButton.current!,
            onClose: () => {
                setActiveMessage(null);
            }
        });
    }

    const openThread = () => {
        setThreadRoot(message);
    }

    const hide = () => {
        showModal({
            body: <ConfirmDialog onConfirm={() => {
                raven?.hideChannelMessage(message.id, '');
            }}/>
        });
    }

    const del = () => {
        showModal({
            body: <ConfirmDialog onConfirm={() => {
                raven?.deleteEvents([message.id])
            }}/>
        });
    }

    const buttons = [<Tooltip title={t('Reaction')}>
        <IconButton size="small" onClick={emoji} ref={emojiButton}>
            <Emoticon height={20}/>
        </IconButton>
    </Tooltip>];

    if (!inThreadView) {
        buttons.push(<Tooltip title={t('Reply in thread')}>
            <IconButton size="small" onClick={openThread}>
                <MessageReplyText height={18}/>
            </IconButton>
        </Tooltip>)
    }

    if (keys?.pub !== message.creator && !('decrypted' in message)) { // only public messages
        buttons.push(<Tooltip title={t('Hide')}>
            <IconButton size="small" onClick={hide}>
                <EyeOff height={20}/>
            </IconButton>
        </Tooltip>);
    }

    if (keys?.pub === message.creator) {
        buttons.push(<Tooltip title={t('Delete')}>
            <IconButton size="small" onClick={del}>
                <Close height={20}/>
            </IconButton>
        </Tooltip>);
    }

    if (buttons.length === 0) return null;

    return <Box sx={{
        padding: '4px 6px',
        borderRadius: theme.shape.borderRadius,
        background: theme.palette.background.paper,
        border: `1px solid ${theme.palette.divider}`,
        display: 'flex',
    }}>
        {buttons.map((b, i) => <Box
            sx={{display: 'flex', alignItems: 'center', mr: i === buttons.length - 1 ? null : '6px'}}
            key={i}>{b}</Box>)}
    </Box>;
}

export default MessageMenu;
=== ./message-menu/mobile.tsx ===
import React, {useEffect, useMemo, useRef, useState} from 'react';
import {keysAtom, ravenAtom, threadRootAtom} from 'atoms';
import {useAtom} from 'jotai';
import Box from '@mui/material/Box';
import Paper from '@mui/material/Paper';
import MenuList from '@mui/material/MenuList';
import MenuItem from '@mui/material/MenuItem';
import ListItemText from '@mui/material/ListItemText';
import ListItemIcon from '@mui/material/ListItemIcon';
import {useTheme} from '@mui/material/styles';
import Tooltip from '@mui/material/Tooltip';
import {darken} from '@mui/material';
import useContentRenderer from 'hooks/use-render-content';
import useToast from 'hooks/use-toast';
import usePopover from 'hooks/use-popover';
import useTranslation from 'hooks/use-translation';
import useModal from 'hooks/use-modal';
import ShortEmojiPicker from 'components/short-emoji-picker';
import CopyToClipboard from 'components/copy-clipboard';
import EmojiPicker from 'components/emoji-picker';
import ConfirmDialog from 'components/confirm-dialog';
import MessageReactions from 'views/components/message-reactions';
import {Message} from 'types';
import {formatMessageDateTime, formatMessageTime} from 'helper';
import MessageReplyText from 'svg/message-reply-text';
import ContentCopy from 'svg/content-copy';
import EyeOff from 'svg/eye-off';
import Close from 'svg/close';


const MessageMobileView = (props: { message: Message, profileName: string, inThreadView?: boolean, onClose: () => void }) => {
    const {message, profileName, inThreadView, onClose} = props;
    const theme = useTheme();
    const renderer = useContentRenderer();
    const [raven] = useAtom(ravenAtom);
    const [keys] = useAtom(keysAtom);
    const [, setThreadRoot] = useAtom(threadRootAtom);
    const renderedBody = useMemo(() => renderer(message), [message]);
    const holderEl = useRef<HTMLDivElement | null>(null);
    const innerHolderEl = useRef<HTMLDivElement | null>(null);
    const fullEmojiPickerHolder = useRef<HTMLDivElement | null>(null);
    const [, showMessage] = useToast();
    const [, showPopover] = usePopover();
    const [, showModal] = useModal();
    const [t] = useTranslation();
    const messageTime = useMemo(() => formatMessageTime(message.created), [message]);
    const messageDateTime = useMemo(() => formatMessageDateTime(message.created), [message]);
    const [shouldRender, setShouldRender] = useState<boolean>(false);

    useEffect(() => {
        if (!shouldRender) {
            setTimeout(() => {
                setShouldRender(true);
            }, 200);
        }
    }, [shouldRender]);

    if (!shouldRender) {
        return null;
    }

    const emojiSelected = (emoji: string) => {
        if (message.reactions?.find(x => x.creator === keys?.pub && x.content === emoji) === undefined) {
            raven?.sendReaction(message.id, message.creator, emoji).catch(e => {
                showMessage(e.toString(), 'error');
            });
        }
        showPopover(null);
    }

    const emojiFull = () => {
        showPopover({
            body: <Box sx={{width: '298px'}}>
                <EmojiPicker onSelect={emojiSelected}/>
            </Box>,
            anchorEl: fullEmojiPickerHolder.current!
        });
    }

    const openThread = () => {
        setThreadRoot(message);
        onClose();
    }

    const hide = () => {
        showModal({
            body: <ConfirmDialog onConfirm={() => {
                raven?.hideChannelMessage(message.id, '');
                onClose();
            }}/>
        });
    }

    const del = () => {
        showModal({
            body: <ConfirmDialog onConfirm={() => {
                raven?.deleteEvents([message.id]);
                onClose();
            }}/>
        });
    }

    const buttons = [<CopyToClipboard copy={message.content} key="copy">
        <MenuItem>
            <ListItemIcon>
                <ContentCopy height={18}/>
            </ListItemIcon>
            <ListItemText primaryTypographyProps={{fontSize: '.9em'}}>{t('Copy')}</ListItemText>
        </MenuItem>
    </CopyToClipboard>];

    if (!inThreadView) {
        buttons.push(<MenuItem onClick={openThread} key="thread">
            <ListItemIcon>
                <MessageReplyText height={18}/>
            </ListItemIcon>
            <ListItemText primaryTypographyProps={{fontSize: '.9em'}}>{t('Reply in thread')}</ListItemText>
        </MenuItem>);
    }

    if (keys?.pub !== message.creator && !('decrypted' in message)) { // only public messages
        buttons.push(<MenuItem onClick={hide} key="hide">
            <ListItemIcon>
                <EyeOff height={20}/>
            </ListItemIcon>
            <ListItemText primaryTypographyProps={{fontSize: '.9em'}}>{t('Hide')}</ListItemText>
        </MenuItem>);
    }

    if (keys?.pub === message.creator) {
        buttons.push(<MenuItem onClick={del} key="del">
            <ListItemIcon>
                <Close height={20}/>
            </ListItemIcon>
            <ListItemText primaryTypographyProps={{fontSize: '.9em'}}>{t('Delete')}</ListItemText>
        </MenuItem>);
    }

    return <Box
        ref={holderEl}
        onTouchStart={(e) => {
            e.stopPropagation();
        }}
        onTouchEnd={(e) => {
            e.stopPropagation();
        }}
        onClick={(e) => {
            e.stopPropagation();
            if (e.target === holderEl.current || e.target === innerHolderEl.current) {
                onClose();
            }
        }}
        sx={{
            position: 'fixed',
            top: 0,
            bottom: 0,
            right: 0,
            left: 0,
            width: '100%',
            height: '100%',
            zIndex: 999,
            backdropFilter: 'blur(14px)',
            background: 'rgba(255, 255, 255, .1)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            userSelect: 'none'
        }}>
        <Box ref={innerHolderEl} sx={{
            width: '90%',
        }}>
            <Box sx={{
                width: '280px',
                mb: '20px',
                borderRadius: '16px',
                background: theme.palette.background.paper
            }}>
                <ShortEmojiPicker onSelect={emojiSelected} onMore={emojiFull}/>
                <Box ref={fullEmojiPickerHolder}></Box>
            </Box>
            <Box sx={{
                background: theme.palette.background.paper,
                p: '12px',
                borderRadius: '6px'
            }}>
                <Box sx={{display: 'flex', alignItems: 'center', fontSize: '.7em',}}>
                    <Box sx={{
                        mr: '5px',
                    }}>{profileName}</Box>
                    <Tooltip title={messageDateTime} placement="bottom-start" enterTouchDelay={500}>
                        <Box sx={{
                            color: darken(theme.palette.text.secondary, 0.3),
                        }}>{messageTime}</Box>
                    </Tooltip>
                </Box>
                <Box sx={{
                    fontSize: '.9em',
                    mt: '4px',
                    wordBreak: 'break-word',
                    lineHeight: '1.4em',
                    color: theme.palette.text.secondary,
                    userSelect: 'text'
                }}>{renderedBody}</Box>
            </Box>
            {message.reactions && message.reactions.length > 0 && (
                <Box sx={{pt: '10px', display: 'inline-flex'}}>
                    <MessageReactions message={message}/>
                </Box>
            )}
            <Paper sx={{width: '320px', maxWidth: '100%', fontSize: '90%', mt: '10px'}}>
                <MenuList sx={{fontSize: '90%'}}>
                    {buttons}
                </MenuList>
            </Paper>
        </Box>
    </Box>;
}

export default MessageMobileView;=== ./message-reactions/index.tsx ===
import {useMemo} from 'react';
import Box from '@mui/material/Box';
import uniq from 'lodash.uniq';
import toArray from 'lodash.toarray';
import {useAtom} from 'jotai';
import {keysAtom} from 'atoms';
import ReactionBtn from 'views/components/message-reactions/reaction-btn';
import {Message, ReactionCombined} from 'types';

const MessageReactions = (props: { message: Message }) => {
    const {message} = props;
    const [keys] = useAtom(keysAtom);

    const reactions: ReactionCombined[] | null = useMemo(() => {
        if (!message.reactions) return null;

        const symbols: Record<string, number> = {};
        message.reactions.sort((a, b) => a.created - b.created).forEach(r => {
            // best way to check correct (visible) length of a string that contains emojis since Intl.Segmenter doesn't work with Firefox
            if (toArray(r.content).length === 1) {
                symbols[r.content] = 1;
            }
        });

        return Object.keys(symbols).map((symbol) => {
            const authors = uniq(message.reactions!.filter(x => x.content === symbol).map(x => x.creator));
            const count = authors.length;
            const userReaction = message.reactions!.find(x => x.content === symbol && x.creator === keys?.pub);

            return {symbol, authors, count, userReaction}
        });
    }, [message.reactions]);

    if (!reactions) return null;

    return <Box sx={{
        display: 'flex',
        mb: '4px'
    }}>
        {reactions.map((r, i) => <ReactionBtn key={r.symbol} message={message} r={r} mr={i < reactions.length - 1}/>)}
    </Box>;
}

export default MessageReactions;
=== ./message-reactions/reaction-btn.tsx ===
import {useState} from 'react';
import {useAtom} from 'jotai';
import Box from '@mui/material/Box';
import {blue} from '@mui/material/colors';
import {useTheme} from '@mui/material/styles';
import {ravenAtom} from 'atoms';
import {Message, ReactionCombined} from 'types';

const ReactionBtn = (props: { message: Message, r: ReactionCombined, mr: boolean }) => {
    const {message, r, mr} = props;
    const theme = useTheme();
    const [raven] = useAtom(ravenAtom);
    const [inProgress, setInProgress] = useState(false);

    return <Box key={r.symbol} sx={{
        fontSize: '0.8em',
        p: '0 6px',
        mr: mr ? '4px' : null,
        background: r.userReaction ? blue[800] : theme.palette.background.paper,
        borderRadius: '8px',
        display: 'flex',
        alignItems: 'center',
        cursor: 'pointer',
        border: '1px solid transparent',
        opacity: inProgress ? .6 : null,
        pointerEvents: inProgress ? 'none' : null,
        ':hover': {
            borderColor: theme.palette.divider,
        },
    }} onClick={() => {
        if (inProgress) return;
        setInProgress(true);
        (r.userReaction ? raven?.deleteEvents([r.userReaction.id]) : raven?.sendReaction(message.id, message.creator, r.symbol))?.finally(() => {
            setInProgress(false);
        });
    }}>
        <Box sx={{mr: '3px'}}>{r.symbol}</Box>
        <Box sx={{
            color: theme.palette.text.disabled,
            fontSize: '0.9em',
        }}>{r.count}</Box>
    </Box>
}

export default ReactionBtn;
=== ./calendar/oldCalendar.tsx ===
// Calendar.tsx

import React, { useState, useEffect } from 'react';
import { useAtom } from 'jotai';
import { 
  Box, 
  Slider, 
  Button, 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions,
  TextField,
  Typography
} from '@mui/material';
import { ravenAtom, profilesAtom, channelAtom, activeProposalIdAtom, keysAtom } from 'atoms';
import { PublicMessage } from 'types';
import useTranslation from 'hooks/use-translation';
import { formatMessageDateTime } from 'helper';
import { RouteComponentProps } from '@reach/router';
import { nip19 } from 'nostr-tools';

interface CalendarProps extends RouteComponentProps {}

// Define a new type that matches our event suggestion structure
interface EventSuggestion {
  id: string;
  root: string;
  content: string;
  creator: string;
  created: number;
  mentions: string[];
  proposalID: string;
}

const Calendar: React.FC<CalendarProps> = (props) => {
  console.log("Starting Calendar");
  const [t] = useTranslation();
  const [raven] = useAtom(ravenAtom);
  const [profiles] = useAtom(profilesAtom);
  const [channel] = useAtom(channelAtom);
  const [activeProposalId] = useAtom(activeProposalIdAtom);
  const [keys] = useAtom(keysAtom);
  
  const [timeRange, setTimeRange] = useState<[number, number]>([9, 17]); // 9 AM to 5 PM
  const [startDate, setStartDate] = useState<string>(new Date().toISOString().split('T')[0]);
  const [endDate, setEndDate] = useState<string>(new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]);
  const [eventSuggestions, setEventSuggestions] = useState<EventSuggestion[]>([]);
  const [showDialog, setShowDialog] = useState(false);
  const [selectedSuggestion, setSelectedSuggestion] = useState<EventSuggestion | null>(null);
  const [finalDateTime, setFinalDateTime] = useState<string>('');
  const [recipientPubKey, setRecipientPubKey] = useState<string>('');

  useEffect(() => {
    if (raven && keys) {
      fetchEventSuggestions();
      const interval = setInterval(fetchEventSuggestions, 30000); // Check for new messages every 30 seconds
      return () => clearInterval(interval);
    }
  }, [raven, keys]);

useEffect(() => {
  console.log('Current eventSuggestions:', eventSuggestions);
}, [eventSuggestions]);

const fetchEventSuggestions = async () => {
  if (!raven || !keys) {
    console.log('Raven or keys not available');
    return;
  }
  try {
    console.log('Fetching proposals...');
    const messages = await raven.fetchAllProposal();
    console.log('Fetched messages:', messages);
    
const newSuggestions = messages
  .filter(msg => {
    try {
      const content = JSON.parse(msg.content);
      return content.type === 'event_suggestion' && content.timeRange && content.dateRange;
    } catch (e) {
      console.log(`Error parsing message ${msg.id}:`, e);
      return false;
    }
  })
  .map(msg => ({
    id: msg.id,
    root: msg.tags.find(tag => tag[0] === 'e')?.[1] || '',
    content: msg.content, // Store as string
    creator: msg.pubkey,
    created: msg.created_at,
    mentions: msg.tags.filter(tag => tag[0] === 'p').map(tag => tag[1]),
    proposalID: msg.tags.find(tag => tag[0] === 'e')?.[1] || '',
  }));

    console.log('New suggestions:', newSuggestions);

  setEventSuggestions(prevSuggestions => {
    const existingIds = new Set(prevSuggestions.map(s => s.id));
    const uniqueNewSuggestions = newSuggestions.filter(s => !existingIds.has(s.id));
    console.log('Unique new suggestions:', uniqueNewSuggestions);
    const updatedSuggestions = [...prevSuggestions, ...uniqueNewSuggestions];
    console.log('Updated event suggestions:', updatedSuggestions);
    return updatedSuggestions;
  });

    // console.log('Updated event suggestions:', eventSuggestions);
  } catch (error) {
    console.error('Error fetching event suggestions:', error);
  }
};

const handleSendSuggestion = async () => {
  if (!raven) {
    console.error('Raven is not initialized');
    alert(t('Unable to send suggestion. Please try again later.'));
    return;
  }

  if (!recipientPubKey.trim()) {
    alert(t('Please enter a recipient public key'));
    return;
  }

  let pubkey = recipientPubKey;

  if (recipientPubKey.startsWith('npub1')) {
    try {
      const { type, data } = nip19.decode(recipientPubKey);
      if (type !== 'npub') {
        throw new Error('Not an npub key');
      }
      pubkey = data as string;
    } catch (e) {
      console.error('Error decoding npub:', e);
      alert(t('Invalid npub format'));
      return;
    }
  } else if (!/^[0-9a-fA-F]{64}$/.test(recipientPubKey)) {
    alert(t('Invalid public key format'));
    return;
  }

  console.log('Sending to pubkey:', pubkey);

const suggestion = JSON.stringify({
  type: 'event_suggestion',
  dateRange: [startDate, endDate],
  timeRange: timeRange,
});

  console.log('Sending suggestion:', suggestion);

  try {
    const result = await raven.sendDirectMessage(
      pubkey,
      suggestion,
      [], // No mentions for direct messages
      activeProposalId || undefined
    );
    console.log('Send result:', result);
    console.log('Message tags:', result.tags);
    alert(t('Event suggestion sent successfully!'));
    setRecipientPubKey('');
    fetchEventSuggestions(); // Fetch updated suggestions
  } catch (error) {
    console.error('Error sending event suggestion:', error);
    alert(t('Failed to send event suggestion. Please check the recipient public key and try again.'));
  }
};

const handleRespondToSuggestion = async (suggestion: EventSuggestion, response: 'accept' | 'counter' | 'ignore') => {
  if (!raven) return;
  const content = JSON.parse(suggestion.content);
  if (response === 'accept') {
    setSelectedSuggestion(suggestion);
    setShowDialog(true);
  } else if (response === 'counter') {
    setTimeRange(content.timeRange);
    setStartDate(content.dateRange[0]);
    setEndDate(content.dateRange[1]);
    setRecipientPubKey(suggestion.creator);
  } else {
    const responseMessage = JSON.stringify({
      type: 'event_response',
      originalSuggestionId: suggestion.id,
      response: 'ignored',
    });
    await raven.sendDirectMessage(suggestion.creator, responseMessage, [], suggestion.proposalID);
    setEventSuggestions(prevSuggestions => prevSuggestions.filter(s => s.id !== suggestion.id));
  }
  fetchEventSuggestions(); // Fetch updated suggestions
};

  const handleFinalizeEvent = async () => {
    if (!raven || !selectedSuggestion || !finalDateTime || !channel) return;
    const finalizeMessage = JSON.stringify({
      type: 'event_finalized',
      originalSuggestionId: selectedSuggestion.id,
      finalDateTime: finalDateTime,
    });
    await raven.sendPublicMessage(channel, finalizeMessage, [selectedSuggestion.creator], selectedSuggestion.proposalID);
    setShowDialog(false);
    setEventSuggestions(prevSuggestions => prevSuggestions.filter(s => s.id !== selectedSuggestion.id));
    fetchEventSuggestions(); // Fetch updated suggestions
  };

const formatPublicKey = (pubkey: string) => {
  return pubkey.slice(0, 8) + '...'; // or use nip19.npubEncode(pubkey) if available
};

const formatTimeRange = (range: [number, number] | undefined): string => {
  if (!range || !Array.isArray(range) || range.length < 2) {
    console.error('Invalid time range:', range);
    return 'Invalid time range';
  }
  return `${range[0]}:00 - ${range[1]}:00`;
};

  const formatDateRange = (start: string, end: string): string => {
    return `${formatMessageDateTime(new Date(start).getTime())} - ${formatMessageDateTime(new Date(end).getTime())}`;
  };

  console.log("Event suggestions: ", eventSuggestions);

  return (
    <Box sx={{ width: '100%', padding: 2 }}>
      <Typography variant="h4" gutterBottom>{t('Event Scheduler')}</Typography>
      
      <Box sx={{ mb: 2 }}>
        <TextField
          label={t('Recipient Public Key')}
          value={recipientPubKey}
          onChange={(e) => setRecipientPubKey(e.target.value)}
          fullWidth
          placeholder={t('Enter recipient\'s public key')}
        />
      </Box>
      <Box sx={{ mb: 2 }}>
        <TextField
          label={t('Start Date')}
          type="date"
          value={startDate}
          onChange={(e) => setStartDate(e.target.value)}
          fullWidth
          InputLabelProps={{
            shrink: true,
          }}
        />
      </Box>
      <Box sx={{ mb: 2 }}>
        <TextField
          label={t('End Date')}
          type="date"
          value={endDate}
          onChange={(e) => setEndDate(e.target.value)}
          fullWidth
          InputLabelProps={{
            shrink: true,
          }}
        />
      </Box>
      <Box sx={{ mb: 2 }}>
        <Slider
          value={timeRange}
          onChange={(_, newValue) => setTimeRange(newValue as [number, number])}
          valueLabelDisplay="auto"
          min={0}
          max={24}
          step={1}
          marks
          valueLabelFormat={(value) => `${value}:00`}
        />
        <Box sx={{ mt: 1 }}>{t('Time Range')}: {formatTimeRange(timeRange)}</Box>
      </Box>
<Button 
  variant="contained" 
  onClick={handleSendSuggestion}
  disabled={!recipientPubKey.trim()}
>
  {t('Send Event Suggestion')}
</Button>

      <Typography variant="h5" sx={{ mt: 4, mb: 2 }}>{t('Received Event Suggestions')}</Typography>
      <Box sx={{ mt: 2 }}>
{eventSuggestions.map(suggestion => {
  let content;
  try {
    content = JSON.parse(suggestion.content);
  } catch (e) {
    console.error('Error parsing suggestion content:', e);
    content = {};
  }
  console.log("Suggestion content:", content);
  console.log("Suggestion creator:", suggestion.creator);
  return (
    <Box key={suggestion.id} sx={{ border: '1px solid #ccc', borderRadius: 2, p: 2, mb: 2 }}>
      <Box>{t('Suggested by')}: {profiles.find(p => p.creator === suggestion.creator)?.name || formatPublicKey(suggestion.creator)}</Box>
      <Box>{t('Suggested time range')}: {formatTimeRange(content.timeRange)}</Box>
      <Box>{t('Suggested date range')}: {content.dateRange ? formatDateRange(content.dateRange[0], content.dateRange[1]) : 'Invalid date range'}</Box>
      <Box sx={{ mt: 1 }}>
        <Button onClick={() => handleRespondToSuggestion(suggestion, 'accept')}>{t('Accept')}</Button>
        <Button onClick={() => handleRespondToSuggestion(suggestion, 'counter')}>{t('Counter')}</Button>
        <Button onClick={() => handleRespondToSuggestion(suggestion, 'ignore')}>{t('Ignore')}</Button>
      </Box>
    </Box>
  );
})}
      </Box>

      <Dialog open={showDialog} onClose={() => setShowDialog(false)}>
        <DialogTitle>{t('Finalize Event')}</DialogTitle>
        <DialogContent>
          <TextField
            label={t('Final Date and Time')}
            type="datetime-local"
            value={finalDateTime}
            onChange={(e) => setFinalDateTime(e.target.value)}
            fullWidth
            InputLabelProps={{
              shrink: true,
            }}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowDialog(false)}>{t('Cancel')}</Button>
          <Button onClick={handleFinalizeEvent} disabled={!finalDateTime}>{t('Finalize')}</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default Calendar;=== ./calendar/index.tsx ===
import React, { useState, useEffect, useCallback } from 'react';
import { useAtom } from 'jotai';
import {
  Box,
  Slider,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Typography,
  CircularProgress,
  Snackbar,
  Select,
  MenuItem,
  FormControl,
  InputLabel
} from '@mui/material';
import { ravenAtom, profilesAtom, channelAtom, activeProposalIdAtom, keysAtom, directMessagesAtom } from 'atoms';
import NewKinds from 'raven/raven';
import RavenEvents from 'raven/raven';
import ExtendedFilter from 'raven/raven';
import ExtendedKind from 'raven/raven';
import useTranslation from 'hooks/use-translation';
import { formatMessageDateTime } from 'helper';
import { RouteComponentProps } from '@reach/router';
import { nip19 } from 'nostr-tools';
import useLiveDirectContacts from 'hooks/use-live-direct-contacts';
import { Helmet } from 'react-helmet';
import AppWrapper from 'views/components/app-wrapper';
import AppMenu from 'views/components/app-menu';
import AppContent from 'views/components/app-content';

interface CalendarProps extends RouteComponentProps {}

export interface EventSuggestion {
  id: string;
  root: string;
  content: string;
  creator: string;
  created: number;
  mentions: string[];
  proposalID: string;
  finalDateTime?: string;
}

const Calendar: React.FC<CalendarProps> = (props) => {
  console.log("Starting Calendar component");

  const [t] = useTranslation();
  const [raven] = useAtom(ravenAtom);
  const [profiles] = useAtom(profilesAtom);
  const [channel] = useAtom(channelAtom);
  const [activeProposalId] = useAtom(activeProposalIdAtom);
  const [keys] = useAtom(keysAtom);

  const [timeRange, setTimeRange] = useState<[number, number]>([9, 17]);
  const [startDate, setStartDate] = useState<string>(new Date().toISOString().split('T')[0]);
  const [endDate, setEndDate] = useState<string>(new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]);
  const [eventSuggestions, setEventSuggestions] = useState<EventSuggestion[]>([]);
  const [showDialog, setShowDialog] = useState(false);
  const [selectedSuggestion, setSelectedSuggestion] = useState<EventSuggestion | null>(null);
  const [finalDateTime, setFinalDateTime] = useState<string>('');
  const [recipientPubKey, setRecipientPubKey] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  //const [isIntervalLoading, setIsIntervalLoading] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [finalizedEvents, setFinalizedEvents] = useState<EventSuggestion[]>([]);
const [isCountering, setIsCountering] = useState(false);
const [counteredSuggestionId, setCounteredSuggestionId] = useState<string | null>(null);

  const [directMessages] = useAtom(directMessagesAtom);
  const directContacts = useLiveDirectContacts();

  // Replace recipientPubKey state with selectedContact
  const [selectedContact, setSelectedContact] = useState<string>('');

const fetchEventSuggestions = useCallback(async (isInitialLoad = false) => {
  if (!raven || !keys) {
    console.log('Raven or keys not available, skipping fetchEventSuggestions', { raven, keys });
    return;
  }
  if (isInitialLoad) {
    setIsLoading(true);
  }
  try {
    console.log('Fetching calendar suggestions...');
    const messages = await raven.fetchCalendarSuggestions();
    console.log('Fetched messages:', messages);
    
    const newSuggestions: EventSuggestion[] = [];
    const newFinalizedEvents: EventSuggestion[] = [];

    messages.forEach(msg => {
      const content = JSON.parse(msg.content);
      if (content.type === 'event_suggestion') {
        newSuggestions.push({
          id: msg.id,
          root: msg.tags.find(tag => tag[0] === 'e')?.[1] || '',
          content: msg.content,
          creator: msg.pubkey,
          created: msg.created_at,
          mentions: msg.tags.filter(tag => tag[0] === 'p').map(tag => tag[1]),
          proposalID: msg.tags.find(tag => tag[0] === 'e')?.[1] || '',
        });
      } else if (content.type === 'event_finalized') {
        newFinalizedEvents.push({
          id: msg.id,
          root: msg.tags.find(tag => tag[0] === 'e')?.[1] || '',
          content: msg.content,
          creator: msg.pubkey,
          created: msg.created_at,
          mentions: msg.tags.filter(tag => tag[0] === 'p').map(tag => tag[1]),
          proposalID: msg.tags.find(tag => tag[0] === 'e')?.[1] || '',
          finalDateTime: content.finalDateTime,
        });
      }
    });

    console.log('New suggestions:', newSuggestions);
    console.log('New finalized events:', newFinalizedEvents);

    setEventSuggestions(prevSuggestions => {
      const existingIds = new Set(prevSuggestions.map(s => s.id));
      const uniqueNewSuggestions = newSuggestions.filter(s => !existingIds.has(s.id));
      return [...prevSuggestions, ...uniqueNewSuggestions];
    });

    setFinalizedEvents(prevEvents => {
      const existingIds = new Set(prevEvents.map(e => e.id));
      const uniqueNewEvents = newFinalizedEvents.filter(e => !existingIds.has(e.id));
      return [...prevEvents, ...uniqueNewEvents];
    });

  } catch (error) {
    console.error('Error fetching event suggestions:', error);
    setSnackbarMessage(t('Failed to fetch event suggestions. Please try again.'));
  } finally {
    if (isInitialLoad) {
      setIsLoading(false);
    }
  }
}, [raven, keys, t]);

  useEffect(() => {
    if (raven && keys) {
      console.log("Raven and keys are available, starting to fetch event suggestions");
      fetchEventSuggestions(true);
      const interval = setInterval(() => fetchEventSuggestions(false), 30000);
      return () => clearInterval(interval);
    } else {
      console.log("Raven or keys not available", { raven, keys });
    }
  }, [raven, keys, fetchEventSuggestions]);

  useEffect(() => {
    if (raven) {
      const handleCalendarSuggestion = (suggestions: EventSuggestion[]) => {
        setEventSuggestions(prevSuggestions => {
          const newSuggestions = suggestions.filter(s => 
            !prevSuggestions.some(ps => ps.id === s.id)
          );
          return [...prevSuggestions, ...newSuggestions];
        });
      };

      raven.onCalendarSuggestion(handleCalendarSuggestion);

      return () => {
        raven.offCalendarSuggestion(handleCalendarSuggestion);
      };
    }
  }, [raven]);

  const handleSendSuggestion = async () => {
    if (!raven) {
      console.error('Raven is not initialized');
      setSnackbarMessage(t('Unable to send suggestion. Please try again later.'));
      return;
    }

    if (!selectedContact) {
      console.log('No contact selected');
      setSnackbarMessage(t('Please select a recipient'));
      return;
    }

    const suggestion = JSON.stringify({
      type: 'event_suggestion',
      dateRange: [
        new Date(startDate).toISOString(),
        new Date(endDate).toISOString()
      ],
      timeRange: timeRange,
      isCounterSuggestion: isCountering,
      originalSuggestionId: counteredSuggestionId
    });

    console.log('Sending suggestion:', suggestion);

    try {
      setIsLoading(true);
      const result = await raven.publishCalendarSuggestion(selectedContact, suggestion);
      console.log('Send result:', result);
      console.log('Message tags:', result.tags);
      setSnackbarMessage(t('Event suggestion sent successfully!'));
      setSelectedContact('');
      await fetchEventSuggestions(true);
    } catch (error) {
      console.error('Error sending event suggestion:', error);
      setSnackbarMessage(t('Failed to send event suggestion. Please try again.'));
    } finally {
      setIsLoading(false);
    }

    setIsCountering(false);
    setCounteredSuggestionId(null);
  };

const handleIgnore = (suggestion: EventSuggestion) => {
  setEventSuggestions(prevSuggestions => prevSuggestions.filter(s => s.id !== suggestion.id));
  setSnackbarMessage(t('Suggestion ignored and removed'));
};

  const handleRespondToSuggestion = async (suggestion: EventSuggestion, response: 'accept' | 'counter' | 'ignore') => {
    console.log("handleRespondToSuggestion called", { suggestion, response });

    if (!raven) {
      console.error('Raven is not initialized');
      return;
    }
    const content = JSON.parse(suggestion.content);
    console.log('Parsed suggestion content:', content);

    if (response === 'accept') {
      setSelectedSuggestion(suggestion);
      setShowDialog(true);
    } else if (response === 'counter') {
      setTimeRange(content.timeRange);
      setStartDate(content.dateRange[0]);
      setEndDate(content.dateRange[1]);
      setRecipientPubKey(suggestion.creator);
      console.log('Set up counter suggestion', { timeRange: content.timeRange, startDate: content.dateRange[0], endDate: content.dateRange[1], recipientPubKey: suggestion.creator });
    } else {
      const responseMessage = JSON.stringify({
        type: 'event_response',
        originalSuggestionId: suggestion.id,
        response: 'ignored',
      });
      console.log('Sending ignore response:', responseMessage);
      try {
        setIsLoading(true);
        const result = await raven.sendDirectMessage(suggestion.creator, responseMessage, [], suggestion.proposalID);
        console.log('Ignore response sent:', result);
        setEventSuggestions(prevSuggestions => prevSuggestions.filter(s => s.id !== suggestion.id));
      } catch (error) {
        console.error('Error sending ignore response:', error);
        setSnackbarMessage(t('Failed to send ignore response. Please try again.'));
      } finally {
        setIsLoading(false);
      }
    }
    await fetchEventSuggestions(true);
  };

const handleCounter = (suggestion: EventSuggestion) => {
  const content = JSON.parse(suggestion.content);
  setTimeRange(content.timeRange);
  setStartDate(new Date(content.dateRange[0]).toISOString().split('T')[0]);
  setEndDate(new Date(content.dateRange[1]).toISOString().split('T')[0]);
  setRecipientPubKey(suggestion.creator);
  setIsCountering(true);
  setCounteredSuggestionId(suggestion.id);
};

const handleAccept = async (suggestion: EventSuggestion) => {
  setSelectedSuggestion(suggestion);
  setShowDialog(true);
};

const handleFinalizeEvent = async () => {
  if (!raven || !selectedSuggestion || !finalDateTime) {
    console.error('Missing required data for finalizing event', { raven, selectedSuggestion, finalDateTime });
    return;
  }

  const finalizeMessage = JSON.stringify({
    type: 'event_finalized',
    originalSuggestionId: selectedSuggestion.id,
    finalDateTime: finalDateTime,
    suggestedBy: selectedSuggestion.creator,
    ...JSON.parse(selectedSuggestion.content)
  });

  try {
    setIsLoading(true);
    const result = await raven.publishCalendarSuggestion(selectedSuggestion.creator, finalizeMessage);
    console.log('Finalize message sent:', result);
    setShowDialog(false);
    setEventSuggestions(prevSuggestions => prevSuggestions.filter(s => s.id !== selectedSuggestion.id));
    setFinalizedEvents(prevEvents => [...prevEvents, {
      ...selectedSuggestion,
      finalDateTime: finalDateTime
    }]);
    setSnackbarMessage(t('Event finalized successfully!'));
  } catch (error) {
    console.error('Error sending finalize message:', error);
    setSnackbarMessage(t('Failed to finalize event. Please try again.'));
  } finally {
    setIsLoading(false);
  }
};

  const formatPublicKey = (pubkey: string) => {
    return pubkey.slice(0, 8) + '...'; // or use nip19.npubEncode(pubkey) if available
  };

  const formatTimeRange = (range: [number, number] | undefined): string => {
    if (!range || !Array.isArray(range) || range.length < 2) {
      console.error('Invalid time range:', range);
      return 'Invalid time range';
    }
    return `${range[0]}:00 - ${range[1]}:00`;
  };

const formatDateRange = (start: string, end: string): string => {
  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
  };
  return `${formatDate(start)} - ${formatDate(end)}`;
};

  return (
    <>
      <Helmet>
        <title>{t("NostrChat - Calendar")}</title>
      </Helmet>
      <AppWrapper>
        <AppMenu />
        <AppContent>
          <Box sx={{ width: '100%', maxWidth: 600, mx: 'auto', mt: 4 }}>
            <Typography variant="h4" sx={{ mb: 4 }}>
              {isCountering ? t('Counter Event Suggestion') : t('Event Suggestion')}
            </Typography>
      <Box sx={{ mb: 2 }}>
        <FormControl fullWidth>
          <InputLabel id="contact-select-label">{t("Select Recipient")}</InputLabel>
          <Select
            labelId="contact-select-label"
            value={selectedContact}
            onChange={(e) => setSelectedContact(e.target.value as string)}
            label={t("Select Recipient")}
          >
            {directContacts.map((contact) => (
              <MenuItem key={contact.pub} value={contact.pub}>
                {profiles.find(p => p.creator === contact.pub)?.name || contact.npub}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
      </Box>
      <Box sx={{ mb: 2 }}>
        <TextField
          label={t('Start Date')}
          type="date"
          value={startDate}
          onChange={(e) => setStartDate(e.target.value)}
          fullWidth
          InputLabelProps={{
            shrink: true,
          }}
        />
      </Box>
      <Box sx={{ mb: 2 }}>
        <TextField
          label={t('End Date')}
          type="date"
          value={endDate}
          onChange={(e) => setEndDate(e.target.value)}
          fullWidth
          InputLabelProps={{
            shrink: true,
          }}
        />
      </Box>
      <Box sx={{ mb: 2 }}>
        <Slider
          value={timeRange}
          onChange={(_, newValue) => setTimeRange(newValue as [number, number])}
          valueLabelDisplay="auto"
          min={0}
          max={24}
          step={1}
          marks
          valueLabelFormat={(value) => `${value}:00`}
        />
        <Box sx={{ mt: 1 }}>{t('Time Range')}: {formatTimeRange(timeRange)}</Box>
      </Box>
      <Button 
        variant="contained" 
        onClick={handleSendSuggestion}
        disabled={!selectedContact}
      >
        {isCountering ? t('Send Counter Suggestion') : t('Send Event Suggestion')}
      </Button>

      <Typography variant="h5" sx={{ mt: 4, mb: 2 }}>{t('Received Event Suggestions')}</Typography>
      <Box sx={{ mt: 2 }}>
        {eventSuggestions.map(suggestion => {
          let content;
          try {
            content = JSON.parse(suggestion.content);
          } catch (e) {
            console.error('Error parsing suggestion content:', e);
            content = {};
          }
          console.log("Rendering suggestion with content:", content);
          return (
            <Box key={suggestion.id} sx={{ border: '1px solid #ccc', borderRadius: 2, p: 2, mb: 2 }}>
              <Box>{t('Suggested by')}: {profiles.find(p => p.creator === suggestion.creator)?.name || formatPublicKey(suggestion.creator)}</Box>
              <Box>{t('Suggested time range')}: {formatTimeRange(content.timeRange)}</Box>
<Box>
  {t('Suggested date range')}: {content.dateRange ? 
    formatDateRange(content.dateRange[0], content.dateRange[1]) 
    : 'Invalid date range'}
</Box>
<Box sx={{ mt: 1 }}>
  <Button onClick={() => handleAccept(suggestion)}>{t('Accept')}</Button>
  <Button onClick={() => handleCounter(suggestion)}>{t('Counter')}</Button>
  <Button onClick={() => handleIgnore(suggestion)}>{t('Ignore')}</Button>
</Box>
            </Box>
          );
        })}
      </Box>

<Typography variant="h5" sx={{ mt: 4, mb: 2 }}>{t('Finalized Events')}</Typography>
<Box sx={{ mt: 2 }}>
  {finalizedEvents.map(event => {
    let content;
    try {
      content = JSON.parse(event.content);
    } catch (e) {
      console.error('Error parsing event content:', e);
      content = {};
    }
    return (
      <Box key={event.id} sx={{ border: '1px solid #ccc', borderRadius: 2, p: 2, mb: 2 }}>
        <Box>{t('Suggested by')}: {profiles.find(p => p.creator === event.creator)?.name || formatPublicKey(event.creator)}</Box>
        <Box>{t('Suggested time range')}: {formatTimeRange(content.timeRange)}</Box>
        <Box>{t('Suggested date range')}: {content.dateRange ? 
          formatDateRange(content.dateRange[0], content.dateRange[1]) 
          : 'Invalid date range'}
        </Box>
        <Box>{t('Finalized date and time')}: {event.finalDateTime ? formatMessageDateTime(new Date(event.finalDateTime).getTime()) : 'Not set'}</Box>
      </Box>
    );
  })}
</Box>


      <Dialog open={showDialog} onClose={() => setShowDialog(false)}>
        <DialogTitle>{t('Finalize Event')}</DialogTitle>
        <DialogContent>
          <TextField
            label={t('Final Date and Time')}
            type="datetime-local"
            value={finalDateTime}
            onChange={(e) => setFinalDateTime(e.target.value)}
            fullWidth
            InputLabelProps={{
              shrink: true,
            }}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowDialog(false)}>{t('Cancel')}</Button>
          <Button onClick={handleFinalizeEvent} disabled={!finalDateTime}>{t('Finalize')}</Button>
        </DialogActions>
      </Dialog>
      
            <Snackbar
              open={!!snackbarMessage}
              autoHideDuration={6000}
              onClose={() => setSnackbarMessage(null)}
              message={snackbarMessage}
            />
          </Box>
        </AppContent>
      </AppWrapper>
    </>
  );
};

export default Calendar;
=== ./public-brand/index.tsx ===
import Box from '@mui/material/Box';
import {useNavigate} from '@reach/router';

const PublicBrand = () => {
    const navigate = useNavigate();
    return <Box sx={{
        position: 'absolute',
        left: '20px',
        top: '20px',
        height: '40px',
        display: 'flex',
        cursor: 'pointer'
    }} onClick={() => {
        navigate('/login').then();
    }}>
        <Box sx={{height: '40px'}} component='img' src='/logo-large-white.png'></Box>
    </Box>
}

export default PublicBrand;
=== ./channel-card/index.tsx ===
import React from 'react';
import { useAtom } from 'jotai';
import Box from '@mui/material/Box';
import Divider from '@mui/material/Divider';
import Button from '@mui/material/Button';
import Paper from '@mui/material/Paper';
import { useTheme } from '@mui/material/styles';
import useTranslation from 'hooks/use-translation';
import { Channel } from 'types';
import { keysAtom, leftChannelListAtom } from 'atoms';
import { truncate } from 'util/truncate';

const ChannelCard = (props: { channel: Channel, onJoin: () => void }) => {
  const { channel, onJoin } = props;
  const theme = useTheme();
  const [t] = useTranslation();
  const [keys] = useAtom(keysAtom);
  const [leftChannelList] = useAtom(leftChannelListAtom);

  const hasPicture = channel.picture.startsWith('https://');
  const left = leftChannelList.includes(channel.id);

  const join = () => onJoin();

  const renderAbout = () => {
    if (channel.about) {
      try {
        const parsedAbout = JSON.parse(channel.about);
        return truncate(parsedAbout.purpose || '', 360);
      } catch (error) {
        console.error('Error parsing channel about information:', error);
        return '';
      }
    }
    return '';
  };

  return (
    <Paper sx={{ textAlign: 'center', p: '20px' }}>
      {hasPicture && (
        <Box sx={{ mb: '10px' }}>
          <Box
            component="img"
            sx={{
              width: '140px',
              height: '140px',
              borderRadius: '50%',
            }}
            src={channel.picture}
            alt={channel.name}
          />
        </Box>
      )}
      <Box
        sx={{
          fontFamily: 'Faktum, sans-serif',
          fontSize: '1.1em',
        }}
      >
        {truncate(channel.name, 60)}
      </Box>
      <Divider sx={{ m: '12px 0' }} />
      {channel.about && (
        <Box
          sx={{
            color: theme.palette.primary.dark,
            fontSize: '0.9em',
            mb: '20px',
          }}
        >
          {renderAbout()}
        </Box>
      )}
      <Box>
        {left && (
          <Box
            sx={{
              mb: '20px',
              color: theme.palette.text.secondary,
              fontSize: '0.8em',
            }}
          >
            {t('You left this channel')}
          </Box>
        )}
        <Button variant="contained" onClick={join}>
          {keys ? (left ? t('Re-join') : t('Join')) : t('Login to Join')}
        </Button>
      </Box>
    </Paper>
  );
};

export default ChannelCard;=== ./LoadingComponent.tsx ===
import React from 'react';
import './loading.css'
const LoadingComponent = () => {
  return (
    <div className='loading_page'>
      <div className='lds_roller'>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
      </div>
    </div>
  );
};

export default LoadingComponent;
=== ./dashboard/index.tsx ===
import React from 'react';
import { Box, Typography, Button } from '@mui/material';
import { Channel, Message } from 'types';

interface DashboardProps {
  channel: Channel;
  messages: Message[];
}

const Dashboard: React.FC<DashboardProps> = ({ channel, messages }) => {
  return (
    <Box sx={{ p: 2 }}>
      <Typography variant="h4">Dashboard</Typography>
      
      {/* Committees */}
      <Box sx={{ mb: 4 }}>
        <Typography variant="h5">Committees</Typography>
        {/* Add committee information here */}
      </Box>

      {/* Proposal Details */}
      <Box sx={{ mb: 4 }}>
        <Typography variant="h5">Proposal Details</Typography>
        <Typography>Name: {channel.name}</Typography>
        <Typography>Creator: {channel.creator}</Typography>
        {/* Add more proposal details here */}
      </Box>

      {/* Activities */}
      <Box sx={{ mb: 4 }}>
        <Typography variant="h5">Activities</Typography>
        {messages.slice(0, 5).map((message) => (
          <Box key={message.id} sx={{ mb: 1 }}>
            <Typography>Contributor: {message.creator}</Typography>
            <Typography>Message: {message.content}</Typography>
          </Box>
        ))}
      </Box>

      {/* Rewards */}
      <Box>
        <Typography variant="h5">Rewards</Typography>
        <Typography>Reward distribution to be implemented</Typography>
      </Box>
    </Box>
  );
};

export default Dashboard;=== ./app-content-header-base/index.tsx ===
import React from 'react';
import {useAtom} from 'jotai';
import Box from '@mui/material/Box';
import IconButton from '@mui/material/IconButton';
import {useTheme} from '@mui/material/styles';

import useMediaBreakPoint from 'hooks/use-media-break-point';
import useStyles from 'hooks/use-styles';
import {appMenuAtom} from 'atoms';
import ChevronRight from 'svg/chevron-right';
import ChevronLeft from 'svg/chevron-left';

const AppContentHeaderBase = (props: { children: React.ReactNode }) => {
    const theme = useTheme();
    const styles = useStyles();
    const [appMenu, setAppMenu] = useAtom(appMenuAtom);
    const {isMd} = useMediaBreakPoint();

    const isSmallScreen = !isMd;

    return <Box>
        <Box sx={{
            // height: styles.headerHeight,
            display: 'flex',
            flexGrow: 0,
            flexShrink: 0,
            borderBottom: `1px solid ${theme.palette.divider}`,
            alignItems: 'center',
            pl: isSmallScreen ? '5px' : '20px'
        }}>
            {isSmallScreen && (
                <Box
                    sx={{
                        width: '40px',
                        flexShrink: 0,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        mr: '6px',
                    }}
                    onClick={() => {
                        setAppMenu(!appMenu)
                    }}>
                    <Box sx={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        borderRadius: '12px',
                        width: '36px',
                        height: '36px',
                        background: theme.palette.divider,
                    }}>
                        <IconButton>
                            {appMenu ? <ChevronRight height={24}/> : <ChevronLeft height={24}/>}
                        </IconButton>
                    </Box>
                </Box>
            )}
            {props.children}
        </Box>
    </Box>
}


export default AppContentHeaderBase;
=== ./picture-input/index.tsx ===
import TextField from '@mui/material/TextField';
import React from 'react';

const PictureInput = (props: { label: string, value: string, onChange: (value: string) => void, error: string }) => {
    const {label, value, onChange, error} = props;

    const changed = (e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>) => {
        onChange(e.target.value);
    };

    return <TextField label={label} value={value} onChange={changed} fullWidth autoComplete="off"
                      error={!!error} helperText={error || ' '}/>
}


export default PictureInput;
=== ./chat-input/editor/mention-list.tsx ===
import React, {forwardRef, useEffect, useImperativeHandle, useMemo, useState} from 'react';
import Box from '@mui/material/Box';
import uniqBy from 'lodash.uniqby';
import {useAtom} from 'jotai';
import {useTheme} from '@mui/material/styles';
import {grey} from '@mui/material/colors';
import useTranslation from 'hooks/use-translation';
import useLiveChannel from 'hooks/use-live-channel';
import useLivePublicMessages from 'hooks/use-live-public-messages';
import {MentionListProps, MentionListRef} from 'views/components/chat-input/editor/types';
import Avatar from 'views/components/avatar';
import {directMessageAtom, profilesAtom} from 'atoms';
import {notEmpty} from 'util/misc';


const MentionList = forwardRef<MentionListRef, MentionListProps>((props, ref) => {
    const {query} = props;
    const [profiles,] = useAtom(profilesAtom);
    const channel = useLiveChannel();
    const [directMessage,] = useAtom(directMessageAtom);
    const messages = useLivePublicMessages(channel?.id);

    const suggestionProfiles = useMemo(() => {
        if (channel) {
            return uniqBy(messages.map(m => profiles.find(x => x.creator === m.creator)).filter(notEmpty), 'creator')
        } else if (directMessage) {
            return profiles.filter(x => x.creator === directMessage);
        }

        return [];
    }, [channel, messages, directMessage, profiles]);

    const items = useMemo(() => suggestionProfiles.filter(x => x.name)
        .filter(x => x.name.toLowerCase().indexOf(query.toLowerCase()) > -1).slice(0, 10).map(x => ({
            name: x.name,
            id: x.creator,
            picture: x.picture
        })), [suggestionProfiles, query]);

    const [selectedIndex, setSelectedIndex] = useState(0);
    const theme = useTheme();
    const [t] = useTranslation();

    const selectItem = (index: number) => {
        const item = items[index]
        if (item) {
            props.command({id: item.id, label: item.name});
        }
    }

    const upHandler = () => {
        setSelectedIndex(((selectedIndex + items.length) - 1) % items.length);
    }

    const downHandler = () => {
        setSelectedIndex((selectedIndex + 1) % items.length);
    }

    const enterHandler = () => {
        selectItem(selectedIndex);
    }

    useEffect(() => setSelectedIndex(0), [items]);

    useImperativeHandle(ref, () => ({
        onKeyDown: ({event}) => {
            if (event.key === 'ArrowUp') {
                upHandler();
                return true;
            }

            if (event.key === 'ArrowDown') {
                downHandler();
                return true;
            }

            if (event.key === 'Enter') {
                enterHandler();
                return true;
            }

            return false;
        },
    }))

    return (
        <Box sx={{
            width: '100%',
            background: grey[900],
            boxShadow: theme.shadows[10],
            borderRadius: theme.shape.borderRadius,
            fontSize: '90%',
            p: '3px',
            color: grey[300],
        }}>
            {items.length ? items.map((item, index) => (
                <Box key={index} sx={{
                    display: 'flex',
                    alignItems: 'center',
                    p: '4px 14px',
                    cursor: 'pointer',
                    borderRadius: theme.shape.borderRadius,
                    background: index === selectedIndex ? grey[800] : null,
                    mb: index === items.length - 1 ? null : '4px',
                    ':hover': {
                        background: grey[800]
                    }
                }} onClick={() => selectItem(index)}>
                    <Avatar seed={item.id} size={20} src={item.picture}/>
                    <Box sx={{ml: '4px'}}>{item.name}</Box>
                </Box>
            )) : <Box sx={{p: '4px 14px',}}>{t('No result')}</Box>}
        </Box>
    )
});

export default MentionList;
=== ./chat-input/editor/index.tsx ===
import {useRef} from 'react';
import {Extension, ReactRenderer, useEditor} from '@tiptap/react';
import Document from '@tiptap/extension-document';
import Paragraph from '@tiptap/extension-paragraph';
import Text from '@tiptap/extension-text';
import History from '@tiptap/extension-history';
import {Mention} from '@tiptap/extension-mention';
import tippy, {GetReferenceClientRect, Instance} from 'tippy.js';
import {SuggestionProps} from '@tiptap/suggestion';
import MentionList from 'views/components/chat-input/editor/mention-list';
import {MentionListRef} from 'views/components/chat-input/editor/types';

const useMakeEditor = ({content, onUpdate}: { content: string, onUpdate: () => void }) => {
    const reactRenderer = useRef<ReactRenderer<MentionListRef> | null>(null);
    let saveTimer: any = null;

    return useEditor({
        extensions: [
            Document,
            Paragraph,
            Text,
            History,
            Extension.create({
                name: 'ShiftEnterExtension',
                addKeyboardShortcuts() {
                    return {
                        'Shift-Enter': () => this.editor.commands.first(({commands}) => [
                            () => commands.createParagraphNear(),
                            () => commands.liftEmptyBlock(),
                            () => commands.splitBlock(),
                        ]),
                        'Enter': () => true,
                    };
                },
            }),
            Mention.configure({
                HTMLAttributes: {
                    class: 'mention',
                },
                renderLabel({options, node}) {
                    const label = (options?.suggestion?.char as string) || '';
                    return `${label}${String(node?.attrs?.label)}`;
                },
                suggestion: {
                    render: () => {
                        let popup: Instance[];

                        return {
                            onStart: (props: Pick<SuggestionProps, 'editor' | 'clientRect'>) => {
                                reactRenderer.current = new ReactRenderer(MentionList, {
                                    props,
                                    editor: props.editor,
                                });

                                if (!props.clientRect) {
                                    return;
                                }

                                popup = tippy('body', {
                                    getReferenceClientRect: props.clientRect as GetReferenceClientRect,
                                    appendTo: () => document.body,
                                    content: reactRenderer.current.element,
                                    showOnCreate: true,
                                    interactive: true,
                                    trigger: 'manual',
                                    placement: 'top-start',
                                });
                            },
                            onUpdate(props: Pick<SuggestionProps, 'clientRect'>) {
                                if (reactRenderer.current) {
                                    reactRenderer.current.updateProps(props);
                                }

                                if (!props.clientRect) {
                                    return;
                                } else {
                                    popup[0].setProps({
                                        getReferenceClientRect: props.clientRect as GetReferenceClientRect,
                                    });
                                }
                            },
                            onKeyDown(props: { event: KeyboardEvent }) {
                                props.event.stopPropagation();
                                if (props.event.key === 'Escape') {
                                    popup[0].hide();

                                    return true;
                                }

                                if (reactRenderer.current && reactRenderer.current.ref) {
                                    return reactRenderer.current.ref?.onKeyDown(props);
                                } else {
                                    return false;
                                }
                            },
                            onExit() {
                                if (popup) {
                                    popup[0]?.destroy();
                                }
                                setTimeout(() => {
                                    if (reactRenderer.current) {
                                        reactRenderer.current.destroy();
                                    }
                                    reactRenderer.current = null;
                                }, 0);
                            },
                        };
                    },
                },
            }),
        ],
        content: content,
        onUpdate: () => {
            clearTimeout(saveTimer);
            saveTimer = setTimeout(() => {
                onUpdate();
            }, 200);
        },
    })
}

export default useMakeEditor;
=== ./chat-input/index.tsx ===
import React, {useEffect, useRef} from 'react';
import {EditorContent, JSONContent} from '@tiptap/react'
import Box from '@mui/material/Box';
import {useTheme} from '@mui/material/styles';
import {lighten} from '@mui/material';
import Button from '@mui/material/Button';
import {useAtom} from 'jotai';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import Tools from 'views/components/chat-input/tools';
import useMakeEditor from 'views/components/chat-input/editor';
import Send from 'svg/send';
import {getEditorValue, removeEditorValue, storeEditorValue} from 'local-storage';
import {PLATFORM} from 'const';
import { proposalCommitteesAtom, channelAtom } from 'atoms';
import { Committee, Channel } from 'types';

const ChatInput = (props: { separator: string, senderFn: (message: string, mentions: string[]) => Promise<any> }) => {
    const {senderFn, separator} = props;
    const theme = useTheme();
    const {isMd} = useMediaBreakPoint();
    const inputRef = useRef<HTMLDivElement | null>(null);
    const storageKey = `${separator}_msg`;

    const [proposalCommittees, setProposalCommittees] = useAtom(proposalCommitteesAtom);

    const save = () => {
        const val = editor?.getHTML();
        if (!val) {
            removeEditorValue(storageKey);
            return;
        }
        storeEditorValue(storageKey, val);
    }

    const editor = useMakeEditor({content: getEditorValue(storageKey) || '', onUpdate: save});

    useEffect(() => {
        editor?.commands.setContent(getEditorValue(storageKey) || '');
        if (PLATFORM === 'web') {
            editor?.commands.focus();
        }
    }, [storageKey]);

    function getMentions(data: JSONContent): string[] {
        const mentions = (data.content || []).flatMap(getMentions)
        if (data.type === 'mention' && data.attrs?.id) {
            mentions.push(data.attrs.id)
        }
        return [...new Set(mentions)];
    }

    const send = () => {
        const message = editor?.getText();
        if (!message) return;
        const json = editor?.getJSON();
        const mentions = json ? getMentions(json) : [];
        editor?.commands.setContent('');
        removeEditorValue(storageKey);
        return senderFn(message, mentions);
    }

    const insert = (text: string) => {
        editor?.commands.insertContent(text);
        editor?.commands.focus();
    }

    const addMember = (committeeId: string) => {
      setProposalCommittees((prevCommittees: Committee[]) => {
        return prevCommittees.map(committee => {
          if (committee.id === committeeId) {
            return {
              ...committee,
              members: [...committee.members, '']
            };
          }
          return committee;
        });
      });
    };

    const removeMember = (committeeId: string) => {
      setProposalCommittees((prevCommittees: Committee[]) => {
        return prevCommittees.map(committee => {
          if (committee.id === committeeId) {
            const updatedMembers = [...committee.members];
            updatedMembers.pop();
            return {
              ...committee,
              members: updatedMembers
            };
          }
          return committee;
        });
      });
    };

/*
        <div className="add-remove-buttons">
          <button onClick={() => addMember(committee.id)}>Add Member</button>
          <button onClick={() => removeMember(committee.id)}>Remove Member</button>
        </div>
*/

    return <Box sx={{
        p: `10px 10px 14px ${isMd ? '20px' : '10px'}`,
        flexGrow: 0,
        flexShrink: 0,
    }}>
<hr/>
<div className="committees">
  {proposalCommittees.map(committee => (
    <div key={committee.id} className="committee">
      <div className="committee-header">{committee.name}</div>
      <div className="committee-members">
        <p>Members: {committee.members.join(', ')}</p>
      </div>
    </div>
  ))}
</div>

        <Box sx={{
            background: theme.palette.divider,
            borderRadius: theme.shape.borderRadius,
        }}>
            <Box sx={{p: '1px 10px'}}>
                <EditorContent
                    editor={editor}
                    onKeyDown={(e) => {

                        if (!e.shiftKey && e.key === 'Enter') {
                            send();
                        }
                    }}/>
            </Box>
            <Box sx={{
                borderTop: `1px solid ${lighten(theme.palette.divider, 0.6)}`,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                padding: '6px',
                height: '60px',
            }}>
                <Box sx={{
                    pl: '12px',
                    display: 'flex',
                    alignItems: 'center',
                }}>
                    <Tools inputRef={inputRef} senderFn={(message: string) => {
                        return props.senderFn(message, [])
                    }} insertFn={insert}/>
                </Box>
                <Button variant="contained" size="small" color="primary" sx={{
                    minWidth: 'auto',
                    width: '28px',
                    height: '28px',
                    padding: '6px',
                    borderRadius: '10px'
                }} onClick={send}><Send height={32}/></Button>
            </Box>
        </Box>
    </Box>;
}

export default ChatInput;
=== ./chat-input/tools/emoji.tsx ===
import React, {useState} from 'react';
import Box from '@mui/material/Box';
import EmojiPicker from 'components/emoji-picker';
import usePopover from 'hooks/use-popover';
import useStyles from 'hooks/use-styles';
import EmoticonHappy from 'svg/emoticon-happy';

const Emoji = (props: { onSelect: (selected: string) => void }) => {
    const [, showPopover] = usePopover();
    const [hover, setHover] = useState<boolean>(false);
    const styles = useStyles();

    const emojiClicked = (event: React.MouseEvent<HTMLDivElement>) => {
        setHover(true);
        showPopover({
            body: <EmojiPicker onSelect={(emoji) => {
                setTimeout(() => {
                    props.onSelect(emoji);
                }, 200)
                showPopover(null);
                setHover(false);
            }}/>,
            anchorEl: event.currentTarget,
            onClose: () => {
                setHover(false);
            }
        });
    }

    return <Box sx={styles.chatInputToolSx} onClick={emojiClicked} className={hover ? 'hover' : ''}>
        <EmoticonHappy height={20}/>
    </Box>;
}

export default Emoji;
=== ./chat-input/tools/index.tsx ===
import {MutableRefObject, useEffect} from 'react';
import Emoji from 'views/components/chat-input/tools/emoji';
import Gif from 'views/components/chat-input/tools/gif';

const Tools = (props: { inputRef: MutableRefObject<HTMLDivElement | null>, insertFn: (text: string) => void, senderFn: (message: string) => void }) => {
    const {inputRef, insertFn, senderFn} = props;

    useEffect(() => {
        const onPaste = (e: ClipboardEvent) => {
            e.preventDefault();
            insertFn(e.clipboardData!.getData('text/plain'));
        }

        const onDrop = (e: DragEvent) => {
            e.preventDefault();
        }

        const input = inputRef.current;

        input?.addEventListener('paste', onPaste);
        input?.addEventListener('drop', onDrop);
        return () => {
            input?.removeEventListener('paste', onPaste);
            input?.removeEventListener('drop', onDrop);
        }
    }, []);

    return <>
        <Emoji onSelect={insertFn}/>
        {/* <Gif onSelect={senderFn}/> */}
    </>;
}

export default Tools;
=== ./chat-input/tools/gif.tsx ===
import React, {useState} from 'react';
import Box from '@mui/material/Box';
import GifPicker from 'components/gif-picker';
import usePopover from 'hooks/use-popover';
import useStyles from 'hooks/use-styles';
import GifIcon from 'svg/gif';

const Gif = (props: { onSelect: (selected: string) => void }) => {
    const [, showPopover] = usePopover();
    const [hover, setHover] = useState<boolean>(false);
    const styles = useStyles();

    const gifClicked = (event: React.MouseEvent<HTMLDivElement>) => {
        setHover(true);
        showPopover({
            body: <GifPicker onSelect={(gif) => {
                setTimeout(() => {
                    props.onSelect(gif);
                }, 200)
                showPopover(null);
                setHover(false);
            }}/>,
            anchorEl: event.currentTarget,
            onClose: () => {
                setHover(false);
            }
        });
    }

    return <Box onClick={gifClicked} sx={styles.chatInputToolSx} className={hover ? 'hover' : ''}>
        <GifIcon height={20}/>
    </Box>;
}

export default Gif;
=== ./chat-input/ProposalIndexExpired.tsx ===
import React, { useEffect, useRef } from 'react';
import { EditorContent, JSONContent } from '@tiptap/react';
import Box from '@mui/material/Box';
import { useTheme } from '@mui/material/styles';
import { IoWarningOutline } from 'react-icons/io5';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import useMakeEditor from 'views/components/chat-input/editor';
import {
  getEditorValue,
  removeEditorValue,
  storeEditorValue,
} from 'local-storage';
import { PLATFORM } from 'const';

const ProposalIndexExpired = (props: {
  separator: string;
  senderFn: (message: string, mentions: string[]) => Promise<any>;
}) => {
  const { senderFn, separator } = props;
  const theme = useTheme();
  const { isMd } = useMediaBreakPoint();
  const inputRef = useRef<HTMLDivElement | null>(null);
  const storageKey = `${separator}_msg`;

  const save = () => {
    const val = editor?.getHTML();
    if (!val) {
      removeEditorValue(storageKey);
      return;
    }
    storeEditorValue(storageKey, val);
  };

  const editor = useMakeEditor({
    content: getEditorValue(storageKey) || '',
    onUpdate: save,
  });

  useEffect(() => {
    editor?.commands.setContent(getEditorValue(storageKey) || '');
    if (PLATFORM === 'web') {
      editor?.commands.focus();
    }
  }, [storageKey]);
 

  return (
    <Box sx={{ p: 2, borderTop: '1px solid rgba(255, 255, 255, 0.12)' }}>
      <Box
        sx={{
          background: theme.palette.divider,
          borderRadius: theme.shape.borderRadius,
        }}
      >
        <Box sx={{ p: '10px 10px' }}>
          <p style={{ padding:'20px 10px' }}>
            <span style={{marginRight:'10px'}}>
              <IoWarningOutline />
            </span>
            Proposal Voting Period Expired !!
          </p>
        </Box>
      </Box>
    </Box>
  );
};

export default ProposalIndexExpired;
=== ./chat-input/ProposalIndex.tsx ===
import React, { useEffect, useRef } from 'react';
import { EditorContent, JSONContent } from '@tiptap/react';
import Box from '@mui/material/Box';
import { useTheme } from '@mui/material/styles';
import { lighten } from '@mui/material';
import Button from '@mui/material/Button';
import { FaArrowDown } from 'react-icons/fa';

import { useAtom } from 'jotai';
import { proposalCommitteesAtom } from 'atoms';

import useMediaBreakPoint from 'hooks/use-media-break-point';
import Tools from 'views/components/chat-input/tools';
import useMakeEditor from 'views/components/chat-input/editor';
import Send from 'svg/send';
import { getEditorValue, removeEditorValue, storeEditorValue } from 'local-storage';
import { PLATFORM } from 'const';
import { Committee } from 'types';

const ProposalChatInput = (props: { separator: string, senderFn: (message: string, mentions: string[]) => Promise<any>, isPermanentProposal?: boolean }) => {
  const { senderFn, separator, isPermanentProposal } = props;
  const theme = useTheme();
  const { isMd } = useMediaBreakPoint();
  const inputRef = useRef<HTMLDivElement | null>(null);
  const storageKey = `${separator}_msg`;
  
  const [proposalCommittees, setProposalCommittees] = useAtom(proposalCommitteesAtom);

    const save = () => {
        const val = editor?.getHTML();
        if (!val) {
            removeEditorValue(storageKey);
            return;
        }
        storeEditorValue(storageKey, val);
    }

    const editor = useMakeEditor({content: getEditorValue(storageKey) || '', onUpdate: save});

    useEffect(() => {
        editor?.commands.setContent(getEditorValue(storageKey) || '');
        if (PLATFORM === 'web') {
            editor?.commands.focus();
        }
    }, [storageKey]);

    function getMentions(data: JSONContent): string[] {
        const mentions = (data.content || []).flatMap(getMentions)
        if (data.type === 'mention' && data.attrs?.id) {
            mentions.push(data.attrs.id)
        }
        return [...new Set(mentions)];
    }

  const send = () => {
    const message = editor?.getText();
    if (!message) return;
    const json = editor?.getJSON();
    const mentions = json ? getMentions(json) : [];
    editor?.commands.setContent('');
    removeEditorValue(storageKey);
    return senderFn(message, mentions);
  };

    const insert = (text: string) => {
        editor?.commands.insertContent(text);
        editor?.commands.focus();
    }

    const addMember = (committeeId: string) => {
      setProposalCommittees((prevCommittees: Committee[]) => {
        return prevCommittees.map(committee => {
          if (committee.id === committeeId) {
            return {
              ...committee,
              members: [...committee.members, '']
            };
          }
          return committee;
        });
      });
    };

    const removeMember = (committeeId: string) => {
      setProposalCommittees((prevCommittees: Committee[]) => {
        return prevCommittees.map(committee => {
          if (committee.id === committeeId) {
            const updatedMembers = [...committee.members];
            updatedMembers.pop();
            return {
              ...committee,
              members: updatedMembers
            };
          }
          return committee;
        });
      });
    };

/*
<div className="add-remove-buttons">
                <button onClick={() => addMember(committee.id)}>Add Member</button>
                <button onClick={() => removeMember(committee.id)}>Remove Member</button>
              </div>
*/

  return (
    <Box sx={{ p: 2, borderTop: '1px solid rgba(255, 255, 255, 0.12)' }}>
      <hr/>
      <div className="committees">
        {proposalCommittees.map(committee => (
          <div key={committee.id} className="committee">
            <div className="committee-header">{committee.name}</div>
            <div className="committee-members">
              <p>Members: {committee.members.join(', ')}</p>
              
            </div>
          </div>
        ))}
      </div>
      <Box
        sx={{
          background: theme.palette.divider,
          borderRadius: theme.shape.borderRadius,
        }}
      >
        <Box sx={{ p: '1px 10px' }}>
          <p style={{ paddingTop: '10px' }}>
            <span>
              <FaArrowDown />
            </span>{' '}
            Share your thought about this Proposal
          </p>
          <EditorContent
            editor={editor}
            onKeyDown={e => {
              if (!e.shiftKey && e.key === 'Enter') {
                send();
              }
            }}
          />
        </Box>
        <Box
          sx={{
            borderTop: `1px solid ${lighten(theme.palette.divider, 0.6)}`,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            padding: '6px',
            height: '60px',
          }}
        >
          <Box
            sx={{
              pl: '12px',
              display: 'flex',
              alignItems: 'center',
            }}
          >
            <Tools
              inputRef={inputRef}
              senderFn={(message: string) => {
                return props.senderFn(message, []);
              }}
              insertFn={insert}
            />
          </Box>
          <Button
            variant="contained"
            size="small"
            color="primary"
            sx={{
              minWidth: 'auto',
              width: '28px',
              height: '28px',
              padding: '6px',
              borderRadius: '10px',
            }}
            onClick={send}
          >
            <Send height={32} />
          </Button>
        </Box>
      </Box>
    </Box>
  );
};

export default ProposalChatInput;=== ./message-view/index.tsx ===
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { useAtom } from 'jotai';
import uniq from 'lodash.uniq';
import { darken } from '@mui/material';
import Box from '@mui/material/Box';
import { useTheme } from '@mui/material/styles';
import Tooltip from '@mui/material/Tooltip';
import { grey } from '@mui/material/colors';
import { useNavigate } from '@reach/router';
import { nip19 } from 'nostr-tools';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import useContentRenderer from 'hooks/use-render-content';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import useTranslation from 'hooks/use-translation';
import useModal from 'hooks/use-modal';
import useStyles from 'hooks/use-styles';
import Avatar from 'views/components/avatar';
import ProfileDialog from 'views/components/dialogs/profile';
import MessageReactions from 'views/components/message-reactions';
import MessageMenuWeb from 'views/components/message-menu/web';
import MessageMobileMobile from 'views/components/message-menu/mobile';
import {
  activeMessageAtom,
  profilesAtom,
  threadRootAtom,
  spammersAtom,
} from 'atoms';
import { Message } from 'types';
import {
  formatMessageTime,
  formatMessageFromNow,
  formatMessageDateTime,
} from 'helper';
import ChevronRight from 'svg/chevron-right';
import { PLATFORM } from 'const';
import { truncateMiddle } from 'util/truncate';

const MessageView = (props: {
  message: Message;
  compactView: boolean;
  dateFormat: 'time' | 'fromNow';
  inThreadView?: boolean;
}) => {
  const { message, compactView, dateFormat, inThreadView } = props;
  const theme = useTheme();
  const styles = useStyles();
  const navigate = useNavigate();
  const [profiles] = useAtom(profilesAtom);
  const profile = profiles.find(x => x.creator === message.creator);
  const [threadRoot, setThreadRoot] = useAtom(threadRootAtom);
  const [activeMessage] = useAtom(activeMessageAtom);
  const [spammers] = useAtom(spammersAtom);
  const [t] = useTranslation();
  const [, showModal] = useModal();
  const { isMd } = useMediaBreakPoint();
  const renderer = useContentRenderer();
  const holderEl = useRef<HTMLDivElement | null>(null);
  const [menu, setMenu] = useState<boolean>(false);
  const [mobileMenu, setMobileMenu] = useState<boolean>(false);
  const [isVisible, setIsVisible] = useState<boolean>(true);
  const profileName = useMemo(
    () =>
      truncateMiddle(
        profile?.name || nip19.npubEncode(message.creator),
        isMd ? 40 : 22,
        ':'
      ),
    [profile, message]
  );
  const messageTime = useMemo(
    () =>
      dateFormat === 'time'
        ? formatMessageTime(message.created)
        : formatMessageFromNow(message.created),
    [message]
  );
  const messageDateTime = useMemo(
    () => formatMessageDateTime(message.created),
    [message]
  );
  const lastReply = useMemo(
    () =>
      message.children && message.children.length > 0
        ? formatMessageFromNow(
            message.children[message.children.length - 1].created
          )
        : null,
    [message]
  );
  let mobileMenuTimer: any = null;
  const canTouch = styles.canTouch();
  const canHover = styles.canHover();
  const [showSpammer, setShowSpammer] = useState<boolean>(false);
  const isSpammer = spammers[message.creator] !== undefined;
  const renderedBody = useMemo(() => {
    const sx = {
      fontSize: '.8em',
      background: grey[800],
      display: 'inline-flex',
      borderRadius: '6px',
      p: '0 6px',
      cursor: 'pointer',
      ':hover': {
        background: grey[600],
      },
    };
    if (isSpammer && !showSpammer) {
      return (
        <Box
          sx={sx}
          onClick={() => {
            setShowSpammer(true);
          }}
        >
          {t('This account appears to be a spammer. Click to show message.')}
        </Box>
      );
    } else if (isSpammer && showSpammer) {
      return (
        <>
          {renderer(message)}
          <Box
            sx={{ ...sx, mt: '10px' }}
            onClick={() => {
              setShowSpammer(false);
            }}
          >
            {t('Hide')}
          </Box>
        </>
      );
    } else {
      return renderer(message);
    }
  }, [message, isSpammer, showSpammer]);

  const profileClicked = () => {
    showModal({
      body: (
        <ProfileDialog
          profile={profile}
          pubkey={message.creator}
          onDM={() => {
            navigate(`/dm/${nip19.npubEncode(message.creator)}`).then();
          }}
        />
      ),
      maxWidth: 'xs',
      hideOnBackdrop: true,
    });
  };

  useEffect(() => {
    if (!holderEl.current) return;

    const observer = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) {
        setIsVisible(true);
      } else {
        setIsVisible(false);
      }
    });
    observer.observe(holderEl.current);

    return () => {
      observer.disconnect();
    };
  }, [isVisible]);

  useEffect(() => {
    if (mobileMenu && PLATFORM !== 'web') {
      // Send a small vibration
      Haptics.impact({ style: ImpactStyle.Light }).then();
    }
  }, [mobileMenu]);

  const ps = isMd ? '24px' : '10px';
  return (
    <Box
      data-visible={isVisible}
      data-id={message.id}
      className="message"
      ref={holderEl}
      sx={{
        display: 'flex',
        p: `${!compactView ? '15px' : '3px'} ${ps} 0 ${ps}`,
        position: 'relative',
        background:
          activeMessage === message.id || mobileMenu
            ? theme.palette.divider
            : null,
        ...styles.withHover({
          ':hover': {
            background: theme.palette.divider,
          },
        }),
        userSelect: canTouch ? 'none' : null,
      }}
      onMouseEnter={() => {
        if (canHover) setMenu(true);
      }}
      onMouseLeave={() => {
        if (canHover) setMenu(false);
      }}
      onTouchStart={() => {
        mobileMenuTimer = setTimeout(() => {
          setMobileMenu(true);
        }, 600);
      }}
      onTouchEnd={() => {
        clearTimeout(mobileMenuTimer);
      }}
      onTouchCancel={() => {
        clearTimeout(mobileMenuTimer);
      }}
      onTouchMove={() => {
        clearTimeout(mobileMenuTimer);
      }}
      onContextMenu={e => {
        if (canTouch) {
          // don't want to see context menu while using dev tools
          e.preventDefault();
        }
      }}
    >
      {(menu || activeMessage === message.id) && (
        <Box
          sx={{
            position: 'absolute',
            right: '10px',
            top: '-10px',
          }}
        >
          <MessageMenuWeb message={message} inThreadView={inThreadView} />
        </Box>
      )}
      <Box
        sx={{
          display: 'flex',
          width: '40px',
          flexGrow: 0,
          flexShrink: 0,
        }}
      >
        {compactView ? null : (
          <Box sx={{ cursor: 'pointer' }} onClick={profileClicked}>
            <Avatar src={profile?.picture} seed={message.creator} size={40} />
          </Box>
        )}
      </Box>
      <Box sx={{ flexGrow: 1, ml: '12px' }}>
        {!compactView && (
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              fontSize: '0.8em',
              lineHeight: '1em',
              mr: '12px',
              mb: '12px',
            }}
          >
            <Box
              onClick={profileClicked}
              sx={{
                fontWeight: '600',
                mr: '5px',
                cursor: 'pointer',
              }}
            >
              {profileName}
            </Box>
            <Tooltip title={messageDateTime} placement="right">
              <Box
                sx={{
                  color: darken(theme.palette.text.secondary, 0.3),
                  fontSize: '90%',
                  cursor: 'default',
                }}
              >
                {messageTime}
              </Box>
            </Tooltip>
          </Box>
        )}
        <Box
          sx={{
            fontSize: '0.9em',
            mt: '4px',
            wordBreak: 'break-word',
            lineHeight: '1.4em',
            color: theme.palette.text.secondary,
          }}
        >
          {renderedBody}
        </Box>
        {!inThreadView && message.children && message.children.length > 0 && (
          <Box
            sx={{
              p: '6px',
              mb: '4px',
              display: 'inline-flex',
              alignItems: 'center',
              fontSize: '0.8rem',
              cursor: 'pointer',
              border: '1px solid transparent',
              color: darken(theme.palette.text.secondary, 0.3),
              borderRadius: theme.shape.borderRadius,
              svg: {
                display: 'none',
              },
              ':hover': {
                borderColor: theme.palette.divider,
                background: theme.palette.background.paper,
                svg: {
                  display: 'block',
                },
              },
            }}
            onClick={() => {
              setThreadRoot(message);
            }}
          >
            {uniq(message.children.map(m => m.creator))
              .slice(0, 4)
              .map(c => {
                const profile = profiles.find(x => x.creator === c);
                return (
                  <Box
                    key={c}
                    sx={{
                      mr: '6px',
                      display: 'flex',
                      alignItems: 'center',
                    }}
                  >
                    <Avatar src={profile?.picture} seed={c} size={20} />
                  </Box>
                );
              })}
            <Box
              sx={{
                mr: '10px',
                color: theme.palette.primary.main,
                fontWeight: 'bold',
              }}
            >
              {message.children.length === 1
                ? t('1 reply')
                : t('{{n}} replies', { n: message.children.length })}
            </Box>
            {isMd && !threadRoot && (
              <>
                <Box sx={{ mr: '10px' }}>
                  {t('Last reply {{n}}', { n: lastReply! })}
                </Box>
                <ChevronRight height={20} />
              </>
            )}
          </Box>
        )}
        <MessageReactions message={message} />
        {mobileMenu && (
          <MessageMobileMobile
            message={message}
            profileName={profileName}
            inThreadView={inThreadView}
            onClose={() => {
              setMobileMenu(false);
            }}
          />
        )}
      </Box>
    </Box>
  );
};

export default MessageView;
=== ./message-view/ProposalMessageView.tsx ===
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { useAtom } from 'jotai';
import uniq from 'lodash.uniq';
import { darken } from '@mui/material';
import Box from '@mui/material/Box';
import { useTheme } from '@mui/material/styles';
import Tooltip from '@mui/material/Tooltip';
import { grey } from '@mui/material/colors';
import { useNavigate } from '@reach/router';
import { nip19 } from 'nostr-tools';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import useContentRenderer from 'hooks/use-render-content';
import useMediaBreakPoint from 'hooks/use-media-break-point';
import useTranslation from 'hooks/use-translation';
import useModal from 'hooks/use-modal';
import useStyles from 'hooks/use-styles';
import Avatar from 'views/components/avatar';
import ProfileDialog from 'views/components/dialogs/profile';
import MessageReactions from 'views/components/message-reactions';
import MessageMenuWeb from 'views/components/message-menu/web';
import MessageMobileMobile from 'views/components/message-menu/mobile';
import {
  activeMessageAtom,
  profilesAtom,
  threadRootAtom,
  spammersAtom,
} from 'atoms';
import { Message } from 'types';
import {
  formatMessageTime,
  formatMessageFromNow,
  formatMessageDateTime,
} from 'helper';
import ChevronRight from 'svg/chevron-right';
import { PLATFORM } from 'const';
import { truncateMiddle } from 'util/truncate';

const ProposalMessageView = (props: {
  message: Message;
  compactView: boolean;
  dateFormat: 'time' | 'fromNow';
  inThreadView?: boolean;
}) => {
  const { message, compactView, dateFormat, inThreadView } = props;
  const theme = useTheme();
  const styles = useStyles();
  const navigate = useNavigate();
  const [profiles] = useAtom(profilesAtom);
  const profile = profiles.find(x => x.creator === message.creator);
  const [threadRoot, setThreadRoot] = useAtom(threadRootAtom);
  const [activeMessage] = useAtom(activeMessageAtom);
  const [spammers] = useAtom(spammersAtom);
  const [t] = useTranslation();
  const [, showModal] = useModal();
  const { isMd } = useMediaBreakPoint();
  const renderer = useContentRenderer();
  const holderEl = useRef<HTMLDivElement | null>(null);
  const [menu, setMenu] = useState<boolean>(false);
  const [mobileMenu, setMobileMenu] = useState<boolean>(false);
  const [isVisible, setIsVisible] = useState<boolean>(true);
  const profileName = useMemo(
    () =>
      truncateMiddle(
        profile?.name || nip19.npubEncode(message.creator),
        isMd ? 40 : 22,
        ':'
      ),
    [profile, message]
  );
  const messageTime = useMemo(
    () =>
      dateFormat === 'time'
        ? formatMessageTime(message.created)
        : formatMessageFromNow(message.created),
    [message]
  );
  const messageDateTime = useMemo(
    () => formatMessageDateTime(message.created),
    [message]
  );
  const lastReply = useMemo(
    () =>
      message.children && message.children.length > 0
        ? formatMessageFromNow(
            message.children[message.children.length - 1].created
          )
        : null,
    [message]
  );
  let mobileMenuTimer: any = null;
  const canTouch = styles.canTouch();
  const canHover = styles.canHover();
  const [showSpammer, setShowSpammer] = useState<boolean>(false);
  const isSpammer = spammers[message.creator] !== undefined;
  const renderedBody = useMemo(() => {
    const sx = {
      fontSize: '.8em',
      background: grey[800],
      display: 'inline-flex',
      borderRadius: '6px',
      p: '0 6px',
      cursor: 'pointer',
      ':hover': {
        background: grey[600],
      },
    };
    if (isSpammer && !showSpammer) {
      return (
        <Box
          sx={sx}
          onClick={() => {
            setShowSpammer(true);
          }}
        >
          {t('This account appears to be a spammer. Click to show message.')}
        </Box>
      );
    } else if (isSpammer && showSpammer) {
      return (
        <>
          {renderer(message)}
          <Box
            sx={{ ...sx, mt: '10px' }}
            onClick={() => {
              setShowSpammer(false);
            }}
          >
            {t('Hide')}
          </Box>
        </>
      );
    } else {
      return renderer(message);
    }
  }, [message, isSpammer, showSpammer]);

  const profileClicked = () => {
    showModal({
      body: (
        <ProfileDialog
          profile={profile}
          pubkey={message.creator}
          onDM={() => {
            navigate(`/dm/${nip19.npubEncode(message.creator)}`).then();
          }}
        />
      ),
      maxWidth: 'xs',
      hideOnBackdrop: true,
    });
  };

  useEffect(() => {
    if (!holderEl.current) return;

    const observer = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) {
        setIsVisible(true);
      } else {
        setIsVisible(false);
      }
    });
    observer.observe(holderEl.current);

    return () => {
      observer.disconnect();
    };
  }, [isVisible]);

  useEffect(() => {
    if (mobileMenu && PLATFORM !== 'web') {
      // Send a small vibration
      Haptics.impact({ style: ImpactStyle.Light }).then();
    }
  }, [mobileMenu]);

  const ps = isMd ? '24px' : '10px';
  return (
    <Box
      data-visible={isVisible}
      data-id={message.id}
      className="message"
      ref={holderEl}
      sx={{
        display: 'flex',
        p: `${!compactView ? '15px' : '3px'} ${ps} 0 ${ps}`,
        position: 'relative',
        background:
          activeMessage === message.id || mobileMenu
            ? theme.palette.divider
            : null,
        ...styles.withHover({
          ':hover': {
            background: theme.palette.divider,
          },
        }),
        userSelect: canTouch ? 'none' : null,
      }}
      onMouseEnter={() => {
        if (canHover) setMenu(true);
      }}
      onMouseLeave={() => {
        if (canHover) setMenu(false);
      }}
      onTouchStart={() => {
        mobileMenuTimer = setTimeout(() => {
          setMobileMenu(true);
        }, 600);
      }}
      onTouchEnd={() => {
        clearTimeout(mobileMenuTimer);
      }}
      onTouchCancel={() => {
        clearTimeout(mobileMenuTimer);
      }}
      onTouchMove={() => {
        clearTimeout(mobileMenuTimer);
      }}
      onContextMenu={e => {
        if (canTouch) {
          // don't want to see context menu while using dev tools
          e.preventDefault();
        }
      }}
    >
      {/* {(menu || activeMessage === message.id) && (
        <Box
          sx={{
            position: 'absolute',
            right: '10px',
            top: '-10px',
          }}
        >
          <MessageMenuWeb message={message} inThreadView={inThreadView} />
        </Box>
      )} */}
      <Box
        sx={{
          display: 'flex',
          width: '40px',
          flexGrow: 0,
          flexShrink: 0,
        }}
      >
        {compactView ? null : (
          <Box sx={{ cursor: 'pointer' }} onClick={profileClicked}>
            <Avatar src={profile?.picture} seed={message.creator} size={40} />
          </Box>
        )}
      </Box>
      <Box sx={{ flexGrow: 1, ml: '12px' }}>
        {!compactView && (
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              fontSize: '0.8em',
              lineHeight: '1em',
              mr: '12px',
              mb: '12px',
            }}
          >
            <Box
              onClick={profileClicked}
              sx={{
                fontWeight: '600',
                mr: '5px',
                cursor: 'pointer',
              }}
            >
              {profileName}
            </Box>
        <MessageReactions message={message} />
            <Tooltip title={messageDateTime} placement="right">
              <Box
                sx={{
                  color: darken(theme.palette.text.secondary, 0.3),
                  fontSize: '90%',
                  cursor: 'default',
                }}
              >
                {messageTime}
              </Box>
            </Tooltip>
          </Box>
        )}
        <Box
          sx={{
            fontSize: '0.9em',
            mt: '4px',
            wordBreak: 'break-word',
            lineHeight: '1.4em',
            color: theme.palette.text.secondary,
          }}
        >
          {renderedBody}
        </Box>
        {!inThreadView && message.children && message.children.length > 0 && (
          <Box
            sx={{
              p: '6px',
              mb: '4px',
              display: 'inline-flex',
              alignItems: 'center',
              fontSize: '0.8rem',
              cursor: 'pointer',
              border: '1px solid transparent',
              color: darken(theme.palette.text.secondary, 0.3),
              borderRadius: theme.shape.borderRadius,
              svg: {
                display: 'none',
              },
              ':hover': {
                borderColor: theme.palette.divider,
                background: theme.palette.background.paper,
                svg: {
                  display: 'block',
                },
              },
            }}
            onClick={() => {
              setThreadRoot(message);
            }}
          >
            {uniq(message.children.map(m => m.creator))
              .slice(0, 4)
              .map(c => {
                const profile = profiles.find(x => x.creator === c);
                return (
                  <Box
                    key={c}
                    sx={{
                      mr: '6px',
                      display: 'flex',
                      alignItems: 'center',
                    }}
                  >
                    <Avatar src={profile?.picture} seed={c} size={20} />
                  </Box>
                );
              })}
            <Box
              sx={{
                mr: '10px',
                color: theme.palette.primary.main,
                fontWeight: 'bold',
              }}
            >
              {message.children.length === 1
                ? t('1 reply')
                : t('{{n}} replies', { n: message.children.length })}
            </Box>
            {isMd && !threadRoot && (
              <>
                <Box sx={{ mr: '10px' }}>
                  {t('Last reply {{n}}', { n: lastReply! })}
                </Box>
                <ChevronRight height={20} />
              </>
            )}
          </Box>
        )}
        <MessageReactions message={message} />
        {mobileMenu && (
          <MessageMobileMobile
            message={message}
            profileName={profileName}
            inThreadView={inThreadView}
            onClose={() => {
              setMobileMenu(false);
            }}
          />
        )}
      </Box>
    </Box>
  );
};

export default ProposalMessageView;
=== ./metadata-form/index.tsx ===
import React, { useEffect, useState } from 'react';
import Joi from 'joi';
import Box from '@mui/material/Box';
import TextField from '@mui/material/TextField';
import Button from '@mui/material/Button';
import { CircularProgress } from '@mui/material';
import { toast } from 'react-toastify';

import useTranslation from 'hooks/use-translation';
// import PictureInput from "views/components/picture-input";
import { Metadata } from 'types';
//import QRCode from 'qrcode';
import axios from 'axios';
import { UPLOAD_API_KEY, proposalTypes } from 'util/constant';

const MetadataForm = (props: {
  values?: Metadata;
  labels?: Metadata;
  submitBtnLabel: string;
  skipButton: React.ReactElement;
  onSubmit: (data: Metadata) => void;
  inProgress?: boolean;
}) => {
  const { skipButton, submitBtnLabel, values, labels, onSubmit, inProgress } =
    props;
  const [name, setName] = useState(values?.name || '');
  const [about, setAbout] = useState(values?.about || '');
  const [picture, setPicture] = useState(values?.picture || '');
  const [t] = useTranslation();
  const [error, setError] = useState('');
  const [errorMessage, setErrorMessage] = useState('');
  const [changed, setChanged] = useState(false);
  const [uploading, setUploading] = useState(false);

  useEffect(() => {
    if (values && !changed) {
      setName(values.name);
      setAbout(values.about);
      setPicture(values.picture);
    }
  }, [values]);

  const resetError = () => {
    setError('');
    setErrorMessage('');
  };

  const nameChanged = (
    e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    resetError();
    setName(e.target.value);
    setChanged(true);
  };

  const aboutChanged = (
    e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    resetError();
    setAbout(e.target.value);
    setChanged(true);
  };

  const pictureChanged = (picture: string) => {
    resetError();
    setPicture(picture);
    setChanged(true);
  };

  const handleFileUpload = (event: any) => {
    if (event.target.files[0]) {
      const formData = new FormData();
      formData.append('image', event.target.files[0]);
      setUploading(true);
      axios
        .post(`https://api.imgbb.com/1/upload?key=${UPLOAD_API_KEY}`, formData)
        .then((response: any) => {
          if (response.data) {
            console.log('file settled');
            pictureChanged(response.data.data.url);
          }
          setUploading(false);
        })
        .catch((error: any) => {
          console.error('Upload failed:', error);
        })
        .finally(() => {
          console.log('file upload done');
        });
    }
  };

  //  New proposal form
  const [proposalType, setProposalType] = useState('');
  const [formData, setFormData] = useState<{
    problem: string;
    solution: string;
    targetAudience: string;
    qualifications: string;
    purpose: string;
    approach: string;
    outcome: string;
    timeline: string;
    budget: string;
    callToAction: string;
    voting:object
  }>({
    problem: '',
    solution: '',
    targetAudience: '',
    qualifications: '',
    purpose: '',
    approach: '',
    outcome: '',
    timeline: '',
    budget: '',
    callToAction: '',
    voting:[]
  });
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleProposalTypeChange = (
    e: React.ChangeEvent<HTMLSelectElement>
  ) => {
    const selectedProposalType = e.target.value;
    setProposalType(selectedProposalType);

    // Find the selected proposal type from the proposalTypes array
    const selectedProposal = proposalTypes.find(
      type => type.name === selectedProposalType
    );

    if (selectedProposal) {
      // Update formData with purpose, approach, and outcome from selected proposal
      setFormData({
        ...formData,
        purpose: selectedProposal.purpose,
        approach: selectedProposal.approach,
        outcome: selectedProposal.outcome,
      });
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };
  const submit = () => {
    setIsSubmitting(true)
    const metadata = {
      name: formData.approach,
      about: JSON.stringify(formData),
      picture: picture,
    };
    onSubmit(metadata);
  };
  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <div>
          <div style={{ marginBottom: '20px' }}>
            <img
              className="user_pic"
              src={picture ? picture : '/img/proposal.png'}
            />
          </div>
          {uploading ? (
            <>
              <CircularProgress size={20} sx={{ mr: '8px' }} /> Uploading Image
              ...
            </>
          ) : (
            <Button
              variant="contained"
              onClick={e =>
                document.getElementById('upload_profile_pic')?.click()
              }
            >
              + Upload
            </Button>
          )}
          <br />
          <input
            style={{ visibility: 'hidden' }}
            onChange={e => handleFileUpload(e)}
            type="file"
            accept="image/x-png,image/gif,image/jpeg"
            id="upload_profile_pic"
          />
        </div>

        <div className="text-left">
          <div style={{ textAlign: 'left' }}>
            <label>Proposal Type:</label>
            <select
              className="form-control in_bg_tr"
              value={proposalType}
              onChange={handleProposalTypeChange}
            >
              <option value="">Select a proposal type</option>
              {proposalTypes.map((type, i) => (
                <option key={i} value={type.name}>
                  {type.name}
                </option>
              ))}
            </select>
          </div>
          {proposalType && (
            <>
              <div>
                <label>Purpose:</label>
                <textarea
                  name="purpose"
                  placeholder="Purpose"
                  className="no_border form-control in_bg_tr"
                  value={formData.purpose}
                  onChange={handleInputChange}
                />
              </div>
              <div>
                <label>Approach:</label>
                <textarea
                  className="no_border form-control in_bg_tr"
                  name="approach"
                  value={formData.approach}
                  onChange={handleInputChange}
                />
              </div>
              <div>
                <label>Outcome:</label>
                <textarea
                  className="no_border form-control in_bg_tr"
                  name="outcome"
                  value={formData.outcome}
                  onChange={handleInputChange}
                />
              </div>
            </>
          )}
          <div>
            <label>Problem:</label>
            <textarea
              className="form-control in_bg_tr"
              name="problem"
              value={formData.problem}
              onChange={handleInputChange}
            />
          </div>
          {proposalType && formData.problem ? (
            <button
              type="submit"
              className="btn btn_success mt-3"
              disabled={isSubmitting}
              onClick={e => submit()}
            >
              {isSubmitting ? 'Submitting...' : 'Submit'}
            </button>
          ) : (
            <button
              type="submit"
              className="btn btn_success mt-3"
              onClick={e => toast.error('Form incomplete, Fill it Up !')}
            >
              Submit
            </button>
          )}
        </div>
      </div>
    </>
  );
};

export default MetadataForm;=== ./metadata-form/loginForm.tsx ===
import React, { useEffect, useState } from "react";
import Joi from "joi";
import Box from "@mui/material/Box";
import TextField from "@mui/material/TextField";
import Button from "@mui/material/Button";
import { CircularProgress } from "@mui/material";
import QRCode from "qrcode.react";
import { nip19 } from "nostr-tools";

import useTranslation from "hooks/use-translation";
import { Metadata } from "types";
import axios from "axios";
import { useAtom } from "jotai";
import { keysAtom } from "atoms";
import { UPLOAD_API_KEY } from "util/constant";

const LoginMetadataForm = (props: {
  values?: Metadata;
  labels?: Metadata;
  submitBtnLabel: string;
  skipButton: React.ReactElement;
  onSubmit: (data: Metadata) => void;
  inProgress?: boolean;
}) => {
  const { skipButton, submitBtnLabel, values, labels, onSubmit, inProgress } =
    props;
  const [name, setName] = useState(values?.name || "");
  const [about, setAbout] = useState(values?.about || "");
  const [picture, setPicture] = useState(values?.picture || "");
  const [t] = useTranslation();
  const [error, setError] = useState("");
  const [errorMessage, setErrorMessage] = useState("");
  const [changed, setChanged] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [keys] = useAtom(keysAtom);

  useEffect(() => {
    if (values && !changed) {
      setName(values.name);
      setAbout(values.about);
      setPicture(values.picture);
    }
  }, [values]);

  const resetError = () => {
    setError("");
    setErrorMessage("");
  };

  const nameChanged = (
    e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    resetError();
    setName(e.target.value);
    setChanged(true);
  };

  const aboutChanged = (
    e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    resetError();
    setAbout(e.target.value);
    setChanged(true);
  };

  const pictureChanged = (picture: string) => {
    resetError();
    setPicture(picture);
    setChanged(true);
  };

  const submit = () => {
    const scheme = Joi.object({
      name: Joi.string().required(),
      about: Joi.string().empty(""),
      picture: Joi.string()
        .uri({ scheme: "https", allowRelative: false })
        .empty(""),
    }).messages({
      "string.uriCustomScheme": t(
        "Picture must be a valid uri with a scheme matching the https pattern"
      ),
    });

    const metadata = { name, about, picture };
    const validation = scheme.validate(metadata);

    if (validation.error) {
      setError(validation.error.details[0].path[0].toString() || "");
      setErrorMessage(validation.error.details[0].message);
      return;
    }

    onSubmit(metadata);
  };

  const handleFileUpload = (event: any) => {
    if (event.target.files[0]) {
      const formData = new FormData();
      formData.append("image", event.target.files[0]);
      setUploading(true);
      axios
        .post(`https://api.imgbb.com/1/upload?key=${UPLOAD_API_KEY}`, formData)
        .then((response: any) => {
          if (response.data) {
            pictureChanged(response.data.data.url);
          }
          setUploading(false);
        })
        .catch((error: any) => {
          console.error("Upload failed:", error);
        })
        .finally(() => {
          console.log("file upload done");
        });
    }
  };

  return (
    <>
      <div style={{ textAlign: "center" }}>
        <div>
          <div style={{ marginBottom: '20px' }}>
            {picture ? (
              <img className="user_pic" src={picture} />
            ) : (
              keys?.pub && (
                <QRCode
                  value={nip19.npubEncode(keys.pub)}
                  size={150}
                  includeMargin={false}
                  renderAs="svg"
                  style={{
                    width: '150px',
                    height: '150px',
                  }}
                />
              )
            )}
          </div>
          {uploading ? (
            <>
              <CircularProgress size={20} sx={{ mr: "8px" }} /> Uploading Image
              ...
            </>
          ) : (
            <Button
              variant="contained"
              onClick={(e) =>
                document.getElementById("upload_profile_pic")?.click()
              }
            >
              + Upload
            </Button>
          )}
          <br />
          <input
            style={{ visibility: "hidden" }}
            onChange={(e) => handleFileUpload(e)}
            type="file"
            accept="image/x-png,image/gif,image/jpeg"
            id="upload_profile_pic"
          />
        </div>
        <TextField
          label={t(labels?.name || "Name")}
          value={name}
          onChange={nameChanged}
          fullWidth
          autoFocus
          autoComplete="off"
          error={error === "name"}
          helperText={error === "name" ? errorMessage : " "}
        />

        <TextField
          label={t(labels?.about || "About")}
          value={about}
          onChange={aboutChanged}
          fullWidth
          autoComplete="off"
          helperText=""
        />
        <Box sx={{ display: "flex", justifyContent: "space-between" }}>
          <Button
            style={{ marginTop: "20px" }}
            variant="contained"
            disabled={inProgress}
            onClick={submit}
          >
            {inProgress ? "Updating ..." : submitBtnLabel}
          </Button>
        </Box>
      </div>
    </>
  );
};

export default LoginMetadataForm;
=== ./CredentialDisplayDialog/index.tsx ===
import React, { useState } from 'react';
import { 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions, 
  Button, 
  TextField
} from '@mui/material';

interface CredentialDisplayDialogProps {
  open: boolean;
  onClose: () => void;
  username: string;
  password: string;
}

const CredentialDisplayDialog: React.FC<CredentialDisplayDialogProps> = ({ 
  open, 
  onClose, 
  username, 
  password 
}) => {
  const [showPassword, setShowPassword] = useState(false);

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle>Your New Account Credentials</DialogTitle>
      <DialogContent>
        <p>Please copy and store these credentials in a safe place. You will need them to log in.</p>
        <TextField
          margin="dense"
          label="Username"
          type="text"
          fullWidth
          value={username}
          InputProps={{
            readOnly: true,
          }}
        />
        <TextField
          margin="dense"
          label="Password"
          type={showPassword ? 'text' : 'password'}
          fullWidth
          value={password}
          InputProps={{
            readOnly: true,
          }}
        />
        <Button onClick={() => setShowPassword(!showPassword)}>
          {showPassword ? 'Hide Password' : 'Show Password'}
        </Button>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Close</Button>
      </DialogActions>
    </Dialog>
  );
};

export default CredentialDisplayDialog;